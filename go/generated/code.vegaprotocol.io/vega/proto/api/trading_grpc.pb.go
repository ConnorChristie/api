// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package api

import (
	proto "code.vegaprotocol.io/vega/proto"
	context "context"
	empty "github.com/golang/protobuf/ptypes/empty"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion7

// TradingClient is the client API for Trading service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TradingClient interface {
	// Prepare a submit order request
	PrepareSubmitOrder(ctx context.Context, in *SubmitOrderRequest, opts ...grpc.CallOption) (*PrepareSubmitOrderResponse, error)
	// Prepare a cancel order request
	PrepareCancelOrder(ctx context.Context, in *CancelOrderRequest, opts ...grpc.CallOption) (*PrepareCancelOrderResponse, error)
	// Prepare an amend order request
	PrepareAmendOrder(ctx context.Context, in *AmendOrderRequest, opts ...grpc.CallOption) (*PrepareAmendOrderResponse, error)
	// Request a withdrawal
	PrepareWithdraw(ctx context.Context, in *PrepareWithdrawRequest, opts ...grpc.CallOption) (*PrepareWithdrawResponse, error)
	// Submit a signed transaction
	SubmitTransaction(ctx context.Context, in *SubmitTransactionRequest, opts ...grpc.CallOption) (*SubmitTransactionResponse, error)
	// Prepare a governance proposal
	PrepareProposal(ctx context.Context, in *PrepareProposalRequest, opts ...grpc.CallOption) (*PrepareProposalResponse, error)
	// Prepare a governance vote
	PrepareVote(ctx context.Context, in *PrepareVoteRequest, opts ...grpc.CallOption) (*PrepareVoteResponse, error)
	// Propagate a chain event
	PropagateChainEvent(ctx context.Context, in *PropagateChainEventRequest, opts ...grpc.CallOption) (*PropagateChainEventResponse, error)
	PrepareLiquidityProvision(ctx context.Context, in *PrepareLiquidityProvisionRequest, opts ...grpc.CallOption) (*PrepareLiquidityProvisionResponse, error)
}

type tradingClient struct {
	cc grpc.ClientConnInterface
}

func NewTradingClient(cc grpc.ClientConnInterface) TradingClient {
	return &tradingClient{cc}
}

func (c *tradingClient) PrepareSubmitOrder(ctx context.Context, in *SubmitOrderRequest, opts ...grpc.CallOption) (*PrepareSubmitOrderResponse, error) {
	out := new(PrepareSubmitOrderResponse)
	err := c.cc.Invoke(ctx, "/api.trading/PrepareSubmitOrder", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradingClient) PrepareCancelOrder(ctx context.Context, in *CancelOrderRequest, opts ...grpc.CallOption) (*PrepareCancelOrderResponse, error) {
	out := new(PrepareCancelOrderResponse)
	err := c.cc.Invoke(ctx, "/api.trading/PrepareCancelOrder", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradingClient) PrepareAmendOrder(ctx context.Context, in *AmendOrderRequest, opts ...grpc.CallOption) (*PrepareAmendOrderResponse, error) {
	out := new(PrepareAmendOrderResponse)
	err := c.cc.Invoke(ctx, "/api.trading/PrepareAmendOrder", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradingClient) PrepareWithdraw(ctx context.Context, in *PrepareWithdrawRequest, opts ...grpc.CallOption) (*PrepareWithdrawResponse, error) {
	out := new(PrepareWithdrawResponse)
	err := c.cc.Invoke(ctx, "/api.trading/PrepareWithdraw", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradingClient) SubmitTransaction(ctx context.Context, in *SubmitTransactionRequest, opts ...grpc.CallOption) (*SubmitTransactionResponse, error) {
	out := new(SubmitTransactionResponse)
	err := c.cc.Invoke(ctx, "/api.trading/SubmitTransaction", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradingClient) PrepareProposal(ctx context.Context, in *PrepareProposalRequest, opts ...grpc.CallOption) (*PrepareProposalResponse, error) {
	out := new(PrepareProposalResponse)
	err := c.cc.Invoke(ctx, "/api.trading/PrepareProposal", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradingClient) PrepareVote(ctx context.Context, in *PrepareVoteRequest, opts ...grpc.CallOption) (*PrepareVoteResponse, error) {
	out := new(PrepareVoteResponse)
	err := c.cc.Invoke(ctx, "/api.trading/PrepareVote", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradingClient) PropagateChainEvent(ctx context.Context, in *PropagateChainEventRequest, opts ...grpc.CallOption) (*PropagateChainEventResponse, error) {
	out := new(PropagateChainEventResponse)
	err := c.cc.Invoke(ctx, "/api.trading/PropagateChainEvent", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradingClient) PrepareLiquidityProvision(ctx context.Context, in *PrepareLiquidityProvisionRequest, opts ...grpc.CallOption) (*PrepareLiquidityProvisionResponse, error) {
	out := new(PrepareLiquidityProvisionResponse)
	err := c.cc.Invoke(ctx, "/api.trading/PrepareLiquidityProvision", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TradingServer is the server API for Trading service.
// All implementations must embed UnimplementedTradingServer
// for forward compatibility
type TradingServer interface {
	// Prepare a submit order request
	PrepareSubmitOrder(context.Context, *SubmitOrderRequest) (*PrepareSubmitOrderResponse, error)
	// Prepare a cancel order request
	PrepareCancelOrder(context.Context, *CancelOrderRequest) (*PrepareCancelOrderResponse, error)
	// Prepare an amend order request
	PrepareAmendOrder(context.Context, *AmendOrderRequest) (*PrepareAmendOrderResponse, error)
	// Request a withdrawal
	PrepareWithdraw(context.Context, *PrepareWithdrawRequest) (*PrepareWithdrawResponse, error)
	// Submit a signed transaction
	SubmitTransaction(context.Context, *SubmitTransactionRequest) (*SubmitTransactionResponse, error)
	// Prepare a governance proposal
	PrepareProposal(context.Context, *PrepareProposalRequest) (*PrepareProposalResponse, error)
	// Prepare a governance vote
	PrepareVote(context.Context, *PrepareVoteRequest) (*PrepareVoteResponse, error)
	// Propagate a chain event
	PropagateChainEvent(context.Context, *PropagateChainEventRequest) (*PropagateChainEventResponse, error)
	PrepareLiquidityProvision(context.Context, *PrepareLiquidityProvisionRequest) (*PrepareLiquidityProvisionResponse, error)
	mustEmbedUnimplementedTradingServer()
}

// UnimplementedTradingServer must be embedded to have forward compatible implementations.
type UnimplementedTradingServer struct {
}

func (UnimplementedTradingServer) PrepareSubmitOrder(context.Context, *SubmitOrderRequest) (*PrepareSubmitOrderResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PrepareSubmitOrder not implemented")
}
func (UnimplementedTradingServer) PrepareCancelOrder(context.Context, *CancelOrderRequest) (*PrepareCancelOrderResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PrepareCancelOrder not implemented")
}
func (UnimplementedTradingServer) PrepareAmendOrder(context.Context, *AmendOrderRequest) (*PrepareAmendOrderResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PrepareAmendOrder not implemented")
}
func (UnimplementedTradingServer) PrepareWithdraw(context.Context, *PrepareWithdrawRequest) (*PrepareWithdrawResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PrepareWithdraw not implemented")
}
func (UnimplementedTradingServer) SubmitTransaction(context.Context, *SubmitTransactionRequest) (*SubmitTransactionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubmitTransaction not implemented")
}
func (UnimplementedTradingServer) PrepareProposal(context.Context, *PrepareProposalRequest) (*PrepareProposalResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PrepareProposal not implemented")
}
func (UnimplementedTradingServer) PrepareVote(context.Context, *PrepareVoteRequest) (*PrepareVoteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PrepareVote not implemented")
}
func (UnimplementedTradingServer) PropagateChainEvent(context.Context, *PropagateChainEventRequest) (*PropagateChainEventResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PropagateChainEvent not implemented")
}
func (UnimplementedTradingServer) PrepareLiquidityProvision(context.Context, *PrepareLiquidityProvisionRequest) (*PrepareLiquidityProvisionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PrepareLiquidityProvision not implemented")
}
func (UnimplementedTradingServer) mustEmbedUnimplementedTradingServer() {}

// UnsafeTradingServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TradingServer will
// result in compilation errors.
type UnsafeTradingServer interface {
	mustEmbedUnimplementedTradingServer()
}

func RegisterTradingServer(s grpc.ServiceRegistrar, srv TradingServer) {
	s.RegisterService(&_Trading_serviceDesc, srv)
}

func _Trading_PrepareSubmitOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SubmitOrderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradingServer).PrepareSubmitOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.trading/PrepareSubmitOrder",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradingServer).PrepareSubmitOrder(ctx, req.(*SubmitOrderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Trading_PrepareCancelOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CancelOrderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradingServer).PrepareCancelOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.trading/PrepareCancelOrder",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradingServer).PrepareCancelOrder(ctx, req.(*CancelOrderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Trading_PrepareAmendOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AmendOrderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradingServer).PrepareAmendOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.trading/PrepareAmendOrder",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradingServer).PrepareAmendOrder(ctx, req.(*AmendOrderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Trading_PrepareWithdraw_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PrepareWithdrawRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradingServer).PrepareWithdraw(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.trading/PrepareWithdraw",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradingServer).PrepareWithdraw(ctx, req.(*PrepareWithdrawRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Trading_SubmitTransaction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SubmitTransactionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradingServer).SubmitTransaction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.trading/SubmitTransaction",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradingServer).SubmitTransaction(ctx, req.(*SubmitTransactionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Trading_PrepareProposal_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PrepareProposalRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradingServer).PrepareProposal(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.trading/PrepareProposal",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradingServer).PrepareProposal(ctx, req.(*PrepareProposalRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Trading_PrepareVote_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PrepareVoteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradingServer).PrepareVote(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.trading/PrepareVote",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradingServer).PrepareVote(ctx, req.(*PrepareVoteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Trading_PropagateChainEvent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PropagateChainEventRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradingServer).PropagateChainEvent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.trading/PropagateChainEvent",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradingServer).PropagateChainEvent(ctx, req.(*PropagateChainEventRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Trading_PrepareLiquidityProvision_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PrepareLiquidityProvisionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradingServer).PrepareLiquidityProvision(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.trading/PrepareLiquidityProvision",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradingServer).PrepareLiquidityProvision(ctx, req.(*PrepareLiquidityProvisionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Trading_serviceDesc = grpc.ServiceDesc{
	ServiceName: "api.trading",
	HandlerType: (*TradingServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "PrepareSubmitOrder",
			Handler:    _Trading_PrepareSubmitOrder_Handler,
		},
		{
			MethodName: "PrepareCancelOrder",
			Handler:    _Trading_PrepareCancelOrder_Handler,
		},
		{
			MethodName: "PrepareAmendOrder",
			Handler:    _Trading_PrepareAmendOrder_Handler,
		},
		{
			MethodName: "PrepareWithdraw",
			Handler:    _Trading_PrepareWithdraw_Handler,
		},
		{
			MethodName: "SubmitTransaction",
			Handler:    _Trading_SubmitTransaction_Handler,
		},
		{
			MethodName: "PrepareProposal",
			Handler:    _Trading_PrepareProposal_Handler,
		},
		{
			MethodName: "PrepareVote",
			Handler:    _Trading_PrepareVote_Handler,
		},
		{
			MethodName: "PropagateChainEvent",
			Handler:    _Trading_PropagateChainEvent_Handler,
		},
		{
			MethodName: "PrepareLiquidityProvision",
			Handler:    _Trading_PrepareLiquidityProvision_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/trading.proto",
}

// TradingDataClient is the client API for TradingData service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TradingDataClient interface {
	// Get a list of Accounts by Market
	MarketAccounts(ctx context.Context, in *MarketAccountsRequest, opts ...grpc.CallOption) (*MarketAccountsResponse, error)
	// Get a list of Accounts by Party
	PartyAccounts(ctx context.Context, in *PartyAccountsRequest, opts ...grpc.CallOption) (*PartyAccountsResponse, error)
	// Get the list of infrastructure fees accounts filter eventually by assets
	FeeInfrastructureAccounts(ctx context.Context, in *FeeInfrastructureAccountsRequest, opts ...grpc.CallOption) (*FeeInfrastructureAccountsResponse, error)
	// Get a list of Candles by Market
	Candles(ctx context.Context, in *CandlesRequest, opts ...grpc.CallOption) (*CandlesResponse, error)
	// Get Market Data by MarketID
	MarketDataByID(ctx context.Context, in *MarketDataByIDRequest, opts ...grpc.CallOption) (*MarketDataByIDResponse, error)
	// Get a list of Market Data
	MarketsData(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*MarketsDataResponse, error)
	// Get a Market by ID
	MarketByID(ctx context.Context, in *MarketByIDRequest, opts ...grpc.CallOption) (*MarketByIDResponse, error)
	// Get Market Depth
	MarketDepth(ctx context.Context, in *MarketDepthRequest, opts ...grpc.CallOption) (*MarketDepthResponse, error)
	// Get a list of Markets
	Markets(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*MarketsResponse, error)
	// Get an Order by Market and OrderID
	OrderByMarketAndID(ctx context.Context, in *OrderByMarketAndIdRequest, opts ...grpc.CallOption) (*OrderByMarketAndIdResponse, error)
	// Get an Order by Pending Order reference (UUID)
	OrderByReference(ctx context.Context, in *OrderByReferenceRequest, opts ...grpc.CallOption) (*OrderByReferenceResponse, error)
	// Get a list of Orders by Market
	OrdersByMarket(ctx context.Context, in *OrdersByMarketRequest, opts ...grpc.CallOption) (*OrdersByMarketResponse, error)
	// Get a list of Orders by Party
	OrdersByParty(ctx context.Context, in *OrdersByPartyRequest, opts ...grpc.CallOption) (*OrdersByPartyResponse, error)
	// Get a specific order by orderID
	OrderByID(ctx context.Context, in *OrderByIDRequest, opts ...grpc.CallOption) (*proto.Order, error)
	// Get all versions of the order by its orderID
	OrderVersionsByID(ctx context.Context, in *OrderVersionsByIDRequest, opts ...grpc.CallOption) (*OrderVersionsResponse, error)
	// Get Margin Levels by PartyID
	MarginLevels(ctx context.Context, in *MarginLevelsRequest, opts ...grpc.CallOption) (*MarginLevelsResponse, error)
	// Get a list of Parties
	Parties(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*PartiesResponse, error)
	// Get a Party by ID
	PartyByID(ctx context.Context, in *PartyByIDRequest, opts ...grpc.CallOption) (*PartyByIDResponse, error)
	// Get a list of Positions by Party
	PositionsByParty(ctx context.Context, in *PositionsByPartyRequest, opts ...grpc.CallOption) (*PositionsByPartyResponse, error)
	// Get latest Trade
	LastTrade(ctx context.Context, in *LastTradeRequest, opts ...grpc.CallOption) (*LastTradeResponse, error)
	// Get a list of Trades by Market
	TradesByMarket(ctx context.Context, in *TradesByMarketRequest, opts ...grpc.CallOption) (*TradesByMarketResponse, error)
	// Get a list of Trades by Order
	TradesByOrder(ctx context.Context, in *TradesByOrderRequest, opts ...grpc.CallOption) (*TradesByOrderResponse, error)
	// Get a list of Trades by Party
	TradesByParty(ctx context.Context, in *TradesByPartyRequest, opts ...grpc.CallOption) (*TradesByPartyResponse, error)
	// Get governance data (proposals and votes) for all proposals
	GetProposals(ctx context.Context, in *GetProposalsRequest, opts ...grpc.CallOption) (*GetProposalsResponse, error)
	// Get governance data (proposals and votes) for proposals by party authoring them
	GetProposalsByParty(ctx context.Context, in *GetProposalsByPartyRequest, opts ...grpc.CallOption) (*GetProposalsByPartyResponse, error)
	// Get votes by party casting them
	GetVotesByParty(ctx context.Context, in *GetVotesByPartyRequest, opts ...grpc.CallOption) (*GetVotesByPartyResponse, error)
	// Get governance data (proposals and votes) for proposals that aim creating new markets
	GetNewMarketProposals(ctx context.Context, in *GetNewMarketProposalsRequest, opts ...grpc.CallOption) (*GetNewMarketProposalsResponse, error)
	// Get governance data (proposals and votes) for proposals that aim updating markets
	GetUpdateMarketProposals(ctx context.Context, in *GetUpdateMarketProposalsRequest, opts ...grpc.CallOption) (*GetUpdateMarketProposalsResponse, error)
	// Get governance data (proposals and votes) for proposals that aim updating Vega network parameters
	GetNetworkParametersProposals(ctx context.Context, in *GetNetworkParametersProposalsRequest, opts ...grpc.CallOption) (*GetNetworkParametersProposalsResponse, error)
	// Get governance data (proposals and votes) for proposals aiming to create new assets
	GetNewAssetProposals(ctx context.Context, in *GetNewAssetProposalsRequest, opts ...grpc.CallOption) (*GetNewAssetProposalsResponse, error)
	// Get governance data (proposals and votes) for a proposal located by ID
	GetProposalByID(ctx context.Context, in *GetProposalByIDRequest, opts ...grpc.CallOption) (*GetProposalByIDResponse, error)
	// Get governance data (proposals and votes) for a proposal located by reference
	GetProposalByReference(ctx context.Context, in *GetProposalByReferenceRequest, opts ...grpc.CallOption) (*GetProposalByReferenceResponse, error)
	// Subscribe to a stream of all governance updates
	ObserveGovernance(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (TradingData_ObserveGovernanceClient, error)
	// Subscribe to a stream of proposal updates
	ObservePartyProposals(ctx context.Context, in *ObservePartyProposalsRequest, opts ...grpc.CallOption) (TradingData_ObservePartyProposalsClient, error)
	// Subscribe to a stream of votes cast by a specific party
	ObservePartyVotes(ctx context.Context, in *ObservePartyVotesRequest, opts ...grpc.CallOption) (TradingData_ObservePartyVotesClient, error)
	// Subscribe to a stream of proposal votes
	ObserveProposalVotes(ctx context.Context, in *ObserveProposalVotesRequest, opts ...grpc.CallOption) (TradingData_ObserveProposalVotesClient, error)
	// Subscribe to a stream of events from the core
	ObserveEventBus(ctx context.Context, opts ...grpc.CallOption) (TradingData_ObserveEventBusClient, error)
	// Get Statistics
	Statistics(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*proto.Statistics, error)
	// Get Time
	GetVegaTime(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*VegaTimeResponse, error)
	// Subscribe to a stream of Accounts
	AccountsSubscribe(ctx context.Context, in *AccountsSubscribeRequest, opts ...grpc.CallOption) (TradingData_AccountsSubscribeClient, error)
	// Subscribe to a stream of Candles
	CandlesSubscribe(ctx context.Context, in *CandlesSubscribeRequest, opts ...grpc.CallOption) (TradingData_CandlesSubscribeClient, error)
	// Subscribe to a stream of Margin Levels
	MarginLevelsSubscribe(ctx context.Context, in *MarginLevelsSubscribeRequest, opts ...grpc.CallOption) (TradingData_MarginLevelsSubscribeClient, error)
	// Subscribe to a stream of Market Depth
	MarketDepthSubscribe(ctx context.Context, in *MarketDepthSubscribeRequest, opts ...grpc.CallOption) (TradingData_MarketDepthSubscribeClient, error)
	// Subscribe to a stream of Market Depth PriceLevel Updates
	MarketDepthUpdatesSubscribe(ctx context.Context, in *MarketDepthUpdatesSubscribeRequest, opts ...grpc.CallOption) (TradingData_MarketDepthUpdatesSubscribeClient, error)
	// Subscribe to a stream of Markets Data
	MarketsDataSubscribe(ctx context.Context, in *MarketsDataSubscribeRequest, opts ...grpc.CallOption) (TradingData_MarketsDataSubscribeClient, error)
	// Subscribe to a stream of Orders
	OrdersSubscribe(ctx context.Context, in *OrdersSubscribeRequest, opts ...grpc.CallOption) (TradingData_OrdersSubscribeClient, error)
	// Subscribe to a stream of Positions
	PositionsSubscribe(ctx context.Context, in *PositionsSubscribeRequest, opts ...grpc.CallOption) (TradingData_PositionsSubscribeClient, error)
	// Subscribe to a stream of Trades
	TradesSubscribe(ctx context.Context, in *TradesSubscribeRequest, opts ...grpc.CallOption) (TradingData_TradesSubscribeClient, error)
	// Subscribe to a stream of Transfer Responses
	TransferResponsesSubscribe(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (TradingData_TransferResponsesSubscribeClient, error)
	// Get an aggregate of signatures from all the nodes of the network.
	GetNodeSignaturesAggregate(ctx context.Context, in *GetNodeSignaturesAggregateRequest, opts ...grpc.CallOption) (*GetNodeSignaturesAggregateResponse, error)
	// Get an asset by its identifier.
	AssetByID(ctx context.Context, in *AssetByIDRequest, opts ...grpc.CallOption) (*AssetByIDResponse, error)
	// Get a list of all assets on Vega.
	Assets(ctx context.Context, in *AssetsRequest, opts ...grpc.CallOption) (*AssetsResponse, error)
	// Get an estimate for the fee to be paid for a given order
	EstimateFee(ctx context.Context, in *EstimateFeeRequest, opts ...grpc.CallOption) (*EstimateFeeResponse, error)
	// Get an estimate for the margin required for a new order
	EstimateMargin(ctx context.Context, in *EstimateMarginRequest, opts ...grpc.CallOption) (*EstimateMarginResponse, error)
	// Get the bundle approval for an ERC20 withdrawal
	// these data are being used to bundle the call to the smart contract on the ethereum bridge
	ERC20WithdrawalApproval(ctx context.Context, in *ERC20WithdrawalApprovalRequest, opts ...grpc.CallOption) (*ERC20WithdrawalApprovalResponse, error)
	// Get a withdrawal by its ID
	Withdrawal(ctx context.Context, in *WithdrawalRequest, opts ...grpc.CallOption) (*WithdrawalResponse, error)
	// Get withdrawals for a party
	Withdrawals(ctx context.Context, in *WithdrawalsRequest, opts ...grpc.CallOption) (*WithdrawalsResponse, error)
	// Get a deposit by its ID
	Deposit(ctx context.Context, in *DepositRequest, opts ...grpc.CallOption) (*DepositResponse, error)
	// Get withdrawals for a party
	Deposits(ctx context.Context, in *DepositsRequest, opts ...grpc.CallOption) (*DepositsResponse, error)
	// Get the network parameters
	NetworkParameters(ctx context.Context, in *NetworkParametersRequest, opts ...grpc.CallOption) (*NetworkParametersResponse, error)
	// Get the liquidity provision orders
	LiquidityProvisions(ctx context.Context, in *LiquidityProvisionsRequest, opts ...grpc.CallOption) (*LiquidityProvisionsResponse, error)
}

type tradingDataClient struct {
	cc grpc.ClientConnInterface
}

func NewTradingDataClient(cc grpc.ClientConnInterface) TradingDataClient {
	return &tradingDataClient{cc}
}

func (c *tradingDataClient) MarketAccounts(ctx context.Context, in *MarketAccountsRequest, opts ...grpc.CallOption) (*MarketAccountsResponse, error) {
	out := new(MarketAccountsResponse)
	err := c.cc.Invoke(ctx, "/api.trading_data/MarketAccounts", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradingDataClient) PartyAccounts(ctx context.Context, in *PartyAccountsRequest, opts ...grpc.CallOption) (*PartyAccountsResponse, error) {
	out := new(PartyAccountsResponse)
	err := c.cc.Invoke(ctx, "/api.trading_data/PartyAccounts", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradingDataClient) FeeInfrastructureAccounts(ctx context.Context, in *FeeInfrastructureAccountsRequest, opts ...grpc.CallOption) (*FeeInfrastructureAccountsResponse, error) {
	out := new(FeeInfrastructureAccountsResponse)
	err := c.cc.Invoke(ctx, "/api.trading_data/FeeInfrastructureAccounts", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradingDataClient) Candles(ctx context.Context, in *CandlesRequest, opts ...grpc.CallOption) (*CandlesResponse, error) {
	out := new(CandlesResponse)
	err := c.cc.Invoke(ctx, "/api.trading_data/Candles", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradingDataClient) MarketDataByID(ctx context.Context, in *MarketDataByIDRequest, opts ...grpc.CallOption) (*MarketDataByIDResponse, error) {
	out := new(MarketDataByIDResponse)
	err := c.cc.Invoke(ctx, "/api.trading_data/MarketDataByID", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradingDataClient) MarketsData(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*MarketsDataResponse, error) {
	out := new(MarketsDataResponse)
	err := c.cc.Invoke(ctx, "/api.trading_data/MarketsData", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradingDataClient) MarketByID(ctx context.Context, in *MarketByIDRequest, opts ...grpc.CallOption) (*MarketByIDResponse, error) {
	out := new(MarketByIDResponse)
	err := c.cc.Invoke(ctx, "/api.trading_data/MarketByID", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradingDataClient) MarketDepth(ctx context.Context, in *MarketDepthRequest, opts ...grpc.CallOption) (*MarketDepthResponse, error) {
	out := new(MarketDepthResponse)
	err := c.cc.Invoke(ctx, "/api.trading_data/MarketDepth", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradingDataClient) Markets(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*MarketsResponse, error) {
	out := new(MarketsResponse)
	err := c.cc.Invoke(ctx, "/api.trading_data/Markets", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradingDataClient) OrderByMarketAndID(ctx context.Context, in *OrderByMarketAndIdRequest, opts ...grpc.CallOption) (*OrderByMarketAndIdResponse, error) {
	out := new(OrderByMarketAndIdResponse)
	err := c.cc.Invoke(ctx, "/api.trading_data/OrderByMarketAndID", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradingDataClient) OrderByReference(ctx context.Context, in *OrderByReferenceRequest, opts ...grpc.CallOption) (*OrderByReferenceResponse, error) {
	out := new(OrderByReferenceResponse)
	err := c.cc.Invoke(ctx, "/api.trading_data/OrderByReference", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradingDataClient) OrdersByMarket(ctx context.Context, in *OrdersByMarketRequest, opts ...grpc.CallOption) (*OrdersByMarketResponse, error) {
	out := new(OrdersByMarketResponse)
	err := c.cc.Invoke(ctx, "/api.trading_data/OrdersByMarket", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradingDataClient) OrdersByParty(ctx context.Context, in *OrdersByPartyRequest, opts ...grpc.CallOption) (*OrdersByPartyResponse, error) {
	out := new(OrdersByPartyResponse)
	err := c.cc.Invoke(ctx, "/api.trading_data/OrdersByParty", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradingDataClient) OrderByID(ctx context.Context, in *OrderByIDRequest, opts ...grpc.CallOption) (*proto.Order, error) {
	out := new(proto.Order)
	err := c.cc.Invoke(ctx, "/api.trading_data/OrderByID", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradingDataClient) OrderVersionsByID(ctx context.Context, in *OrderVersionsByIDRequest, opts ...grpc.CallOption) (*OrderVersionsResponse, error) {
	out := new(OrderVersionsResponse)
	err := c.cc.Invoke(ctx, "/api.trading_data/OrderVersionsByID", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradingDataClient) MarginLevels(ctx context.Context, in *MarginLevelsRequest, opts ...grpc.CallOption) (*MarginLevelsResponse, error) {
	out := new(MarginLevelsResponse)
	err := c.cc.Invoke(ctx, "/api.trading_data/MarginLevels", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradingDataClient) Parties(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*PartiesResponse, error) {
	out := new(PartiesResponse)
	err := c.cc.Invoke(ctx, "/api.trading_data/Parties", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradingDataClient) PartyByID(ctx context.Context, in *PartyByIDRequest, opts ...grpc.CallOption) (*PartyByIDResponse, error) {
	out := new(PartyByIDResponse)
	err := c.cc.Invoke(ctx, "/api.trading_data/PartyByID", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradingDataClient) PositionsByParty(ctx context.Context, in *PositionsByPartyRequest, opts ...grpc.CallOption) (*PositionsByPartyResponse, error) {
	out := new(PositionsByPartyResponse)
	err := c.cc.Invoke(ctx, "/api.trading_data/PositionsByParty", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradingDataClient) LastTrade(ctx context.Context, in *LastTradeRequest, opts ...grpc.CallOption) (*LastTradeResponse, error) {
	out := new(LastTradeResponse)
	err := c.cc.Invoke(ctx, "/api.trading_data/LastTrade", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradingDataClient) TradesByMarket(ctx context.Context, in *TradesByMarketRequest, opts ...grpc.CallOption) (*TradesByMarketResponse, error) {
	out := new(TradesByMarketResponse)
	err := c.cc.Invoke(ctx, "/api.trading_data/TradesByMarket", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradingDataClient) TradesByOrder(ctx context.Context, in *TradesByOrderRequest, opts ...grpc.CallOption) (*TradesByOrderResponse, error) {
	out := new(TradesByOrderResponse)
	err := c.cc.Invoke(ctx, "/api.trading_data/TradesByOrder", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradingDataClient) TradesByParty(ctx context.Context, in *TradesByPartyRequest, opts ...grpc.CallOption) (*TradesByPartyResponse, error) {
	out := new(TradesByPartyResponse)
	err := c.cc.Invoke(ctx, "/api.trading_data/TradesByParty", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradingDataClient) GetProposals(ctx context.Context, in *GetProposalsRequest, opts ...grpc.CallOption) (*GetProposalsResponse, error) {
	out := new(GetProposalsResponse)
	err := c.cc.Invoke(ctx, "/api.trading_data/GetProposals", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradingDataClient) GetProposalsByParty(ctx context.Context, in *GetProposalsByPartyRequest, opts ...grpc.CallOption) (*GetProposalsByPartyResponse, error) {
	out := new(GetProposalsByPartyResponse)
	err := c.cc.Invoke(ctx, "/api.trading_data/GetProposalsByParty", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradingDataClient) GetVotesByParty(ctx context.Context, in *GetVotesByPartyRequest, opts ...grpc.CallOption) (*GetVotesByPartyResponse, error) {
	out := new(GetVotesByPartyResponse)
	err := c.cc.Invoke(ctx, "/api.trading_data/GetVotesByParty", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradingDataClient) GetNewMarketProposals(ctx context.Context, in *GetNewMarketProposalsRequest, opts ...grpc.CallOption) (*GetNewMarketProposalsResponse, error) {
	out := new(GetNewMarketProposalsResponse)
	err := c.cc.Invoke(ctx, "/api.trading_data/GetNewMarketProposals", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradingDataClient) GetUpdateMarketProposals(ctx context.Context, in *GetUpdateMarketProposalsRequest, opts ...grpc.CallOption) (*GetUpdateMarketProposalsResponse, error) {
	out := new(GetUpdateMarketProposalsResponse)
	err := c.cc.Invoke(ctx, "/api.trading_data/GetUpdateMarketProposals", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradingDataClient) GetNetworkParametersProposals(ctx context.Context, in *GetNetworkParametersProposalsRequest, opts ...grpc.CallOption) (*GetNetworkParametersProposalsResponse, error) {
	out := new(GetNetworkParametersProposalsResponse)
	err := c.cc.Invoke(ctx, "/api.trading_data/GetNetworkParametersProposals", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradingDataClient) GetNewAssetProposals(ctx context.Context, in *GetNewAssetProposalsRequest, opts ...grpc.CallOption) (*GetNewAssetProposalsResponse, error) {
	out := new(GetNewAssetProposalsResponse)
	err := c.cc.Invoke(ctx, "/api.trading_data/GetNewAssetProposals", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradingDataClient) GetProposalByID(ctx context.Context, in *GetProposalByIDRequest, opts ...grpc.CallOption) (*GetProposalByIDResponse, error) {
	out := new(GetProposalByIDResponse)
	err := c.cc.Invoke(ctx, "/api.trading_data/GetProposalByID", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradingDataClient) GetProposalByReference(ctx context.Context, in *GetProposalByReferenceRequest, opts ...grpc.CallOption) (*GetProposalByReferenceResponse, error) {
	out := new(GetProposalByReferenceResponse)
	err := c.cc.Invoke(ctx, "/api.trading_data/GetProposalByReference", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradingDataClient) ObserveGovernance(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (TradingData_ObserveGovernanceClient, error) {
	stream, err := c.cc.NewStream(ctx, &_TradingData_serviceDesc.Streams[0], "/api.trading_data/ObserveGovernance", opts...)
	if err != nil {
		return nil, err
	}
	x := &tradingDataObserveGovernanceClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type TradingData_ObserveGovernanceClient interface {
	Recv() (*proto.GovernanceData, error)
	grpc.ClientStream
}

type tradingDataObserveGovernanceClient struct {
	grpc.ClientStream
}

func (x *tradingDataObserveGovernanceClient) Recv() (*proto.GovernanceData, error) {
	m := new(proto.GovernanceData)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *tradingDataClient) ObservePartyProposals(ctx context.Context, in *ObservePartyProposalsRequest, opts ...grpc.CallOption) (TradingData_ObservePartyProposalsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_TradingData_serviceDesc.Streams[1], "/api.trading_data/ObservePartyProposals", opts...)
	if err != nil {
		return nil, err
	}
	x := &tradingDataObservePartyProposalsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type TradingData_ObservePartyProposalsClient interface {
	Recv() (*proto.GovernanceData, error)
	grpc.ClientStream
}

type tradingDataObservePartyProposalsClient struct {
	grpc.ClientStream
}

func (x *tradingDataObservePartyProposalsClient) Recv() (*proto.GovernanceData, error) {
	m := new(proto.GovernanceData)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *tradingDataClient) ObservePartyVotes(ctx context.Context, in *ObservePartyVotesRequest, opts ...grpc.CallOption) (TradingData_ObservePartyVotesClient, error) {
	stream, err := c.cc.NewStream(ctx, &_TradingData_serviceDesc.Streams[2], "/api.trading_data/ObservePartyVotes", opts...)
	if err != nil {
		return nil, err
	}
	x := &tradingDataObservePartyVotesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type TradingData_ObservePartyVotesClient interface {
	Recv() (*proto.Vote, error)
	grpc.ClientStream
}

type tradingDataObservePartyVotesClient struct {
	grpc.ClientStream
}

func (x *tradingDataObservePartyVotesClient) Recv() (*proto.Vote, error) {
	m := new(proto.Vote)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *tradingDataClient) ObserveProposalVotes(ctx context.Context, in *ObserveProposalVotesRequest, opts ...grpc.CallOption) (TradingData_ObserveProposalVotesClient, error) {
	stream, err := c.cc.NewStream(ctx, &_TradingData_serviceDesc.Streams[3], "/api.trading_data/ObserveProposalVotes", opts...)
	if err != nil {
		return nil, err
	}
	x := &tradingDataObserveProposalVotesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type TradingData_ObserveProposalVotesClient interface {
	Recv() (*proto.Vote, error)
	grpc.ClientStream
}

type tradingDataObserveProposalVotesClient struct {
	grpc.ClientStream
}

func (x *tradingDataObserveProposalVotesClient) Recv() (*proto.Vote, error) {
	m := new(proto.Vote)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *tradingDataClient) ObserveEventBus(ctx context.Context, opts ...grpc.CallOption) (TradingData_ObserveEventBusClient, error) {
	stream, err := c.cc.NewStream(ctx, &_TradingData_serviceDesc.Streams[4], "/api.trading_data/ObserveEventBus", opts...)
	if err != nil {
		return nil, err
	}
	x := &tradingDataObserveEventBusClient{stream}
	return x, nil
}

type TradingData_ObserveEventBusClient interface {
	Send(*ObserveEventsRequest) error
	Recv() (*ObserveEventsResponse, error)
	grpc.ClientStream
}

type tradingDataObserveEventBusClient struct {
	grpc.ClientStream
}

func (x *tradingDataObserveEventBusClient) Send(m *ObserveEventsRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *tradingDataObserveEventBusClient) Recv() (*ObserveEventsResponse, error) {
	m := new(ObserveEventsResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *tradingDataClient) Statistics(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*proto.Statistics, error) {
	out := new(proto.Statistics)
	err := c.cc.Invoke(ctx, "/api.trading_data/Statistics", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradingDataClient) GetVegaTime(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*VegaTimeResponse, error) {
	out := new(VegaTimeResponse)
	err := c.cc.Invoke(ctx, "/api.trading_data/GetVegaTime", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradingDataClient) AccountsSubscribe(ctx context.Context, in *AccountsSubscribeRequest, opts ...grpc.CallOption) (TradingData_AccountsSubscribeClient, error) {
	stream, err := c.cc.NewStream(ctx, &_TradingData_serviceDesc.Streams[5], "/api.trading_data/AccountsSubscribe", opts...)
	if err != nil {
		return nil, err
	}
	x := &tradingDataAccountsSubscribeClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type TradingData_AccountsSubscribeClient interface {
	Recv() (*proto.Account, error)
	grpc.ClientStream
}

type tradingDataAccountsSubscribeClient struct {
	grpc.ClientStream
}

func (x *tradingDataAccountsSubscribeClient) Recv() (*proto.Account, error) {
	m := new(proto.Account)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *tradingDataClient) CandlesSubscribe(ctx context.Context, in *CandlesSubscribeRequest, opts ...grpc.CallOption) (TradingData_CandlesSubscribeClient, error) {
	stream, err := c.cc.NewStream(ctx, &_TradingData_serviceDesc.Streams[6], "/api.trading_data/CandlesSubscribe", opts...)
	if err != nil {
		return nil, err
	}
	x := &tradingDataCandlesSubscribeClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type TradingData_CandlesSubscribeClient interface {
	Recv() (*proto.Candle, error)
	grpc.ClientStream
}

type tradingDataCandlesSubscribeClient struct {
	grpc.ClientStream
}

func (x *tradingDataCandlesSubscribeClient) Recv() (*proto.Candle, error) {
	m := new(proto.Candle)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *tradingDataClient) MarginLevelsSubscribe(ctx context.Context, in *MarginLevelsSubscribeRequest, opts ...grpc.CallOption) (TradingData_MarginLevelsSubscribeClient, error) {
	stream, err := c.cc.NewStream(ctx, &_TradingData_serviceDesc.Streams[7], "/api.trading_data/MarginLevelsSubscribe", opts...)
	if err != nil {
		return nil, err
	}
	x := &tradingDataMarginLevelsSubscribeClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type TradingData_MarginLevelsSubscribeClient interface {
	Recv() (*proto.MarginLevels, error)
	grpc.ClientStream
}

type tradingDataMarginLevelsSubscribeClient struct {
	grpc.ClientStream
}

func (x *tradingDataMarginLevelsSubscribeClient) Recv() (*proto.MarginLevels, error) {
	m := new(proto.MarginLevels)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *tradingDataClient) MarketDepthSubscribe(ctx context.Context, in *MarketDepthSubscribeRequest, opts ...grpc.CallOption) (TradingData_MarketDepthSubscribeClient, error) {
	stream, err := c.cc.NewStream(ctx, &_TradingData_serviceDesc.Streams[8], "/api.trading_data/MarketDepthSubscribe", opts...)
	if err != nil {
		return nil, err
	}
	x := &tradingDataMarketDepthSubscribeClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type TradingData_MarketDepthSubscribeClient interface {
	Recv() (*proto.MarketDepth, error)
	grpc.ClientStream
}

type tradingDataMarketDepthSubscribeClient struct {
	grpc.ClientStream
}

func (x *tradingDataMarketDepthSubscribeClient) Recv() (*proto.MarketDepth, error) {
	m := new(proto.MarketDepth)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *tradingDataClient) MarketDepthUpdatesSubscribe(ctx context.Context, in *MarketDepthUpdatesSubscribeRequest, opts ...grpc.CallOption) (TradingData_MarketDepthUpdatesSubscribeClient, error) {
	stream, err := c.cc.NewStream(ctx, &_TradingData_serviceDesc.Streams[9], "/api.trading_data/MarketDepthUpdatesSubscribe", opts...)
	if err != nil {
		return nil, err
	}
	x := &tradingDataMarketDepthUpdatesSubscribeClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type TradingData_MarketDepthUpdatesSubscribeClient interface {
	Recv() (*proto.MarketDepthUpdate, error)
	grpc.ClientStream
}

type tradingDataMarketDepthUpdatesSubscribeClient struct {
	grpc.ClientStream
}

func (x *tradingDataMarketDepthUpdatesSubscribeClient) Recv() (*proto.MarketDepthUpdate, error) {
	m := new(proto.MarketDepthUpdate)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *tradingDataClient) MarketsDataSubscribe(ctx context.Context, in *MarketsDataSubscribeRequest, opts ...grpc.CallOption) (TradingData_MarketsDataSubscribeClient, error) {
	stream, err := c.cc.NewStream(ctx, &_TradingData_serviceDesc.Streams[10], "/api.trading_data/MarketsDataSubscribe", opts...)
	if err != nil {
		return nil, err
	}
	x := &tradingDataMarketsDataSubscribeClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type TradingData_MarketsDataSubscribeClient interface {
	Recv() (*proto.MarketData, error)
	grpc.ClientStream
}

type tradingDataMarketsDataSubscribeClient struct {
	grpc.ClientStream
}

func (x *tradingDataMarketsDataSubscribeClient) Recv() (*proto.MarketData, error) {
	m := new(proto.MarketData)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *tradingDataClient) OrdersSubscribe(ctx context.Context, in *OrdersSubscribeRequest, opts ...grpc.CallOption) (TradingData_OrdersSubscribeClient, error) {
	stream, err := c.cc.NewStream(ctx, &_TradingData_serviceDesc.Streams[11], "/api.trading_data/OrdersSubscribe", opts...)
	if err != nil {
		return nil, err
	}
	x := &tradingDataOrdersSubscribeClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type TradingData_OrdersSubscribeClient interface {
	Recv() (*OrdersStream, error)
	grpc.ClientStream
}

type tradingDataOrdersSubscribeClient struct {
	grpc.ClientStream
}

func (x *tradingDataOrdersSubscribeClient) Recv() (*OrdersStream, error) {
	m := new(OrdersStream)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *tradingDataClient) PositionsSubscribe(ctx context.Context, in *PositionsSubscribeRequest, opts ...grpc.CallOption) (TradingData_PositionsSubscribeClient, error) {
	stream, err := c.cc.NewStream(ctx, &_TradingData_serviceDesc.Streams[12], "/api.trading_data/PositionsSubscribe", opts...)
	if err != nil {
		return nil, err
	}
	x := &tradingDataPositionsSubscribeClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type TradingData_PositionsSubscribeClient interface {
	Recv() (*proto.Position, error)
	grpc.ClientStream
}

type tradingDataPositionsSubscribeClient struct {
	grpc.ClientStream
}

func (x *tradingDataPositionsSubscribeClient) Recv() (*proto.Position, error) {
	m := new(proto.Position)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *tradingDataClient) TradesSubscribe(ctx context.Context, in *TradesSubscribeRequest, opts ...grpc.CallOption) (TradingData_TradesSubscribeClient, error) {
	stream, err := c.cc.NewStream(ctx, &_TradingData_serviceDesc.Streams[13], "/api.trading_data/TradesSubscribe", opts...)
	if err != nil {
		return nil, err
	}
	x := &tradingDataTradesSubscribeClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type TradingData_TradesSubscribeClient interface {
	Recv() (*TradesStream, error)
	grpc.ClientStream
}

type tradingDataTradesSubscribeClient struct {
	grpc.ClientStream
}

func (x *tradingDataTradesSubscribeClient) Recv() (*TradesStream, error) {
	m := new(TradesStream)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *tradingDataClient) TransferResponsesSubscribe(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (TradingData_TransferResponsesSubscribeClient, error) {
	stream, err := c.cc.NewStream(ctx, &_TradingData_serviceDesc.Streams[14], "/api.trading_data/TransferResponsesSubscribe", opts...)
	if err != nil {
		return nil, err
	}
	x := &tradingDataTransferResponsesSubscribeClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type TradingData_TransferResponsesSubscribeClient interface {
	Recv() (*proto.TransferResponse, error)
	grpc.ClientStream
}

type tradingDataTransferResponsesSubscribeClient struct {
	grpc.ClientStream
}

func (x *tradingDataTransferResponsesSubscribeClient) Recv() (*proto.TransferResponse, error) {
	m := new(proto.TransferResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *tradingDataClient) GetNodeSignaturesAggregate(ctx context.Context, in *GetNodeSignaturesAggregateRequest, opts ...grpc.CallOption) (*GetNodeSignaturesAggregateResponse, error) {
	out := new(GetNodeSignaturesAggregateResponse)
	err := c.cc.Invoke(ctx, "/api.trading_data/GetNodeSignaturesAggregate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradingDataClient) AssetByID(ctx context.Context, in *AssetByIDRequest, opts ...grpc.CallOption) (*AssetByIDResponse, error) {
	out := new(AssetByIDResponse)
	err := c.cc.Invoke(ctx, "/api.trading_data/AssetByID", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradingDataClient) Assets(ctx context.Context, in *AssetsRequest, opts ...grpc.CallOption) (*AssetsResponse, error) {
	out := new(AssetsResponse)
	err := c.cc.Invoke(ctx, "/api.trading_data/Assets", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradingDataClient) EstimateFee(ctx context.Context, in *EstimateFeeRequest, opts ...grpc.CallOption) (*EstimateFeeResponse, error) {
	out := new(EstimateFeeResponse)
	err := c.cc.Invoke(ctx, "/api.trading_data/EstimateFee", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradingDataClient) EstimateMargin(ctx context.Context, in *EstimateMarginRequest, opts ...grpc.CallOption) (*EstimateMarginResponse, error) {
	out := new(EstimateMarginResponse)
	err := c.cc.Invoke(ctx, "/api.trading_data/EstimateMargin", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradingDataClient) ERC20WithdrawalApproval(ctx context.Context, in *ERC20WithdrawalApprovalRequest, opts ...grpc.CallOption) (*ERC20WithdrawalApprovalResponse, error) {
	out := new(ERC20WithdrawalApprovalResponse)
	err := c.cc.Invoke(ctx, "/api.trading_data/ERC20WithdrawalApproval", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradingDataClient) Withdrawal(ctx context.Context, in *WithdrawalRequest, opts ...grpc.CallOption) (*WithdrawalResponse, error) {
	out := new(WithdrawalResponse)
	err := c.cc.Invoke(ctx, "/api.trading_data/Withdrawal", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradingDataClient) Withdrawals(ctx context.Context, in *WithdrawalsRequest, opts ...grpc.CallOption) (*WithdrawalsResponse, error) {
	out := new(WithdrawalsResponse)
	err := c.cc.Invoke(ctx, "/api.trading_data/Withdrawals", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradingDataClient) Deposit(ctx context.Context, in *DepositRequest, opts ...grpc.CallOption) (*DepositResponse, error) {
	out := new(DepositResponse)
	err := c.cc.Invoke(ctx, "/api.trading_data/Deposit", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradingDataClient) Deposits(ctx context.Context, in *DepositsRequest, opts ...grpc.CallOption) (*DepositsResponse, error) {
	out := new(DepositsResponse)
	err := c.cc.Invoke(ctx, "/api.trading_data/Deposits", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradingDataClient) NetworkParameters(ctx context.Context, in *NetworkParametersRequest, opts ...grpc.CallOption) (*NetworkParametersResponse, error) {
	out := new(NetworkParametersResponse)
	err := c.cc.Invoke(ctx, "/api.trading_data/NetworkParameters", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradingDataClient) LiquidityProvisions(ctx context.Context, in *LiquidityProvisionsRequest, opts ...grpc.CallOption) (*LiquidityProvisionsResponse, error) {
	out := new(LiquidityProvisionsResponse)
	err := c.cc.Invoke(ctx, "/api.trading_data/LiquidityProvisions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TradingDataServer is the server API for TradingData service.
// All implementations must embed UnimplementedTradingDataServer
// for forward compatibility
type TradingDataServer interface {
	// Get a list of Accounts by Market
	MarketAccounts(context.Context, *MarketAccountsRequest) (*MarketAccountsResponse, error)
	// Get a list of Accounts by Party
	PartyAccounts(context.Context, *PartyAccountsRequest) (*PartyAccountsResponse, error)
	// Get the list of infrastructure fees accounts filter eventually by assets
	FeeInfrastructureAccounts(context.Context, *FeeInfrastructureAccountsRequest) (*FeeInfrastructureAccountsResponse, error)
	// Get a list of Candles by Market
	Candles(context.Context, *CandlesRequest) (*CandlesResponse, error)
	// Get Market Data by MarketID
	MarketDataByID(context.Context, *MarketDataByIDRequest) (*MarketDataByIDResponse, error)
	// Get a list of Market Data
	MarketsData(context.Context, *empty.Empty) (*MarketsDataResponse, error)
	// Get a Market by ID
	MarketByID(context.Context, *MarketByIDRequest) (*MarketByIDResponse, error)
	// Get Market Depth
	MarketDepth(context.Context, *MarketDepthRequest) (*MarketDepthResponse, error)
	// Get a list of Markets
	Markets(context.Context, *empty.Empty) (*MarketsResponse, error)
	// Get an Order by Market and OrderID
	OrderByMarketAndID(context.Context, *OrderByMarketAndIdRequest) (*OrderByMarketAndIdResponse, error)
	// Get an Order by Pending Order reference (UUID)
	OrderByReference(context.Context, *OrderByReferenceRequest) (*OrderByReferenceResponse, error)
	// Get a list of Orders by Market
	OrdersByMarket(context.Context, *OrdersByMarketRequest) (*OrdersByMarketResponse, error)
	// Get a list of Orders by Party
	OrdersByParty(context.Context, *OrdersByPartyRequest) (*OrdersByPartyResponse, error)
	// Get a specific order by orderID
	OrderByID(context.Context, *OrderByIDRequest) (*proto.Order, error)
	// Get all versions of the order by its orderID
	OrderVersionsByID(context.Context, *OrderVersionsByIDRequest) (*OrderVersionsResponse, error)
	// Get Margin Levels by PartyID
	MarginLevels(context.Context, *MarginLevelsRequest) (*MarginLevelsResponse, error)
	// Get a list of Parties
	Parties(context.Context, *empty.Empty) (*PartiesResponse, error)
	// Get a Party by ID
	PartyByID(context.Context, *PartyByIDRequest) (*PartyByIDResponse, error)
	// Get a list of Positions by Party
	PositionsByParty(context.Context, *PositionsByPartyRequest) (*PositionsByPartyResponse, error)
	// Get latest Trade
	LastTrade(context.Context, *LastTradeRequest) (*LastTradeResponse, error)
	// Get a list of Trades by Market
	TradesByMarket(context.Context, *TradesByMarketRequest) (*TradesByMarketResponse, error)
	// Get a list of Trades by Order
	TradesByOrder(context.Context, *TradesByOrderRequest) (*TradesByOrderResponse, error)
	// Get a list of Trades by Party
	TradesByParty(context.Context, *TradesByPartyRequest) (*TradesByPartyResponse, error)
	// Get governance data (proposals and votes) for all proposals
	GetProposals(context.Context, *GetProposalsRequest) (*GetProposalsResponse, error)
	// Get governance data (proposals and votes) for proposals by party authoring them
	GetProposalsByParty(context.Context, *GetProposalsByPartyRequest) (*GetProposalsByPartyResponse, error)
	// Get votes by party casting them
	GetVotesByParty(context.Context, *GetVotesByPartyRequest) (*GetVotesByPartyResponse, error)
	// Get governance data (proposals and votes) for proposals that aim creating new markets
	GetNewMarketProposals(context.Context, *GetNewMarketProposalsRequest) (*GetNewMarketProposalsResponse, error)
	// Get governance data (proposals and votes) for proposals that aim updating markets
	GetUpdateMarketProposals(context.Context, *GetUpdateMarketProposalsRequest) (*GetUpdateMarketProposalsResponse, error)
	// Get governance data (proposals and votes) for proposals that aim updating Vega network parameters
	GetNetworkParametersProposals(context.Context, *GetNetworkParametersProposalsRequest) (*GetNetworkParametersProposalsResponse, error)
	// Get governance data (proposals and votes) for proposals aiming to create new assets
	GetNewAssetProposals(context.Context, *GetNewAssetProposalsRequest) (*GetNewAssetProposalsResponse, error)
	// Get governance data (proposals and votes) for a proposal located by ID
	GetProposalByID(context.Context, *GetProposalByIDRequest) (*GetProposalByIDResponse, error)
	// Get governance data (proposals and votes) for a proposal located by reference
	GetProposalByReference(context.Context, *GetProposalByReferenceRequest) (*GetProposalByReferenceResponse, error)
	// Subscribe to a stream of all governance updates
	ObserveGovernance(*empty.Empty, TradingData_ObserveGovernanceServer) error
	// Subscribe to a stream of proposal updates
	ObservePartyProposals(*ObservePartyProposalsRequest, TradingData_ObservePartyProposalsServer) error
	// Subscribe to a stream of votes cast by a specific party
	ObservePartyVotes(*ObservePartyVotesRequest, TradingData_ObservePartyVotesServer) error
	// Subscribe to a stream of proposal votes
	ObserveProposalVotes(*ObserveProposalVotesRequest, TradingData_ObserveProposalVotesServer) error
	// Subscribe to a stream of events from the core
	ObserveEventBus(TradingData_ObserveEventBusServer) error
	// Get Statistics
	Statistics(context.Context, *empty.Empty) (*proto.Statistics, error)
	// Get Time
	GetVegaTime(context.Context, *empty.Empty) (*VegaTimeResponse, error)
	// Subscribe to a stream of Accounts
	AccountsSubscribe(*AccountsSubscribeRequest, TradingData_AccountsSubscribeServer) error
	// Subscribe to a stream of Candles
	CandlesSubscribe(*CandlesSubscribeRequest, TradingData_CandlesSubscribeServer) error
	// Subscribe to a stream of Margin Levels
	MarginLevelsSubscribe(*MarginLevelsSubscribeRequest, TradingData_MarginLevelsSubscribeServer) error
	// Subscribe to a stream of Market Depth
	MarketDepthSubscribe(*MarketDepthSubscribeRequest, TradingData_MarketDepthSubscribeServer) error
	// Subscribe to a stream of Market Depth PriceLevel Updates
	MarketDepthUpdatesSubscribe(*MarketDepthUpdatesSubscribeRequest, TradingData_MarketDepthUpdatesSubscribeServer) error
	// Subscribe to a stream of Markets Data
	MarketsDataSubscribe(*MarketsDataSubscribeRequest, TradingData_MarketsDataSubscribeServer) error
	// Subscribe to a stream of Orders
	OrdersSubscribe(*OrdersSubscribeRequest, TradingData_OrdersSubscribeServer) error
	// Subscribe to a stream of Positions
	PositionsSubscribe(*PositionsSubscribeRequest, TradingData_PositionsSubscribeServer) error
	// Subscribe to a stream of Trades
	TradesSubscribe(*TradesSubscribeRequest, TradingData_TradesSubscribeServer) error
	// Subscribe to a stream of Transfer Responses
	TransferResponsesSubscribe(*empty.Empty, TradingData_TransferResponsesSubscribeServer) error
	// Get an aggregate of signatures from all the nodes of the network.
	GetNodeSignaturesAggregate(context.Context, *GetNodeSignaturesAggregateRequest) (*GetNodeSignaturesAggregateResponse, error)
	// Get an asset by its identifier.
	AssetByID(context.Context, *AssetByIDRequest) (*AssetByIDResponse, error)
	// Get a list of all assets on Vega.
	Assets(context.Context, *AssetsRequest) (*AssetsResponse, error)
	// Get an estimate for the fee to be paid for a given order
	EstimateFee(context.Context, *EstimateFeeRequest) (*EstimateFeeResponse, error)
	// Get an estimate for the margin required for a new order
	EstimateMargin(context.Context, *EstimateMarginRequest) (*EstimateMarginResponse, error)
	// Get the bundle approval for an ERC20 withdrawal
	// these data are being used to bundle the call to the smart contract on the ethereum bridge
	ERC20WithdrawalApproval(context.Context, *ERC20WithdrawalApprovalRequest) (*ERC20WithdrawalApprovalResponse, error)
	// Get a withdrawal by its ID
	Withdrawal(context.Context, *WithdrawalRequest) (*WithdrawalResponse, error)
	// Get withdrawals for a party
	Withdrawals(context.Context, *WithdrawalsRequest) (*WithdrawalsResponse, error)
	// Get a deposit by its ID
	Deposit(context.Context, *DepositRequest) (*DepositResponse, error)
	// Get withdrawals for a party
	Deposits(context.Context, *DepositsRequest) (*DepositsResponse, error)
	// Get the network parameters
	NetworkParameters(context.Context, *NetworkParametersRequest) (*NetworkParametersResponse, error)
	// Get the liquidity provision orders
	LiquidityProvisions(context.Context, *LiquidityProvisionsRequest) (*LiquidityProvisionsResponse, error)
	mustEmbedUnimplementedTradingDataServer()
}

// UnimplementedTradingDataServer must be embedded to have forward compatible implementations.
type UnimplementedTradingDataServer struct {
}

func (UnimplementedTradingDataServer) MarketAccounts(context.Context, *MarketAccountsRequest) (*MarketAccountsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MarketAccounts not implemented")
}
func (UnimplementedTradingDataServer) PartyAccounts(context.Context, *PartyAccountsRequest) (*PartyAccountsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PartyAccounts not implemented")
}
func (UnimplementedTradingDataServer) FeeInfrastructureAccounts(context.Context, *FeeInfrastructureAccountsRequest) (*FeeInfrastructureAccountsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FeeInfrastructureAccounts not implemented")
}
func (UnimplementedTradingDataServer) Candles(context.Context, *CandlesRequest) (*CandlesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Candles not implemented")
}
func (UnimplementedTradingDataServer) MarketDataByID(context.Context, *MarketDataByIDRequest) (*MarketDataByIDResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MarketDataByID not implemented")
}
func (UnimplementedTradingDataServer) MarketsData(context.Context, *empty.Empty) (*MarketsDataResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MarketsData not implemented")
}
func (UnimplementedTradingDataServer) MarketByID(context.Context, *MarketByIDRequest) (*MarketByIDResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MarketByID not implemented")
}
func (UnimplementedTradingDataServer) MarketDepth(context.Context, *MarketDepthRequest) (*MarketDepthResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MarketDepth not implemented")
}
func (UnimplementedTradingDataServer) Markets(context.Context, *empty.Empty) (*MarketsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Markets not implemented")
}
func (UnimplementedTradingDataServer) OrderByMarketAndID(context.Context, *OrderByMarketAndIdRequest) (*OrderByMarketAndIdResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OrderByMarketAndID not implemented")
}
func (UnimplementedTradingDataServer) OrderByReference(context.Context, *OrderByReferenceRequest) (*OrderByReferenceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OrderByReference not implemented")
}
func (UnimplementedTradingDataServer) OrdersByMarket(context.Context, *OrdersByMarketRequest) (*OrdersByMarketResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OrdersByMarket not implemented")
}
func (UnimplementedTradingDataServer) OrdersByParty(context.Context, *OrdersByPartyRequest) (*OrdersByPartyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OrdersByParty not implemented")
}
func (UnimplementedTradingDataServer) OrderByID(context.Context, *OrderByIDRequest) (*proto.Order, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OrderByID not implemented")
}
func (UnimplementedTradingDataServer) OrderVersionsByID(context.Context, *OrderVersionsByIDRequest) (*OrderVersionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OrderVersionsByID not implemented")
}
func (UnimplementedTradingDataServer) MarginLevels(context.Context, *MarginLevelsRequest) (*MarginLevelsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MarginLevels not implemented")
}
func (UnimplementedTradingDataServer) Parties(context.Context, *empty.Empty) (*PartiesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Parties not implemented")
}
func (UnimplementedTradingDataServer) PartyByID(context.Context, *PartyByIDRequest) (*PartyByIDResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PartyByID not implemented")
}
func (UnimplementedTradingDataServer) PositionsByParty(context.Context, *PositionsByPartyRequest) (*PositionsByPartyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PositionsByParty not implemented")
}
func (UnimplementedTradingDataServer) LastTrade(context.Context, *LastTradeRequest) (*LastTradeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LastTrade not implemented")
}
func (UnimplementedTradingDataServer) TradesByMarket(context.Context, *TradesByMarketRequest) (*TradesByMarketResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TradesByMarket not implemented")
}
func (UnimplementedTradingDataServer) TradesByOrder(context.Context, *TradesByOrderRequest) (*TradesByOrderResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TradesByOrder not implemented")
}
func (UnimplementedTradingDataServer) TradesByParty(context.Context, *TradesByPartyRequest) (*TradesByPartyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TradesByParty not implemented")
}
func (UnimplementedTradingDataServer) GetProposals(context.Context, *GetProposalsRequest) (*GetProposalsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetProposals not implemented")
}
func (UnimplementedTradingDataServer) GetProposalsByParty(context.Context, *GetProposalsByPartyRequest) (*GetProposalsByPartyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetProposalsByParty not implemented")
}
func (UnimplementedTradingDataServer) GetVotesByParty(context.Context, *GetVotesByPartyRequest) (*GetVotesByPartyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetVotesByParty not implemented")
}
func (UnimplementedTradingDataServer) GetNewMarketProposals(context.Context, *GetNewMarketProposalsRequest) (*GetNewMarketProposalsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetNewMarketProposals not implemented")
}
func (UnimplementedTradingDataServer) GetUpdateMarketProposals(context.Context, *GetUpdateMarketProposalsRequest) (*GetUpdateMarketProposalsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUpdateMarketProposals not implemented")
}
func (UnimplementedTradingDataServer) GetNetworkParametersProposals(context.Context, *GetNetworkParametersProposalsRequest) (*GetNetworkParametersProposalsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetNetworkParametersProposals not implemented")
}
func (UnimplementedTradingDataServer) GetNewAssetProposals(context.Context, *GetNewAssetProposalsRequest) (*GetNewAssetProposalsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetNewAssetProposals not implemented")
}
func (UnimplementedTradingDataServer) GetProposalByID(context.Context, *GetProposalByIDRequest) (*GetProposalByIDResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetProposalByID not implemented")
}
func (UnimplementedTradingDataServer) GetProposalByReference(context.Context, *GetProposalByReferenceRequest) (*GetProposalByReferenceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetProposalByReference not implemented")
}
func (UnimplementedTradingDataServer) ObserveGovernance(*empty.Empty, TradingData_ObserveGovernanceServer) error {
	return status.Errorf(codes.Unimplemented, "method ObserveGovernance not implemented")
}
func (UnimplementedTradingDataServer) ObservePartyProposals(*ObservePartyProposalsRequest, TradingData_ObservePartyProposalsServer) error {
	return status.Errorf(codes.Unimplemented, "method ObservePartyProposals not implemented")
}
func (UnimplementedTradingDataServer) ObservePartyVotes(*ObservePartyVotesRequest, TradingData_ObservePartyVotesServer) error {
	return status.Errorf(codes.Unimplemented, "method ObservePartyVotes not implemented")
}
func (UnimplementedTradingDataServer) ObserveProposalVotes(*ObserveProposalVotesRequest, TradingData_ObserveProposalVotesServer) error {
	return status.Errorf(codes.Unimplemented, "method ObserveProposalVotes not implemented")
}
func (UnimplementedTradingDataServer) ObserveEventBus(TradingData_ObserveEventBusServer) error {
	return status.Errorf(codes.Unimplemented, "method ObserveEventBus not implemented")
}
func (UnimplementedTradingDataServer) Statistics(context.Context, *empty.Empty) (*proto.Statistics, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Statistics not implemented")
}
func (UnimplementedTradingDataServer) GetVegaTime(context.Context, *empty.Empty) (*VegaTimeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetVegaTime not implemented")
}
func (UnimplementedTradingDataServer) AccountsSubscribe(*AccountsSubscribeRequest, TradingData_AccountsSubscribeServer) error {
	return status.Errorf(codes.Unimplemented, "method AccountsSubscribe not implemented")
}
func (UnimplementedTradingDataServer) CandlesSubscribe(*CandlesSubscribeRequest, TradingData_CandlesSubscribeServer) error {
	return status.Errorf(codes.Unimplemented, "method CandlesSubscribe not implemented")
}
func (UnimplementedTradingDataServer) MarginLevelsSubscribe(*MarginLevelsSubscribeRequest, TradingData_MarginLevelsSubscribeServer) error {
	return status.Errorf(codes.Unimplemented, "method MarginLevelsSubscribe not implemented")
}
func (UnimplementedTradingDataServer) MarketDepthSubscribe(*MarketDepthSubscribeRequest, TradingData_MarketDepthSubscribeServer) error {
	return status.Errorf(codes.Unimplemented, "method MarketDepthSubscribe not implemented")
}
func (UnimplementedTradingDataServer) MarketDepthUpdatesSubscribe(*MarketDepthUpdatesSubscribeRequest, TradingData_MarketDepthUpdatesSubscribeServer) error {
	return status.Errorf(codes.Unimplemented, "method MarketDepthUpdatesSubscribe not implemented")
}
func (UnimplementedTradingDataServer) MarketsDataSubscribe(*MarketsDataSubscribeRequest, TradingData_MarketsDataSubscribeServer) error {
	return status.Errorf(codes.Unimplemented, "method MarketsDataSubscribe not implemented")
}
func (UnimplementedTradingDataServer) OrdersSubscribe(*OrdersSubscribeRequest, TradingData_OrdersSubscribeServer) error {
	return status.Errorf(codes.Unimplemented, "method OrdersSubscribe not implemented")
}
func (UnimplementedTradingDataServer) PositionsSubscribe(*PositionsSubscribeRequest, TradingData_PositionsSubscribeServer) error {
	return status.Errorf(codes.Unimplemented, "method PositionsSubscribe not implemented")
}
func (UnimplementedTradingDataServer) TradesSubscribe(*TradesSubscribeRequest, TradingData_TradesSubscribeServer) error {
	return status.Errorf(codes.Unimplemented, "method TradesSubscribe not implemented")
}
func (UnimplementedTradingDataServer) TransferResponsesSubscribe(*empty.Empty, TradingData_TransferResponsesSubscribeServer) error {
	return status.Errorf(codes.Unimplemented, "method TransferResponsesSubscribe not implemented")
}
func (UnimplementedTradingDataServer) GetNodeSignaturesAggregate(context.Context, *GetNodeSignaturesAggregateRequest) (*GetNodeSignaturesAggregateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetNodeSignaturesAggregate not implemented")
}
func (UnimplementedTradingDataServer) AssetByID(context.Context, *AssetByIDRequest) (*AssetByIDResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AssetByID not implemented")
}
func (UnimplementedTradingDataServer) Assets(context.Context, *AssetsRequest) (*AssetsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Assets not implemented")
}
func (UnimplementedTradingDataServer) EstimateFee(context.Context, *EstimateFeeRequest) (*EstimateFeeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EstimateFee not implemented")
}
func (UnimplementedTradingDataServer) EstimateMargin(context.Context, *EstimateMarginRequest) (*EstimateMarginResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EstimateMargin not implemented")
}
func (UnimplementedTradingDataServer) ERC20WithdrawalApproval(context.Context, *ERC20WithdrawalApprovalRequest) (*ERC20WithdrawalApprovalResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ERC20WithdrawalApproval not implemented")
}
func (UnimplementedTradingDataServer) Withdrawal(context.Context, *WithdrawalRequest) (*WithdrawalResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Withdrawal not implemented")
}
func (UnimplementedTradingDataServer) Withdrawals(context.Context, *WithdrawalsRequest) (*WithdrawalsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Withdrawals not implemented")
}
func (UnimplementedTradingDataServer) Deposit(context.Context, *DepositRequest) (*DepositResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Deposit not implemented")
}
func (UnimplementedTradingDataServer) Deposits(context.Context, *DepositsRequest) (*DepositsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Deposits not implemented")
}
func (UnimplementedTradingDataServer) NetworkParameters(context.Context, *NetworkParametersRequest) (*NetworkParametersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NetworkParameters not implemented")
}
func (UnimplementedTradingDataServer) LiquidityProvisions(context.Context, *LiquidityProvisionsRequest) (*LiquidityProvisionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LiquidityProvisions not implemented")
}
func (UnimplementedTradingDataServer) mustEmbedUnimplementedTradingDataServer() {}

// UnsafeTradingDataServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TradingDataServer will
// result in compilation errors.
type UnsafeTradingDataServer interface {
	mustEmbedUnimplementedTradingDataServer()
}

func RegisterTradingDataServer(s grpc.ServiceRegistrar, srv TradingDataServer) {
	s.RegisterService(&_TradingData_serviceDesc, srv)
}

func _TradingData_MarketAccounts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MarketAccountsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradingDataServer).MarketAccounts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.trading_data/MarketAccounts",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradingDataServer).MarketAccounts(ctx, req.(*MarketAccountsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TradingData_PartyAccounts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PartyAccountsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradingDataServer).PartyAccounts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.trading_data/PartyAccounts",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradingDataServer).PartyAccounts(ctx, req.(*PartyAccountsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TradingData_FeeInfrastructureAccounts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FeeInfrastructureAccountsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradingDataServer).FeeInfrastructureAccounts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.trading_data/FeeInfrastructureAccounts",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradingDataServer).FeeInfrastructureAccounts(ctx, req.(*FeeInfrastructureAccountsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TradingData_Candles_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CandlesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradingDataServer).Candles(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.trading_data/Candles",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradingDataServer).Candles(ctx, req.(*CandlesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TradingData_MarketDataByID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MarketDataByIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradingDataServer).MarketDataByID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.trading_data/MarketDataByID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradingDataServer).MarketDataByID(ctx, req.(*MarketDataByIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TradingData_MarketsData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradingDataServer).MarketsData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.trading_data/MarketsData",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradingDataServer).MarketsData(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _TradingData_MarketByID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MarketByIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradingDataServer).MarketByID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.trading_data/MarketByID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradingDataServer).MarketByID(ctx, req.(*MarketByIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TradingData_MarketDepth_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MarketDepthRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradingDataServer).MarketDepth(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.trading_data/MarketDepth",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradingDataServer).MarketDepth(ctx, req.(*MarketDepthRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TradingData_Markets_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradingDataServer).Markets(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.trading_data/Markets",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradingDataServer).Markets(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _TradingData_OrderByMarketAndID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OrderByMarketAndIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradingDataServer).OrderByMarketAndID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.trading_data/OrderByMarketAndID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradingDataServer).OrderByMarketAndID(ctx, req.(*OrderByMarketAndIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TradingData_OrderByReference_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OrderByReferenceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradingDataServer).OrderByReference(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.trading_data/OrderByReference",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradingDataServer).OrderByReference(ctx, req.(*OrderByReferenceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TradingData_OrdersByMarket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OrdersByMarketRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradingDataServer).OrdersByMarket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.trading_data/OrdersByMarket",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradingDataServer).OrdersByMarket(ctx, req.(*OrdersByMarketRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TradingData_OrdersByParty_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OrdersByPartyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradingDataServer).OrdersByParty(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.trading_data/OrdersByParty",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradingDataServer).OrdersByParty(ctx, req.(*OrdersByPartyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TradingData_OrderByID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OrderByIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradingDataServer).OrderByID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.trading_data/OrderByID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradingDataServer).OrderByID(ctx, req.(*OrderByIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TradingData_OrderVersionsByID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OrderVersionsByIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradingDataServer).OrderVersionsByID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.trading_data/OrderVersionsByID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradingDataServer).OrderVersionsByID(ctx, req.(*OrderVersionsByIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TradingData_MarginLevels_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MarginLevelsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradingDataServer).MarginLevels(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.trading_data/MarginLevels",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradingDataServer).MarginLevels(ctx, req.(*MarginLevelsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TradingData_Parties_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradingDataServer).Parties(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.trading_data/Parties",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradingDataServer).Parties(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _TradingData_PartyByID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PartyByIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradingDataServer).PartyByID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.trading_data/PartyByID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradingDataServer).PartyByID(ctx, req.(*PartyByIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TradingData_PositionsByParty_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PositionsByPartyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradingDataServer).PositionsByParty(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.trading_data/PositionsByParty",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradingDataServer).PositionsByParty(ctx, req.(*PositionsByPartyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TradingData_LastTrade_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LastTradeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradingDataServer).LastTrade(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.trading_data/LastTrade",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradingDataServer).LastTrade(ctx, req.(*LastTradeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TradingData_TradesByMarket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TradesByMarketRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradingDataServer).TradesByMarket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.trading_data/TradesByMarket",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradingDataServer).TradesByMarket(ctx, req.(*TradesByMarketRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TradingData_TradesByOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TradesByOrderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradingDataServer).TradesByOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.trading_data/TradesByOrder",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradingDataServer).TradesByOrder(ctx, req.(*TradesByOrderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TradingData_TradesByParty_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TradesByPartyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradingDataServer).TradesByParty(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.trading_data/TradesByParty",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradingDataServer).TradesByParty(ctx, req.(*TradesByPartyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TradingData_GetProposals_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetProposalsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradingDataServer).GetProposals(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.trading_data/GetProposals",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradingDataServer).GetProposals(ctx, req.(*GetProposalsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TradingData_GetProposalsByParty_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetProposalsByPartyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradingDataServer).GetProposalsByParty(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.trading_data/GetProposalsByParty",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradingDataServer).GetProposalsByParty(ctx, req.(*GetProposalsByPartyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TradingData_GetVotesByParty_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetVotesByPartyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradingDataServer).GetVotesByParty(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.trading_data/GetVotesByParty",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradingDataServer).GetVotesByParty(ctx, req.(*GetVotesByPartyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TradingData_GetNewMarketProposals_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetNewMarketProposalsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradingDataServer).GetNewMarketProposals(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.trading_data/GetNewMarketProposals",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradingDataServer).GetNewMarketProposals(ctx, req.(*GetNewMarketProposalsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TradingData_GetUpdateMarketProposals_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUpdateMarketProposalsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradingDataServer).GetUpdateMarketProposals(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.trading_data/GetUpdateMarketProposals",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradingDataServer).GetUpdateMarketProposals(ctx, req.(*GetUpdateMarketProposalsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TradingData_GetNetworkParametersProposals_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetNetworkParametersProposalsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradingDataServer).GetNetworkParametersProposals(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.trading_data/GetNetworkParametersProposals",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradingDataServer).GetNetworkParametersProposals(ctx, req.(*GetNetworkParametersProposalsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TradingData_GetNewAssetProposals_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetNewAssetProposalsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradingDataServer).GetNewAssetProposals(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.trading_data/GetNewAssetProposals",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradingDataServer).GetNewAssetProposals(ctx, req.(*GetNewAssetProposalsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TradingData_GetProposalByID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetProposalByIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradingDataServer).GetProposalByID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.trading_data/GetProposalByID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradingDataServer).GetProposalByID(ctx, req.(*GetProposalByIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TradingData_GetProposalByReference_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetProposalByReferenceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradingDataServer).GetProposalByReference(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.trading_data/GetProposalByReference",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradingDataServer).GetProposalByReference(ctx, req.(*GetProposalByReferenceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TradingData_ObserveGovernance_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(empty.Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(TradingDataServer).ObserveGovernance(m, &tradingDataObserveGovernanceServer{stream})
}

type TradingData_ObserveGovernanceServer interface {
	Send(*proto.GovernanceData) error
	grpc.ServerStream
}

type tradingDataObserveGovernanceServer struct {
	grpc.ServerStream
}

func (x *tradingDataObserveGovernanceServer) Send(m *proto.GovernanceData) error {
	return x.ServerStream.SendMsg(m)
}

func _TradingData_ObservePartyProposals_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ObservePartyProposalsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(TradingDataServer).ObservePartyProposals(m, &tradingDataObservePartyProposalsServer{stream})
}

type TradingData_ObservePartyProposalsServer interface {
	Send(*proto.GovernanceData) error
	grpc.ServerStream
}

type tradingDataObservePartyProposalsServer struct {
	grpc.ServerStream
}

func (x *tradingDataObservePartyProposalsServer) Send(m *proto.GovernanceData) error {
	return x.ServerStream.SendMsg(m)
}

func _TradingData_ObservePartyVotes_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ObservePartyVotesRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(TradingDataServer).ObservePartyVotes(m, &tradingDataObservePartyVotesServer{stream})
}

type TradingData_ObservePartyVotesServer interface {
	Send(*proto.Vote) error
	grpc.ServerStream
}

type tradingDataObservePartyVotesServer struct {
	grpc.ServerStream
}

func (x *tradingDataObservePartyVotesServer) Send(m *proto.Vote) error {
	return x.ServerStream.SendMsg(m)
}

func _TradingData_ObserveProposalVotes_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ObserveProposalVotesRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(TradingDataServer).ObserveProposalVotes(m, &tradingDataObserveProposalVotesServer{stream})
}

type TradingData_ObserveProposalVotesServer interface {
	Send(*proto.Vote) error
	grpc.ServerStream
}

type tradingDataObserveProposalVotesServer struct {
	grpc.ServerStream
}

func (x *tradingDataObserveProposalVotesServer) Send(m *proto.Vote) error {
	return x.ServerStream.SendMsg(m)
}

func _TradingData_ObserveEventBus_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(TradingDataServer).ObserveEventBus(&tradingDataObserveEventBusServer{stream})
}

type TradingData_ObserveEventBusServer interface {
	Send(*ObserveEventsResponse) error
	Recv() (*ObserveEventsRequest, error)
	grpc.ServerStream
}

type tradingDataObserveEventBusServer struct {
	grpc.ServerStream
}

func (x *tradingDataObserveEventBusServer) Send(m *ObserveEventsResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *tradingDataObserveEventBusServer) Recv() (*ObserveEventsRequest, error) {
	m := new(ObserveEventsRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _TradingData_Statistics_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradingDataServer).Statistics(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.trading_data/Statistics",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradingDataServer).Statistics(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _TradingData_GetVegaTime_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradingDataServer).GetVegaTime(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.trading_data/GetVegaTime",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradingDataServer).GetVegaTime(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _TradingData_AccountsSubscribe_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(AccountsSubscribeRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(TradingDataServer).AccountsSubscribe(m, &tradingDataAccountsSubscribeServer{stream})
}

type TradingData_AccountsSubscribeServer interface {
	Send(*proto.Account) error
	grpc.ServerStream
}

type tradingDataAccountsSubscribeServer struct {
	grpc.ServerStream
}

func (x *tradingDataAccountsSubscribeServer) Send(m *proto.Account) error {
	return x.ServerStream.SendMsg(m)
}

func _TradingData_CandlesSubscribe_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(CandlesSubscribeRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(TradingDataServer).CandlesSubscribe(m, &tradingDataCandlesSubscribeServer{stream})
}

type TradingData_CandlesSubscribeServer interface {
	Send(*proto.Candle) error
	grpc.ServerStream
}

type tradingDataCandlesSubscribeServer struct {
	grpc.ServerStream
}

func (x *tradingDataCandlesSubscribeServer) Send(m *proto.Candle) error {
	return x.ServerStream.SendMsg(m)
}

func _TradingData_MarginLevelsSubscribe_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(MarginLevelsSubscribeRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(TradingDataServer).MarginLevelsSubscribe(m, &tradingDataMarginLevelsSubscribeServer{stream})
}

type TradingData_MarginLevelsSubscribeServer interface {
	Send(*proto.MarginLevels) error
	grpc.ServerStream
}

type tradingDataMarginLevelsSubscribeServer struct {
	grpc.ServerStream
}

func (x *tradingDataMarginLevelsSubscribeServer) Send(m *proto.MarginLevels) error {
	return x.ServerStream.SendMsg(m)
}

func _TradingData_MarketDepthSubscribe_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(MarketDepthSubscribeRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(TradingDataServer).MarketDepthSubscribe(m, &tradingDataMarketDepthSubscribeServer{stream})
}

type TradingData_MarketDepthSubscribeServer interface {
	Send(*proto.MarketDepth) error
	grpc.ServerStream
}

type tradingDataMarketDepthSubscribeServer struct {
	grpc.ServerStream
}

func (x *tradingDataMarketDepthSubscribeServer) Send(m *proto.MarketDepth) error {
	return x.ServerStream.SendMsg(m)
}

func _TradingData_MarketDepthUpdatesSubscribe_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(MarketDepthUpdatesSubscribeRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(TradingDataServer).MarketDepthUpdatesSubscribe(m, &tradingDataMarketDepthUpdatesSubscribeServer{stream})
}

type TradingData_MarketDepthUpdatesSubscribeServer interface {
	Send(*proto.MarketDepthUpdate) error
	grpc.ServerStream
}

type tradingDataMarketDepthUpdatesSubscribeServer struct {
	grpc.ServerStream
}

func (x *tradingDataMarketDepthUpdatesSubscribeServer) Send(m *proto.MarketDepthUpdate) error {
	return x.ServerStream.SendMsg(m)
}

func _TradingData_MarketsDataSubscribe_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(MarketsDataSubscribeRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(TradingDataServer).MarketsDataSubscribe(m, &tradingDataMarketsDataSubscribeServer{stream})
}

type TradingData_MarketsDataSubscribeServer interface {
	Send(*proto.MarketData) error
	grpc.ServerStream
}

type tradingDataMarketsDataSubscribeServer struct {
	grpc.ServerStream
}

func (x *tradingDataMarketsDataSubscribeServer) Send(m *proto.MarketData) error {
	return x.ServerStream.SendMsg(m)
}

func _TradingData_OrdersSubscribe_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(OrdersSubscribeRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(TradingDataServer).OrdersSubscribe(m, &tradingDataOrdersSubscribeServer{stream})
}

type TradingData_OrdersSubscribeServer interface {
	Send(*OrdersStream) error
	grpc.ServerStream
}

type tradingDataOrdersSubscribeServer struct {
	grpc.ServerStream
}

func (x *tradingDataOrdersSubscribeServer) Send(m *OrdersStream) error {
	return x.ServerStream.SendMsg(m)
}

func _TradingData_PositionsSubscribe_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(PositionsSubscribeRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(TradingDataServer).PositionsSubscribe(m, &tradingDataPositionsSubscribeServer{stream})
}

type TradingData_PositionsSubscribeServer interface {
	Send(*proto.Position) error
	grpc.ServerStream
}

type tradingDataPositionsSubscribeServer struct {
	grpc.ServerStream
}

func (x *tradingDataPositionsSubscribeServer) Send(m *proto.Position) error {
	return x.ServerStream.SendMsg(m)
}

func _TradingData_TradesSubscribe_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(TradesSubscribeRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(TradingDataServer).TradesSubscribe(m, &tradingDataTradesSubscribeServer{stream})
}

type TradingData_TradesSubscribeServer interface {
	Send(*TradesStream) error
	grpc.ServerStream
}

type tradingDataTradesSubscribeServer struct {
	grpc.ServerStream
}

func (x *tradingDataTradesSubscribeServer) Send(m *TradesStream) error {
	return x.ServerStream.SendMsg(m)
}

func _TradingData_TransferResponsesSubscribe_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(empty.Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(TradingDataServer).TransferResponsesSubscribe(m, &tradingDataTransferResponsesSubscribeServer{stream})
}

type TradingData_TransferResponsesSubscribeServer interface {
	Send(*proto.TransferResponse) error
	grpc.ServerStream
}

type tradingDataTransferResponsesSubscribeServer struct {
	grpc.ServerStream
}

func (x *tradingDataTransferResponsesSubscribeServer) Send(m *proto.TransferResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _TradingData_GetNodeSignaturesAggregate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetNodeSignaturesAggregateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradingDataServer).GetNodeSignaturesAggregate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.trading_data/GetNodeSignaturesAggregate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradingDataServer).GetNodeSignaturesAggregate(ctx, req.(*GetNodeSignaturesAggregateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TradingData_AssetByID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AssetByIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradingDataServer).AssetByID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.trading_data/AssetByID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradingDataServer).AssetByID(ctx, req.(*AssetByIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TradingData_Assets_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AssetsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradingDataServer).Assets(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.trading_data/Assets",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradingDataServer).Assets(ctx, req.(*AssetsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TradingData_EstimateFee_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EstimateFeeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradingDataServer).EstimateFee(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.trading_data/EstimateFee",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradingDataServer).EstimateFee(ctx, req.(*EstimateFeeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TradingData_EstimateMargin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EstimateMarginRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradingDataServer).EstimateMargin(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.trading_data/EstimateMargin",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradingDataServer).EstimateMargin(ctx, req.(*EstimateMarginRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TradingData_ERC20WithdrawalApproval_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ERC20WithdrawalApprovalRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradingDataServer).ERC20WithdrawalApproval(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.trading_data/ERC20WithdrawalApproval",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradingDataServer).ERC20WithdrawalApproval(ctx, req.(*ERC20WithdrawalApprovalRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TradingData_Withdrawal_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WithdrawalRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradingDataServer).Withdrawal(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.trading_data/Withdrawal",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradingDataServer).Withdrawal(ctx, req.(*WithdrawalRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TradingData_Withdrawals_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WithdrawalsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradingDataServer).Withdrawals(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.trading_data/Withdrawals",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradingDataServer).Withdrawals(ctx, req.(*WithdrawalsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TradingData_Deposit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DepositRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradingDataServer).Deposit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.trading_data/Deposit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradingDataServer).Deposit(ctx, req.(*DepositRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TradingData_Deposits_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DepositsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradingDataServer).Deposits(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.trading_data/Deposits",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradingDataServer).Deposits(ctx, req.(*DepositsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TradingData_NetworkParameters_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NetworkParametersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradingDataServer).NetworkParameters(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.trading_data/NetworkParameters",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradingDataServer).NetworkParameters(ctx, req.(*NetworkParametersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TradingData_LiquidityProvisions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LiquidityProvisionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradingDataServer).LiquidityProvisions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.trading_data/LiquidityProvisions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradingDataServer).LiquidityProvisions(ctx, req.(*LiquidityProvisionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _TradingData_serviceDesc = grpc.ServiceDesc{
	ServiceName: "api.trading_data",
	HandlerType: (*TradingDataServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "MarketAccounts",
			Handler:    _TradingData_MarketAccounts_Handler,
		},
		{
			MethodName: "PartyAccounts",
			Handler:    _TradingData_PartyAccounts_Handler,
		},
		{
			MethodName: "FeeInfrastructureAccounts",
			Handler:    _TradingData_FeeInfrastructureAccounts_Handler,
		},
		{
			MethodName: "Candles",
			Handler:    _TradingData_Candles_Handler,
		},
		{
			MethodName: "MarketDataByID",
			Handler:    _TradingData_MarketDataByID_Handler,
		},
		{
			MethodName: "MarketsData",
			Handler:    _TradingData_MarketsData_Handler,
		},
		{
			MethodName: "MarketByID",
			Handler:    _TradingData_MarketByID_Handler,
		},
		{
			MethodName: "MarketDepth",
			Handler:    _TradingData_MarketDepth_Handler,
		},
		{
			MethodName: "Markets",
			Handler:    _TradingData_Markets_Handler,
		},
		{
			MethodName: "OrderByMarketAndID",
			Handler:    _TradingData_OrderByMarketAndID_Handler,
		},
		{
			MethodName: "OrderByReference",
			Handler:    _TradingData_OrderByReference_Handler,
		},
		{
			MethodName: "OrdersByMarket",
			Handler:    _TradingData_OrdersByMarket_Handler,
		},
		{
			MethodName: "OrdersByParty",
			Handler:    _TradingData_OrdersByParty_Handler,
		},
		{
			MethodName: "OrderByID",
			Handler:    _TradingData_OrderByID_Handler,
		},
		{
			MethodName: "OrderVersionsByID",
			Handler:    _TradingData_OrderVersionsByID_Handler,
		},
		{
			MethodName: "MarginLevels",
			Handler:    _TradingData_MarginLevels_Handler,
		},
		{
			MethodName: "Parties",
			Handler:    _TradingData_Parties_Handler,
		},
		{
			MethodName: "PartyByID",
			Handler:    _TradingData_PartyByID_Handler,
		},
		{
			MethodName: "PositionsByParty",
			Handler:    _TradingData_PositionsByParty_Handler,
		},
		{
			MethodName: "LastTrade",
			Handler:    _TradingData_LastTrade_Handler,
		},
		{
			MethodName: "TradesByMarket",
			Handler:    _TradingData_TradesByMarket_Handler,
		},
		{
			MethodName: "TradesByOrder",
			Handler:    _TradingData_TradesByOrder_Handler,
		},
		{
			MethodName: "TradesByParty",
			Handler:    _TradingData_TradesByParty_Handler,
		},
		{
			MethodName: "GetProposals",
			Handler:    _TradingData_GetProposals_Handler,
		},
		{
			MethodName: "GetProposalsByParty",
			Handler:    _TradingData_GetProposalsByParty_Handler,
		},
		{
			MethodName: "GetVotesByParty",
			Handler:    _TradingData_GetVotesByParty_Handler,
		},
		{
			MethodName: "GetNewMarketProposals",
			Handler:    _TradingData_GetNewMarketProposals_Handler,
		},
		{
			MethodName: "GetUpdateMarketProposals",
			Handler:    _TradingData_GetUpdateMarketProposals_Handler,
		},
		{
			MethodName: "GetNetworkParametersProposals",
			Handler:    _TradingData_GetNetworkParametersProposals_Handler,
		},
		{
			MethodName: "GetNewAssetProposals",
			Handler:    _TradingData_GetNewAssetProposals_Handler,
		},
		{
			MethodName: "GetProposalByID",
			Handler:    _TradingData_GetProposalByID_Handler,
		},
		{
			MethodName: "GetProposalByReference",
			Handler:    _TradingData_GetProposalByReference_Handler,
		},
		{
			MethodName: "Statistics",
			Handler:    _TradingData_Statistics_Handler,
		},
		{
			MethodName: "GetVegaTime",
			Handler:    _TradingData_GetVegaTime_Handler,
		},
		{
			MethodName: "GetNodeSignaturesAggregate",
			Handler:    _TradingData_GetNodeSignaturesAggregate_Handler,
		},
		{
			MethodName: "AssetByID",
			Handler:    _TradingData_AssetByID_Handler,
		},
		{
			MethodName: "Assets",
			Handler:    _TradingData_Assets_Handler,
		},
		{
			MethodName: "EstimateFee",
			Handler:    _TradingData_EstimateFee_Handler,
		},
		{
			MethodName: "EstimateMargin",
			Handler:    _TradingData_EstimateMargin_Handler,
		},
		{
			MethodName: "ERC20WithdrawalApproval",
			Handler:    _TradingData_ERC20WithdrawalApproval_Handler,
		},
		{
			MethodName: "Withdrawal",
			Handler:    _TradingData_Withdrawal_Handler,
		},
		{
			MethodName: "Withdrawals",
			Handler:    _TradingData_Withdrawals_Handler,
		},
		{
			MethodName: "Deposit",
			Handler:    _TradingData_Deposit_Handler,
		},
		{
			MethodName: "Deposits",
			Handler:    _TradingData_Deposits_Handler,
		},
		{
			MethodName: "NetworkParameters",
			Handler:    _TradingData_NetworkParameters_Handler,
		},
		{
			MethodName: "LiquidityProvisions",
			Handler:    _TradingData_LiquidityProvisions_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ObserveGovernance",
			Handler:       _TradingData_ObserveGovernance_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ObservePartyProposals",
			Handler:       _TradingData_ObservePartyProposals_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ObservePartyVotes",
			Handler:       _TradingData_ObservePartyVotes_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ObserveProposalVotes",
			Handler:       _TradingData_ObserveProposalVotes_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ObserveEventBus",
			Handler:       _TradingData_ObserveEventBus_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "AccountsSubscribe",
			Handler:       _TradingData_AccountsSubscribe_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "CandlesSubscribe",
			Handler:       _TradingData_CandlesSubscribe_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "MarginLevelsSubscribe",
			Handler:       _TradingData_MarginLevelsSubscribe_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "MarketDepthSubscribe",
			Handler:       _TradingData_MarketDepthSubscribe_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "MarketDepthUpdatesSubscribe",
			Handler:       _TradingData_MarketDepthUpdatesSubscribe_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "MarketsDataSubscribe",
			Handler:       _TradingData_MarketsDataSubscribe_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "OrdersSubscribe",
			Handler:       _TradingData_OrdersSubscribe_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "PositionsSubscribe",
			Handler:       _TradingData_PositionsSubscribe_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "TradesSubscribe",
			Handler:       _TradingData_TradesSubscribe_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "TransferResponsesSubscribe",
			Handler:       _TradingData_TransferResponsesSubscribe_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "api/trading.proto",
}

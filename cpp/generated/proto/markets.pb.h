// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: proto/markets.proto

#ifndef PROTOBUF_INCLUDED_proto_2fmarkets_2eproto
#define PROTOBUF_INCLUDED_proto_2fmarkets_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3007000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3007001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/unknown_field_set.h>
#include "github.com/mwitkow/go-proto-validators/validator.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_proto_2fmarkets_2eproto

// Internal implementation detail -- do not use these members.
struct TableStruct_proto_2fmarkets_2eproto {
  static const ::google::protobuf::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::ParseTable schema[16]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors_proto_2fmarkets_2eproto();
namespace vega {
class ContinuousTrading;
class ContinuousTradingDefaultTypeInternal;
extern ContinuousTradingDefaultTypeInternal _ContinuousTrading_default_instance_;
class DiscreteTrading;
class DiscreteTradingDefaultTypeInternal;
extern DiscreteTradingDefaultTypeInternal _DiscreteTrading_default_instance_;
class EthereumEvent;
class EthereumEventDefaultTypeInternal;
extern EthereumEventDefaultTypeInternal _EthereumEvent_default_instance_;
class ExternalRiskModel;
class ExternalRiskModelDefaultTypeInternal;
extern ExternalRiskModelDefaultTypeInternal _ExternalRiskModel_default_instance_;
class ExternalRiskModel_ConfigEntry_DoNotUse;
class ExternalRiskModel_ConfigEntry_DoNotUseDefaultTypeInternal;
extern ExternalRiskModel_ConfigEntry_DoNotUseDefaultTypeInternal _ExternalRiskModel_ConfigEntry_DoNotUse_default_instance_;
class Future;
class FutureDefaultTypeInternal;
extern FutureDefaultTypeInternal _Future_default_instance_;
class Instrument;
class InstrumentDefaultTypeInternal;
extern InstrumentDefaultTypeInternal _Instrument_default_instance_;
class InstrumentMetadata;
class InstrumentMetadataDefaultTypeInternal;
extern InstrumentMetadataDefaultTypeInternal _InstrumentMetadata_default_instance_;
class LogNormalModelParams;
class LogNormalModelParamsDefaultTypeInternal;
extern LogNormalModelParamsDefaultTypeInternal _LogNormalModelParams_default_instance_;
class LogNormalRiskModel;
class LogNormalRiskModelDefaultTypeInternal;
extern LogNormalRiskModelDefaultTypeInternal _LogNormalRiskModel_default_instance_;
class MarginCalculator;
class MarginCalculatorDefaultTypeInternal;
extern MarginCalculatorDefaultTypeInternal _MarginCalculator_default_instance_;
class Market;
class MarketDefaultTypeInternal;
extern MarketDefaultTypeInternal _Market_default_instance_;
class ScalingFactors;
class ScalingFactorsDefaultTypeInternal;
extern ScalingFactorsDefaultTypeInternal _ScalingFactors_default_instance_;
class SimpleModelParams;
class SimpleModelParamsDefaultTypeInternal;
extern SimpleModelParamsDefaultTypeInternal _SimpleModelParams_default_instance_;
class SimpleRiskModel;
class SimpleRiskModelDefaultTypeInternal;
extern SimpleRiskModelDefaultTypeInternal _SimpleRiskModel_default_instance_;
class TradableInstrument;
class TradableInstrumentDefaultTypeInternal;
extern TradableInstrumentDefaultTypeInternal _TradableInstrument_default_instance_;
}  // namespace vega
namespace google {
namespace protobuf {
template<> ::vega::ContinuousTrading* Arena::CreateMaybeMessage<::vega::ContinuousTrading>(Arena*);
template<> ::vega::DiscreteTrading* Arena::CreateMaybeMessage<::vega::DiscreteTrading>(Arena*);
template<> ::vega::EthereumEvent* Arena::CreateMaybeMessage<::vega::EthereumEvent>(Arena*);
template<> ::vega::ExternalRiskModel* Arena::CreateMaybeMessage<::vega::ExternalRiskModel>(Arena*);
template<> ::vega::ExternalRiskModel_ConfigEntry_DoNotUse* Arena::CreateMaybeMessage<::vega::ExternalRiskModel_ConfigEntry_DoNotUse>(Arena*);
template<> ::vega::Future* Arena::CreateMaybeMessage<::vega::Future>(Arena*);
template<> ::vega::Instrument* Arena::CreateMaybeMessage<::vega::Instrument>(Arena*);
template<> ::vega::InstrumentMetadata* Arena::CreateMaybeMessage<::vega::InstrumentMetadata>(Arena*);
template<> ::vega::LogNormalModelParams* Arena::CreateMaybeMessage<::vega::LogNormalModelParams>(Arena*);
template<> ::vega::LogNormalRiskModel* Arena::CreateMaybeMessage<::vega::LogNormalRiskModel>(Arena*);
template<> ::vega::MarginCalculator* Arena::CreateMaybeMessage<::vega::MarginCalculator>(Arena*);
template<> ::vega::Market* Arena::CreateMaybeMessage<::vega::Market>(Arena*);
template<> ::vega::ScalingFactors* Arena::CreateMaybeMessage<::vega::ScalingFactors>(Arena*);
template<> ::vega::SimpleModelParams* Arena::CreateMaybeMessage<::vega::SimpleModelParams>(Arena*);
template<> ::vega::SimpleRiskModel* Arena::CreateMaybeMessage<::vega::SimpleRiskModel>(Arena*);
template<> ::vega::TradableInstrument* Arena::CreateMaybeMessage<::vega::TradableInstrument>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace vega {

// ===================================================================

class ContinuousTrading :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vega.ContinuousTrading) */ {
 public:
  ContinuousTrading();
  virtual ~ContinuousTrading();

  ContinuousTrading(const ContinuousTrading& from);

  inline ContinuousTrading& operator=(const ContinuousTrading& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ContinuousTrading(ContinuousTrading&& from) noexcept
    : ContinuousTrading() {
    *this = ::std::move(from);
  }

  inline ContinuousTrading& operator=(ContinuousTrading&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ContinuousTrading& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ContinuousTrading* internal_default_instance() {
    return reinterpret_cast<const ContinuousTrading*>(
               &_ContinuousTrading_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(ContinuousTrading* other);
  friend void swap(ContinuousTrading& a, ContinuousTrading& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ContinuousTrading* New() const final {
    return CreateMaybeMessage<ContinuousTrading>(nullptr);
  }

  ContinuousTrading* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ContinuousTrading>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ContinuousTrading& from);
  void MergeFrom(const ContinuousTrading& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ContinuousTrading* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint64 tickSize = 1;
  void clear_ticksize();
  static const int kTickSizeFieldNumber = 1;
  ::google::protobuf::uint64 ticksize() const;
  void set_ticksize(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:vega.ContinuousTrading)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint64 ticksize_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fmarkets_2eproto;
};
// -------------------------------------------------------------------

class DiscreteTrading :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vega.DiscreteTrading) */ {
 public:
  DiscreteTrading();
  virtual ~DiscreteTrading();

  DiscreteTrading(const DiscreteTrading& from);

  inline DiscreteTrading& operator=(const DiscreteTrading& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DiscreteTrading(DiscreteTrading&& from) noexcept
    : DiscreteTrading() {
    *this = ::std::move(from);
  }

  inline DiscreteTrading& operator=(DiscreteTrading&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const DiscreteTrading& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DiscreteTrading* internal_default_instance() {
    return reinterpret_cast<const DiscreteTrading*>(
               &_DiscreteTrading_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(DiscreteTrading* other);
  friend void swap(DiscreteTrading& a, DiscreteTrading& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DiscreteTrading* New() const final {
    return CreateMaybeMessage<DiscreteTrading>(nullptr);
  }

  DiscreteTrading* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DiscreteTrading>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DiscreteTrading& from);
  void MergeFrom(const DiscreteTrading& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DiscreteTrading* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int64 durationNs = 1 [(.validator.field) = {
  void clear_durationns();
  static const int kDurationNsFieldNumber = 1;
  ::google::protobuf::int64 durationns() const;
  void set_durationns(::google::protobuf::int64 value);

  // uint64 tickSize = 2;
  void clear_ticksize();
  static const int kTickSizeFieldNumber = 2;
  ::google::protobuf::uint64 ticksize() const;
  void set_ticksize(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:vega.DiscreteTrading)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int64 durationns_;
  ::google::protobuf::uint64 ticksize_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fmarkets_2eproto;
};
// -------------------------------------------------------------------

class Future :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vega.Future) */ {
 public:
  Future();
  virtual ~Future();

  Future(const Future& from);

  inline Future& operator=(const Future& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Future(Future&& from) noexcept
    : Future() {
    *this = ::std::move(from);
  }

  inline Future& operator=(Future&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Future& default_instance();

  enum OracleCase {
    kEthereumEvent = 100,
    ORACLE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Future* internal_default_instance() {
    return reinterpret_cast<const Future*>(
               &_Future_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(Future* other);
  friend void swap(Future& a, Future& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Future* New() const final {
    return CreateMaybeMessage<Future>(nullptr);
  }

  Future* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Future>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Future& from);
  void MergeFrom(const Future& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Future* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string maturity = 1;
  void clear_maturity();
  static const int kMaturityFieldNumber = 1;
  const ::std::string& maturity() const;
  void set_maturity(const ::std::string& value);
  #if LANG_CXX11
  void set_maturity(::std::string&& value);
  #endif
  void set_maturity(const char* value);
  void set_maturity(const char* value, size_t size);
  ::std::string* mutable_maturity();
  ::std::string* release_maturity();
  void set_allocated_maturity(::std::string* maturity);

  // string asset = 2;
  void clear_asset();
  static const int kAssetFieldNumber = 2;
  const ::std::string& asset() const;
  void set_asset(const ::std::string& value);
  #if LANG_CXX11
  void set_asset(::std::string&& value);
  #endif
  void set_asset(const char* value);
  void set_asset(const char* value, size_t size);
  ::std::string* mutable_asset();
  ::std::string* release_asset();
  void set_allocated_asset(::std::string* asset);

  // .vega.EthereumEvent ethereumEvent = 100;
  bool has_ethereumevent() const;
  void clear_ethereumevent();
  static const int kEthereumEventFieldNumber = 100;
  const ::vega::EthereumEvent& ethereumevent() const;
  ::vega::EthereumEvent* release_ethereumevent();
  ::vega::EthereumEvent* mutable_ethereumevent();
  void set_allocated_ethereumevent(::vega::EthereumEvent* ethereumevent);

  void clear_oracle();
  OracleCase oracle_case() const;
  // @@protoc_insertion_point(class_scope:vega.Future)
 private:
  class HasBitSetters;
  void set_has_ethereumevent();

  inline bool has_oracle() const;
  inline void clear_has_oracle();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr maturity_;
  ::google::protobuf::internal::ArenaStringPtr asset_;
  union OracleUnion {
    OracleUnion() {}
    ::vega::EthereumEvent* ethereumevent_;
  } oracle_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::TableStruct_proto_2fmarkets_2eproto;
};
// -------------------------------------------------------------------

class EthereumEvent :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vega.EthereumEvent) */ {
 public:
  EthereumEvent();
  virtual ~EthereumEvent();

  EthereumEvent(const EthereumEvent& from);

  inline EthereumEvent& operator=(const EthereumEvent& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EthereumEvent(EthereumEvent&& from) noexcept
    : EthereumEvent() {
    *this = ::std::move(from);
  }

  inline EthereumEvent& operator=(EthereumEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const EthereumEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EthereumEvent* internal_default_instance() {
    return reinterpret_cast<const EthereumEvent*>(
               &_EthereumEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(EthereumEvent* other);
  friend void swap(EthereumEvent& a, EthereumEvent& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EthereumEvent* New() const final {
    return CreateMaybeMessage<EthereumEvent>(nullptr);
  }

  EthereumEvent* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EthereumEvent>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const EthereumEvent& from);
  void MergeFrom(const EthereumEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EthereumEvent* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string contractID = 1;
  void clear_contractid();
  static const int kContractIDFieldNumber = 1;
  const ::std::string& contractid() const;
  void set_contractid(const ::std::string& value);
  #if LANG_CXX11
  void set_contractid(::std::string&& value);
  #endif
  void set_contractid(const char* value);
  void set_contractid(const char* value, size_t size);
  ::std::string* mutable_contractid();
  ::std::string* release_contractid();
  void set_allocated_contractid(::std::string* contractid);

  // string event = 2;
  void clear_event();
  static const int kEventFieldNumber = 2;
  const ::std::string& event() const;
  void set_event(const ::std::string& value);
  #if LANG_CXX11
  void set_event(::std::string&& value);
  #endif
  void set_event(const char* value);
  void set_event(const char* value, size_t size);
  ::std::string* mutable_event();
  ::std::string* release_event();
  void set_allocated_event(::std::string* event);

  // uint64 value = 3;
  void clear_value();
  static const int kValueFieldNumber = 3;
  ::google::protobuf::uint64 value() const;
  void set_value(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:vega.EthereumEvent)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr contractid_;
  ::google::protobuf::internal::ArenaStringPtr event_;
  ::google::protobuf::uint64 value_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fmarkets_2eproto;
};
// -------------------------------------------------------------------

class InstrumentMetadata :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vega.InstrumentMetadata) */ {
 public:
  InstrumentMetadata();
  virtual ~InstrumentMetadata();

  InstrumentMetadata(const InstrumentMetadata& from);

  inline InstrumentMetadata& operator=(const InstrumentMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  InstrumentMetadata(InstrumentMetadata&& from) noexcept
    : InstrumentMetadata() {
    *this = ::std::move(from);
  }

  inline InstrumentMetadata& operator=(InstrumentMetadata&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const InstrumentMetadata& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const InstrumentMetadata* internal_default_instance() {
    return reinterpret_cast<const InstrumentMetadata*>(
               &_InstrumentMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(InstrumentMetadata* other);
  friend void swap(InstrumentMetadata& a, InstrumentMetadata& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline InstrumentMetadata* New() const final {
    return CreateMaybeMessage<InstrumentMetadata>(nullptr);
  }

  InstrumentMetadata* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<InstrumentMetadata>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const InstrumentMetadata& from);
  void MergeFrom(const InstrumentMetadata& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InstrumentMetadata* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string tags = 1;
  int tags_size() const;
  void clear_tags();
  static const int kTagsFieldNumber = 1;
  const ::std::string& tags(int index) const;
  ::std::string* mutable_tags(int index);
  void set_tags(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_tags(int index, ::std::string&& value);
  #endif
  void set_tags(int index, const char* value);
  void set_tags(int index, const char* value, size_t size);
  ::std::string* add_tags();
  void add_tags(const ::std::string& value);
  #if LANG_CXX11
  void add_tags(::std::string&& value);
  #endif
  void add_tags(const char* value);
  void add_tags(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField<::std::string>& tags() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* mutable_tags();

  // @@protoc_insertion_point(class_scope:vega.InstrumentMetadata)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField<::std::string> tags_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fmarkets_2eproto;
};
// -------------------------------------------------------------------

class Instrument :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vega.Instrument) */ {
 public:
  Instrument();
  virtual ~Instrument();

  Instrument(const Instrument& from);

  inline Instrument& operator=(const Instrument& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Instrument(Instrument&& from) noexcept
    : Instrument() {
    *this = ::std::move(from);
  }

  inline Instrument& operator=(Instrument&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Instrument& default_instance();

  enum ProductCase {
    kFuture = 100,
    PRODUCT_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Instrument* internal_default_instance() {
    return reinterpret_cast<const Instrument*>(
               &_Instrument_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(Instrument* other);
  friend void swap(Instrument& a, Instrument& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Instrument* New() const final {
    return CreateMaybeMessage<Instrument>(nullptr);
  }

  Instrument* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Instrument>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Instrument& from);
  void MergeFrom(const Instrument& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Instrument* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // string code = 2;
  void clear_code();
  static const int kCodeFieldNumber = 2;
  const ::std::string& code() const;
  void set_code(const ::std::string& value);
  #if LANG_CXX11
  void set_code(::std::string&& value);
  #endif
  void set_code(const char* value);
  void set_code(const char* value, size_t size);
  ::std::string* mutable_code();
  ::std::string* release_code();
  void set_allocated_code(::std::string* code);

  // string name = 3;
  void clear_name();
  static const int kNameFieldNumber = 3;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string baseName = 4;
  void clear_basename();
  static const int kBaseNameFieldNumber = 4;
  const ::std::string& basename() const;
  void set_basename(const ::std::string& value);
  #if LANG_CXX11
  void set_basename(::std::string&& value);
  #endif
  void set_basename(const char* value);
  void set_basename(const char* value, size_t size);
  ::std::string* mutable_basename();
  ::std::string* release_basename();
  void set_allocated_basename(::std::string* basename);

  // string quoteName = 5;
  void clear_quotename();
  static const int kQuoteNameFieldNumber = 5;
  const ::std::string& quotename() const;
  void set_quotename(const ::std::string& value);
  #if LANG_CXX11
  void set_quotename(::std::string&& value);
  #endif
  void set_quotename(const char* value);
  void set_quotename(const char* value, size_t size);
  ::std::string* mutable_quotename();
  ::std::string* release_quotename();
  void set_allocated_quotename(::std::string* quotename);

  // .vega.InstrumentMetadata metadata = 6;
  bool has_metadata() const;
  void clear_metadata();
  static const int kMetadataFieldNumber = 6;
  const ::vega::InstrumentMetadata& metadata() const;
  ::vega::InstrumentMetadata* release_metadata();
  ::vega::InstrumentMetadata* mutable_metadata();
  void set_allocated_metadata(::vega::InstrumentMetadata* metadata);

  // uint64 initialMarkPrice = 7;
  void clear_initialmarkprice();
  static const int kInitialMarkPriceFieldNumber = 7;
  ::google::protobuf::uint64 initialmarkprice() const;
  void set_initialmarkprice(::google::protobuf::uint64 value);

  // .vega.Future future = 100;
  bool has_future() const;
  void clear_future();
  static const int kFutureFieldNumber = 100;
  const ::vega::Future& future() const;
  ::vega::Future* release_future();
  ::vega::Future* mutable_future();
  void set_allocated_future(::vega::Future* future);

  void clear_product();
  ProductCase product_case() const;
  // @@protoc_insertion_point(class_scope:vega.Instrument)
 private:
  class HasBitSetters;
  void set_has_future();

  inline bool has_product() const;
  inline void clear_has_product();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::internal::ArenaStringPtr code_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr basename_;
  ::google::protobuf::internal::ArenaStringPtr quotename_;
  ::vega::InstrumentMetadata* metadata_;
  ::google::protobuf::uint64 initialmarkprice_;
  union ProductUnion {
    ProductUnion() {}
    ::vega::Future* future_;
  } product_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::TableStruct_proto_2fmarkets_2eproto;
};
// -------------------------------------------------------------------

class LogNormalRiskModel :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vega.LogNormalRiskModel) */ {
 public:
  LogNormalRiskModel();
  virtual ~LogNormalRiskModel();

  LogNormalRiskModel(const LogNormalRiskModel& from);

  inline LogNormalRiskModel& operator=(const LogNormalRiskModel& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LogNormalRiskModel(LogNormalRiskModel&& from) noexcept
    : LogNormalRiskModel() {
    *this = ::std::move(from);
  }

  inline LogNormalRiskModel& operator=(LogNormalRiskModel&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const LogNormalRiskModel& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LogNormalRiskModel* internal_default_instance() {
    return reinterpret_cast<const LogNormalRiskModel*>(
               &_LogNormalRiskModel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(LogNormalRiskModel* other);
  friend void swap(LogNormalRiskModel& a, LogNormalRiskModel& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LogNormalRiskModel* New() const final {
    return CreateMaybeMessage<LogNormalRiskModel>(nullptr);
  }

  LogNormalRiskModel* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LogNormalRiskModel>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LogNormalRiskModel& from);
  void MergeFrom(const LogNormalRiskModel& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LogNormalRiskModel* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .vega.LogNormalModelParams params = 3;
  bool has_params() const;
  void clear_params();
  static const int kParamsFieldNumber = 3;
  const ::vega::LogNormalModelParams& params() const;
  ::vega::LogNormalModelParams* release_params();
  ::vega::LogNormalModelParams* mutable_params();
  void set_allocated_params(::vega::LogNormalModelParams* params);

  // double riskAversionParameter = 1;
  void clear_riskaversionparameter();
  static const int kRiskAversionParameterFieldNumber = 1;
  double riskaversionparameter() const;
  void set_riskaversionparameter(double value);

  // double tau = 2;
  void clear_tau();
  static const int kTauFieldNumber = 2;
  double tau() const;
  void set_tau(double value);

  // @@protoc_insertion_point(class_scope:vega.LogNormalRiskModel)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::vega::LogNormalModelParams* params_;
  double riskaversionparameter_;
  double tau_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fmarkets_2eproto;
};
// -------------------------------------------------------------------

class LogNormalModelParams :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vega.LogNormalModelParams) */ {
 public:
  LogNormalModelParams();
  virtual ~LogNormalModelParams();

  LogNormalModelParams(const LogNormalModelParams& from);

  inline LogNormalModelParams& operator=(const LogNormalModelParams& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LogNormalModelParams(LogNormalModelParams&& from) noexcept
    : LogNormalModelParams() {
    *this = ::std::move(from);
  }

  inline LogNormalModelParams& operator=(LogNormalModelParams&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const LogNormalModelParams& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LogNormalModelParams* internal_default_instance() {
    return reinterpret_cast<const LogNormalModelParams*>(
               &_LogNormalModelParams_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(LogNormalModelParams* other);
  friend void swap(LogNormalModelParams& a, LogNormalModelParams& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LogNormalModelParams* New() const final {
    return CreateMaybeMessage<LogNormalModelParams>(nullptr);
  }

  LogNormalModelParams* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LogNormalModelParams>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LogNormalModelParams& from);
  void MergeFrom(const LogNormalModelParams& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LogNormalModelParams* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // double mu = 1;
  void clear_mu();
  static const int kMuFieldNumber = 1;
  double mu() const;
  void set_mu(double value);

  // double r = 2;
  void clear_r();
  static const int kRFieldNumber = 2;
  double r() const;
  void set_r(double value);

  // double sigma = 3;
  void clear_sigma();
  static const int kSigmaFieldNumber = 3;
  double sigma() const;
  void set_sigma(double value);

  // @@protoc_insertion_point(class_scope:vega.LogNormalModelParams)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  double mu_;
  double r_;
  double sigma_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fmarkets_2eproto;
};
// -------------------------------------------------------------------

class SimpleRiskModel :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vega.SimpleRiskModel) */ {
 public:
  SimpleRiskModel();
  virtual ~SimpleRiskModel();

  SimpleRiskModel(const SimpleRiskModel& from);

  inline SimpleRiskModel& operator=(const SimpleRiskModel& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SimpleRiskModel(SimpleRiskModel&& from) noexcept
    : SimpleRiskModel() {
    *this = ::std::move(from);
  }

  inline SimpleRiskModel& operator=(SimpleRiskModel&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const SimpleRiskModel& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SimpleRiskModel* internal_default_instance() {
    return reinterpret_cast<const SimpleRiskModel*>(
               &_SimpleRiskModel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(SimpleRiskModel* other);
  friend void swap(SimpleRiskModel& a, SimpleRiskModel& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SimpleRiskModel* New() const final {
    return CreateMaybeMessage<SimpleRiskModel>(nullptr);
  }

  SimpleRiskModel* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SimpleRiskModel>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SimpleRiskModel& from);
  void MergeFrom(const SimpleRiskModel& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SimpleRiskModel* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .vega.SimpleModelParams params = 1;
  bool has_params() const;
  void clear_params();
  static const int kParamsFieldNumber = 1;
  const ::vega::SimpleModelParams& params() const;
  ::vega::SimpleModelParams* release_params();
  ::vega::SimpleModelParams* mutable_params();
  void set_allocated_params(::vega::SimpleModelParams* params);

  // @@protoc_insertion_point(class_scope:vega.SimpleRiskModel)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::vega::SimpleModelParams* params_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fmarkets_2eproto;
};
// -------------------------------------------------------------------

class SimpleModelParams :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vega.SimpleModelParams) */ {
 public:
  SimpleModelParams();
  virtual ~SimpleModelParams();

  SimpleModelParams(const SimpleModelParams& from);

  inline SimpleModelParams& operator=(const SimpleModelParams& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SimpleModelParams(SimpleModelParams&& from) noexcept
    : SimpleModelParams() {
    *this = ::std::move(from);
  }

  inline SimpleModelParams& operator=(SimpleModelParams&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const SimpleModelParams& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SimpleModelParams* internal_default_instance() {
    return reinterpret_cast<const SimpleModelParams*>(
               &_SimpleModelParams_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(SimpleModelParams* other);
  friend void swap(SimpleModelParams& a, SimpleModelParams& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SimpleModelParams* New() const final {
    return CreateMaybeMessage<SimpleModelParams>(nullptr);
  }

  SimpleModelParams* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SimpleModelParams>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SimpleModelParams& from);
  void MergeFrom(const SimpleModelParams& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SimpleModelParams* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // double factorLong = 1;
  void clear_factorlong();
  static const int kFactorLongFieldNumber = 1;
  double factorlong() const;
  void set_factorlong(double value);

  // double factorShort = 2;
  void clear_factorshort();
  static const int kFactorShortFieldNumber = 2;
  double factorshort() const;
  void set_factorshort(double value);

  // @@protoc_insertion_point(class_scope:vega.SimpleModelParams)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  double factorlong_;
  double factorshort_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fmarkets_2eproto;
};
// -------------------------------------------------------------------

class ExternalRiskModel_ConfigEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<ExternalRiskModel_ConfigEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
static bool _ParseMap(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  typedef ::google::protobuf::internal::MapEntry<ExternalRiskModel_ConfigEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  ExternalRiskModel_ConfigEntry_DoNotUse();
  ExternalRiskModel_ConfigEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const ExternalRiskModel_ConfigEntry_DoNotUse& other);
  static const ExternalRiskModel_ConfigEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ExternalRiskModel_ConfigEntry_DoNotUse*>(&_ExternalRiskModel_ConfigEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class ExternalRiskModel :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vega.ExternalRiskModel) */ {
 public:
  ExternalRiskModel();
  virtual ~ExternalRiskModel();

  ExternalRiskModel(const ExternalRiskModel& from);

  inline ExternalRiskModel& operator=(const ExternalRiskModel& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ExternalRiskModel(ExternalRiskModel&& from) noexcept
    : ExternalRiskModel() {
    *this = ::std::move(from);
  }

  inline ExternalRiskModel& operator=(ExternalRiskModel&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ExternalRiskModel& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ExternalRiskModel* internal_default_instance() {
    return reinterpret_cast<const ExternalRiskModel*>(
               &_ExternalRiskModel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(ExternalRiskModel* other);
  friend void swap(ExternalRiskModel& a, ExternalRiskModel& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ExternalRiskModel* New() const final {
    return CreateMaybeMessage<ExternalRiskModel>(nullptr);
  }

  ExternalRiskModel* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ExternalRiskModel>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ExternalRiskModel& from);
  void MergeFrom(const ExternalRiskModel& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExternalRiskModel* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, string> config = 3;
  int config_size() const;
  void clear_config();
  static const int kConfigFieldNumber = 3;
  const ::google::protobuf::Map< ::std::string, ::std::string >&
      config() const;
  ::google::protobuf::Map< ::std::string, ::std::string >*
      mutable_config();

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string socket = 2;
  void clear_socket();
  static const int kSocketFieldNumber = 2;
  const ::std::string& socket() const;
  void set_socket(const ::std::string& value);
  #if LANG_CXX11
  void set_socket(::std::string&& value);
  #endif
  void set_socket(const char* value);
  void set_socket(const char* value, size_t size);
  ::std::string* mutable_socket();
  ::std::string* release_socket();
  void set_allocated_socket(::std::string* socket);

  // @@protoc_insertion_point(class_scope:vega.ExternalRiskModel)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::MapField<
      ExternalRiskModel_ConfigEntry_DoNotUse,
      ::std::string, ::std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      0 > config_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr socket_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fmarkets_2eproto;
};
// -------------------------------------------------------------------

class ScalingFactors :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vega.ScalingFactors) */ {
 public:
  ScalingFactors();
  virtual ~ScalingFactors();

  ScalingFactors(const ScalingFactors& from);

  inline ScalingFactors& operator=(const ScalingFactors& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ScalingFactors(ScalingFactors&& from) noexcept
    : ScalingFactors() {
    *this = ::std::move(from);
  }

  inline ScalingFactors& operator=(ScalingFactors&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ScalingFactors& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ScalingFactors* internal_default_instance() {
    return reinterpret_cast<const ScalingFactors*>(
               &_ScalingFactors_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(ScalingFactors* other);
  friend void swap(ScalingFactors& a, ScalingFactors& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ScalingFactors* New() const final {
    return CreateMaybeMessage<ScalingFactors>(nullptr);
  }

  ScalingFactors* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ScalingFactors>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ScalingFactors& from);
  void MergeFrom(const ScalingFactors& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ScalingFactors* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // double searchLevel = 1;
  void clear_searchlevel();
  static const int kSearchLevelFieldNumber = 1;
  double searchlevel() const;
  void set_searchlevel(double value);

  // double initialMargin = 2;
  void clear_initialmargin();
  static const int kInitialMarginFieldNumber = 2;
  double initialmargin() const;
  void set_initialmargin(double value);

  // double collateralRelease = 3;
  void clear_collateralrelease();
  static const int kCollateralReleaseFieldNumber = 3;
  double collateralrelease() const;
  void set_collateralrelease(double value);

  // @@protoc_insertion_point(class_scope:vega.ScalingFactors)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  double searchlevel_;
  double initialmargin_;
  double collateralrelease_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fmarkets_2eproto;
};
// -------------------------------------------------------------------

class MarginCalculator :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vega.MarginCalculator) */ {
 public:
  MarginCalculator();
  virtual ~MarginCalculator();

  MarginCalculator(const MarginCalculator& from);

  inline MarginCalculator& operator=(const MarginCalculator& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MarginCalculator(MarginCalculator&& from) noexcept
    : MarginCalculator() {
    *this = ::std::move(from);
  }

  inline MarginCalculator& operator=(MarginCalculator&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const MarginCalculator& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MarginCalculator* internal_default_instance() {
    return reinterpret_cast<const MarginCalculator*>(
               &_MarginCalculator_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(MarginCalculator* other);
  friend void swap(MarginCalculator& a, MarginCalculator& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MarginCalculator* New() const final {
    return CreateMaybeMessage<MarginCalculator>(nullptr);
  }

  MarginCalculator* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MarginCalculator>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MarginCalculator& from);
  void MergeFrom(const MarginCalculator& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MarginCalculator* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .vega.ScalingFactors scalingFactors = 1;
  bool has_scalingfactors() const;
  void clear_scalingfactors();
  static const int kScalingFactorsFieldNumber = 1;
  const ::vega::ScalingFactors& scalingfactors() const;
  ::vega::ScalingFactors* release_scalingfactors();
  ::vega::ScalingFactors* mutable_scalingfactors();
  void set_allocated_scalingfactors(::vega::ScalingFactors* scalingfactors);

  // @@protoc_insertion_point(class_scope:vega.MarginCalculator)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::vega::ScalingFactors* scalingfactors_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fmarkets_2eproto;
};
// -------------------------------------------------------------------

class TradableInstrument :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vega.TradableInstrument) */ {
 public:
  TradableInstrument();
  virtual ~TradableInstrument();

  TradableInstrument(const TradableInstrument& from);

  inline TradableInstrument& operator=(const TradableInstrument& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TradableInstrument(TradableInstrument&& from) noexcept
    : TradableInstrument() {
    *this = ::std::move(from);
  }

  inline TradableInstrument& operator=(TradableInstrument&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const TradableInstrument& default_instance();

  enum RiskModelCase {
    kLogNormalRiskModel = 100,
    kExternalRiskModel = 101,
    kSimpleRiskModel = 102,
    RISKMODEL_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TradableInstrument* internal_default_instance() {
    return reinterpret_cast<const TradableInstrument*>(
               &_TradableInstrument_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(TradableInstrument* other);
  friend void swap(TradableInstrument& a, TradableInstrument& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TradableInstrument* New() const final {
    return CreateMaybeMessage<TradableInstrument>(nullptr);
  }

  TradableInstrument* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TradableInstrument>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TradableInstrument& from);
  void MergeFrom(const TradableInstrument& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TradableInstrument* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .vega.Instrument instrument = 1;
  bool has_instrument() const;
  void clear_instrument();
  static const int kInstrumentFieldNumber = 1;
  const ::vega::Instrument& instrument() const;
  ::vega::Instrument* release_instrument();
  ::vega::Instrument* mutable_instrument();
  void set_allocated_instrument(::vega::Instrument* instrument);

  // .vega.MarginCalculator marginCalculator = 2;
  bool has_margincalculator() const;
  void clear_margincalculator();
  static const int kMarginCalculatorFieldNumber = 2;
  const ::vega::MarginCalculator& margincalculator() const;
  ::vega::MarginCalculator* release_margincalculator();
  ::vega::MarginCalculator* mutable_margincalculator();
  void set_allocated_margincalculator(::vega::MarginCalculator* margincalculator);

  // .vega.LogNormalRiskModel logNormalRiskModel = 100;
  bool has_lognormalriskmodel() const;
  void clear_lognormalriskmodel();
  static const int kLogNormalRiskModelFieldNumber = 100;
  const ::vega::LogNormalRiskModel& lognormalriskmodel() const;
  ::vega::LogNormalRiskModel* release_lognormalriskmodel();
  ::vega::LogNormalRiskModel* mutable_lognormalriskmodel();
  void set_allocated_lognormalriskmodel(::vega::LogNormalRiskModel* lognormalriskmodel);

  // .vega.ExternalRiskModel externalRiskModel = 101;
  bool has_externalriskmodel() const;
  void clear_externalriskmodel();
  static const int kExternalRiskModelFieldNumber = 101;
  const ::vega::ExternalRiskModel& externalriskmodel() const;
  ::vega::ExternalRiskModel* release_externalriskmodel();
  ::vega::ExternalRiskModel* mutable_externalriskmodel();
  void set_allocated_externalriskmodel(::vega::ExternalRiskModel* externalriskmodel);

  // .vega.SimpleRiskModel simpleRiskModel = 102;
  bool has_simpleriskmodel() const;
  void clear_simpleriskmodel();
  static const int kSimpleRiskModelFieldNumber = 102;
  const ::vega::SimpleRiskModel& simpleriskmodel() const;
  ::vega::SimpleRiskModel* release_simpleriskmodel();
  ::vega::SimpleRiskModel* mutable_simpleriskmodel();
  void set_allocated_simpleriskmodel(::vega::SimpleRiskModel* simpleriskmodel);

  void clear_riskModel();
  RiskModelCase riskModel_case() const;
  // @@protoc_insertion_point(class_scope:vega.TradableInstrument)
 private:
  class HasBitSetters;
  void set_has_lognormalriskmodel();
  void set_has_externalriskmodel();
  void set_has_simpleriskmodel();

  inline bool has_riskModel() const;
  inline void clear_has_riskModel();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::vega::Instrument* instrument_;
  ::vega::MarginCalculator* margincalculator_;
  union RiskModelUnion {
    RiskModelUnion() {}
    ::vega::LogNormalRiskModel* lognormalriskmodel_;
    ::vega::ExternalRiskModel* externalriskmodel_;
    ::vega::SimpleRiskModel* simpleriskmodel_;
  } riskModel_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::TableStruct_proto_2fmarkets_2eproto;
};
// -------------------------------------------------------------------

class Market :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vega.Market) */ {
 public:
  Market();
  virtual ~Market();

  Market(const Market& from);

  inline Market& operator=(const Market& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Market(Market&& from) noexcept
    : Market() {
    *this = ::std::move(from);
  }

  inline Market& operator=(Market&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Market& default_instance();

  enum TradingModeCase {
    kContinuous = 100,
    kDiscrete = 101,
    TRADINGMODE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Market* internal_default_instance() {
    return reinterpret_cast<const Market*>(
               &_Market_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(Market* other);
  friend void swap(Market& a, Market& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Market* New() const final {
    return CreateMaybeMessage<Market>(nullptr);
  }

  Market* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Market>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Market& from);
  void MergeFrom(const Market& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Market* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // .vega.TradableInstrument tradableInstrument = 2;
  bool has_tradableinstrument() const;
  void clear_tradableinstrument();
  static const int kTradableInstrumentFieldNumber = 2;
  const ::vega::TradableInstrument& tradableinstrument() const;
  ::vega::TradableInstrument* release_tradableinstrument();
  ::vega::TradableInstrument* mutable_tradableinstrument();
  void set_allocated_tradableinstrument(::vega::TradableInstrument* tradableinstrument);

  // uint64 decimalPlaces = 3;
  void clear_decimalplaces();
  static const int kDecimalPlacesFieldNumber = 3;
  ::google::protobuf::uint64 decimalplaces() const;
  void set_decimalplaces(::google::protobuf::uint64 value);

  // .vega.ContinuousTrading continuous = 100;
  bool has_continuous() const;
  void clear_continuous();
  static const int kContinuousFieldNumber = 100;
  const ::vega::ContinuousTrading& continuous() const;
  ::vega::ContinuousTrading* release_continuous();
  ::vega::ContinuousTrading* mutable_continuous();
  void set_allocated_continuous(::vega::ContinuousTrading* continuous);

  // .vega.DiscreteTrading discrete = 101;
  bool has_discrete() const;
  void clear_discrete();
  static const int kDiscreteFieldNumber = 101;
  const ::vega::DiscreteTrading& discrete() const;
  ::vega::DiscreteTrading* release_discrete();
  ::vega::DiscreteTrading* mutable_discrete();
  void set_allocated_discrete(::vega::DiscreteTrading* discrete);

  void clear_tradingMode();
  TradingModeCase tradingMode_case() const;
  // @@protoc_insertion_point(class_scope:vega.Market)
 private:
  class HasBitSetters;
  void set_has_continuous();
  void set_has_discrete();

  inline bool has_tradingMode() const;
  inline void clear_has_tradingMode();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::vega::TradableInstrument* tradableinstrument_;
  ::google::protobuf::uint64 decimalplaces_;
  union TradingModeUnion {
    TradingModeUnion() {}
    ::vega::ContinuousTrading* continuous_;
    ::vega::DiscreteTrading* discrete_;
  } tradingMode_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::TableStruct_proto_2fmarkets_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ContinuousTrading

// uint64 tickSize = 1;
inline void ContinuousTrading::clear_ticksize() {
  ticksize_ = PROTOBUF_ULONGLONG(0);
}
inline ::google::protobuf::uint64 ContinuousTrading::ticksize() const {
  // @@protoc_insertion_point(field_get:vega.ContinuousTrading.tickSize)
  return ticksize_;
}
inline void ContinuousTrading::set_ticksize(::google::protobuf::uint64 value) {

  ticksize_ = value;
  // @@protoc_insertion_point(field_set:vega.ContinuousTrading.tickSize)
}

// -------------------------------------------------------------------

// DiscreteTrading

// int64 durationNs = 1 [(.validator.field) = {
inline void DiscreteTrading::clear_durationns() {
  durationns_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 DiscreteTrading::durationns() const {
  // @@protoc_insertion_point(field_get:vega.DiscreteTrading.durationNs)
  return durationns_;
}
inline void DiscreteTrading::set_durationns(::google::protobuf::int64 value) {

  durationns_ = value;
  // @@protoc_insertion_point(field_set:vega.DiscreteTrading.durationNs)
}

// uint64 tickSize = 2;
inline void DiscreteTrading::clear_ticksize() {
  ticksize_ = PROTOBUF_ULONGLONG(0);
}
inline ::google::protobuf::uint64 DiscreteTrading::ticksize() const {
  // @@protoc_insertion_point(field_get:vega.DiscreteTrading.tickSize)
  return ticksize_;
}
inline void DiscreteTrading::set_ticksize(::google::protobuf::uint64 value) {

  ticksize_ = value;
  // @@protoc_insertion_point(field_set:vega.DiscreteTrading.tickSize)
}

// -------------------------------------------------------------------

// Future

// string maturity = 1;
inline void Future::clear_maturity() {
  maturity_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Future::maturity() const {
  // @@protoc_insertion_point(field_get:vega.Future.maturity)
  return maturity_.GetNoArena();
}
inline void Future::set_maturity(const ::std::string& value) {

  maturity_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vega.Future.maturity)
}
#if LANG_CXX11
inline void Future::set_maturity(::std::string&& value) {

  maturity_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vega.Future.maturity)
}
#endif
inline void Future::set_maturity(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  maturity_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vega.Future.maturity)
}
inline void Future::set_maturity(const char* value, size_t size) {

  maturity_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vega.Future.maturity)
}
inline ::std::string* Future::mutable_maturity() {

  // @@protoc_insertion_point(field_mutable:vega.Future.maturity)
  return maturity_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Future::release_maturity() {
  // @@protoc_insertion_point(field_release:vega.Future.maturity)

  return maturity_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Future::set_allocated_maturity(::std::string* maturity) {
  if (maturity != nullptr) {

  } else {

  }
  maturity_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), maturity);
  // @@protoc_insertion_point(field_set_allocated:vega.Future.maturity)
}

// string asset = 2;
inline void Future::clear_asset() {
  asset_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Future::asset() const {
  // @@protoc_insertion_point(field_get:vega.Future.asset)
  return asset_.GetNoArena();
}
inline void Future::set_asset(const ::std::string& value) {

  asset_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vega.Future.asset)
}
#if LANG_CXX11
inline void Future::set_asset(::std::string&& value) {

  asset_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vega.Future.asset)
}
#endif
inline void Future::set_asset(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  asset_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vega.Future.asset)
}
inline void Future::set_asset(const char* value, size_t size) {

  asset_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vega.Future.asset)
}
inline ::std::string* Future::mutable_asset() {

  // @@protoc_insertion_point(field_mutable:vega.Future.asset)
  return asset_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Future::release_asset() {
  // @@protoc_insertion_point(field_release:vega.Future.asset)

  return asset_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Future::set_allocated_asset(::std::string* asset) {
  if (asset != nullptr) {

  } else {

  }
  asset_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), asset);
  // @@protoc_insertion_point(field_set_allocated:vega.Future.asset)
}

// .vega.EthereumEvent ethereumEvent = 100;
inline bool Future::has_ethereumevent() const {
  return oracle_case() == kEthereumEvent;
}
inline void Future::set_has_ethereumevent() {
  _oneof_case_[0] = kEthereumEvent;
}
inline void Future::clear_ethereumevent() {
  if (has_ethereumevent()) {
    delete oracle_.ethereumevent_;
    clear_has_oracle();
  }
}
inline ::vega::EthereumEvent* Future::release_ethereumevent() {
  // @@protoc_insertion_point(field_release:vega.Future.ethereumEvent)
  if (has_ethereumevent()) {
    clear_has_oracle();
      ::vega::EthereumEvent* temp = oracle_.ethereumevent_;
    oracle_.ethereumevent_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vega::EthereumEvent& Future::ethereumevent() const {
  // @@protoc_insertion_point(field_get:vega.Future.ethereumEvent)
  return has_ethereumevent()
      ? *oracle_.ethereumevent_
      : *reinterpret_cast< ::vega::EthereumEvent*>(&::vega::_EthereumEvent_default_instance_);
}
inline ::vega::EthereumEvent* Future::mutable_ethereumevent() {
  if (!has_ethereumevent()) {
    clear_oracle();
    set_has_ethereumevent();
    oracle_.ethereumevent_ = CreateMaybeMessage< ::vega::EthereumEvent >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:vega.Future.ethereumEvent)
  return oracle_.ethereumevent_;
}

inline bool Future::has_oracle() const {
  return oracle_case() != ORACLE_NOT_SET;
}
inline void Future::clear_has_oracle() {
  _oneof_case_[0] = ORACLE_NOT_SET;
}
inline Future::OracleCase Future::oracle_case() const {
  return Future::OracleCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// EthereumEvent

// string contractID = 1;
inline void EthereumEvent::clear_contractid() {
  contractid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& EthereumEvent::contractid() const {
  // @@protoc_insertion_point(field_get:vega.EthereumEvent.contractID)
  return contractid_.GetNoArena();
}
inline void EthereumEvent::set_contractid(const ::std::string& value) {

  contractid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vega.EthereumEvent.contractID)
}
#if LANG_CXX11
inline void EthereumEvent::set_contractid(::std::string&& value) {

  contractid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vega.EthereumEvent.contractID)
}
#endif
inline void EthereumEvent::set_contractid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  contractid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vega.EthereumEvent.contractID)
}
inline void EthereumEvent::set_contractid(const char* value, size_t size) {

  contractid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vega.EthereumEvent.contractID)
}
inline ::std::string* EthereumEvent::mutable_contractid() {

  // @@protoc_insertion_point(field_mutable:vega.EthereumEvent.contractID)
  return contractid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EthereumEvent::release_contractid() {
  // @@protoc_insertion_point(field_release:vega.EthereumEvent.contractID)

  return contractid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EthereumEvent::set_allocated_contractid(::std::string* contractid) {
  if (contractid != nullptr) {

  } else {

  }
  contractid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), contractid);
  // @@protoc_insertion_point(field_set_allocated:vega.EthereumEvent.contractID)
}

// string event = 2;
inline void EthereumEvent::clear_event() {
  event_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& EthereumEvent::event() const {
  // @@protoc_insertion_point(field_get:vega.EthereumEvent.event)
  return event_.GetNoArena();
}
inline void EthereumEvent::set_event(const ::std::string& value) {

  event_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vega.EthereumEvent.event)
}
#if LANG_CXX11
inline void EthereumEvent::set_event(::std::string&& value) {

  event_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vega.EthereumEvent.event)
}
#endif
inline void EthereumEvent::set_event(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  event_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vega.EthereumEvent.event)
}
inline void EthereumEvent::set_event(const char* value, size_t size) {

  event_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vega.EthereumEvent.event)
}
inline ::std::string* EthereumEvent::mutable_event() {

  // @@protoc_insertion_point(field_mutable:vega.EthereumEvent.event)
  return event_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EthereumEvent::release_event() {
  // @@protoc_insertion_point(field_release:vega.EthereumEvent.event)

  return event_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EthereumEvent::set_allocated_event(::std::string* event) {
  if (event != nullptr) {

  } else {

  }
  event_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), event);
  // @@protoc_insertion_point(field_set_allocated:vega.EthereumEvent.event)
}

// uint64 value = 3;
inline void EthereumEvent::clear_value() {
  value_ = PROTOBUF_ULONGLONG(0);
}
inline ::google::protobuf::uint64 EthereumEvent::value() const {
  // @@protoc_insertion_point(field_get:vega.EthereumEvent.value)
  return value_;
}
inline void EthereumEvent::set_value(::google::protobuf::uint64 value) {

  value_ = value;
  // @@protoc_insertion_point(field_set:vega.EthereumEvent.value)
}

// -------------------------------------------------------------------

// InstrumentMetadata

// repeated string tags = 1;
inline int InstrumentMetadata::tags_size() const {
  return tags_.size();
}
inline void InstrumentMetadata::clear_tags() {
  tags_.Clear();
}
inline const ::std::string& InstrumentMetadata::tags(int index) const {
  // @@protoc_insertion_point(field_get:vega.InstrumentMetadata.tags)
  return tags_.Get(index);
}
inline ::std::string* InstrumentMetadata::mutable_tags(int index) {
  // @@protoc_insertion_point(field_mutable:vega.InstrumentMetadata.tags)
  return tags_.Mutable(index);
}
inline void InstrumentMetadata::set_tags(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:vega.InstrumentMetadata.tags)
  tags_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void InstrumentMetadata::set_tags(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:vega.InstrumentMetadata.tags)
  tags_.Mutable(index)->assign(std::move(value));
}
#endif
inline void InstrumentMetadata::set_tags(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  tags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:vega.InstrumentMetadata.tags)
}
inline void InstrumentMetadata::set_tags(int index, const char* value, size_t size) {
  tags_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:vega.InstrumentMetadata.tags)
}
inline ::std::string* InstrumentMetadata::add_tags() {
  // @@protoc_insertion_point(field_add_mutable:vega.InstrumentMetadata.tags)
  return tags_.Add();
}
inline void InstrumentMetadata::add_tags(const ::std::string& value) {
  tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:vega.InstrumentMetadata.tags)
}
#if LANG_CXX11
inline void InstrumentMetadata::add_tags(::std::string&& value) {
  tags_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:vega.InstrumentMetadata.tags)
}
#endif
inline void InstrumentMetadata::add_tags(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:vega.InstrumentMetadata.tags)
}
inline void InstrumentMetadata::add_tags(const char* value, size_t size) {
  tags_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:vega.InstrumentMetadata.tags)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
InstrumentMetadata::tags() const {
  // @@protoc_insertion_point(field_list:vega.InstrumentMetadata.tags)
  return tags_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>*
InstrumentMetadata::mutable_tags() {
  // @@protoc_insertion_point(field_mutable_list:vega.InstrumentMetadata.tags)
  return &tags_;
}

// -------------------------------------------------------------------

// Instrument

// string id = 1;
inline void Instrument::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Instrument::id() const {
  // @@protoc_insertion_point(field_get:vega.Instrument.id)
  return id_.GetNoArena();
}
inline void Instrument::set_id(const ::std::string& value) {

  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vega.Instrument.id)
}
#if LANG_CXX11
inline void Instrument::set_id(::std::string&& value) {

  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vega.Instrument.id)
}
#endif
inline void Instrument::set_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vega.Instrument.id)
}
inline void Instrument::set_id(const char* value, size_t size) {

  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vega.Instrument.id)
}
inline ::std::string* Instrument::mutable_id() {

  // @@protoc_insertion_point(field_mutable:vega.Instrument.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Instrument::release_id() {
  // @@protoc_insertion_point(field_release:vega.Instrument.id)

  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Instrument::set_allocated_id(::std::string* id) {
  if (id != nullptr) {

  } else {

  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:vega.Instrument.id)
}

// string code = 2;
inline void Instrument::clear_code() {
  code_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Instrument::code() const {
  // @@protoc_insertion_point(field_get:vega.Instrument.code)
  return code_.GetNoArena();
}
inline void Instrument::set_code(const ::std::string& value) {

  code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vega.Instrument.code)
}
#if LANG_CXX11
inline void Instrument::set_code(::std::string&& value) {

  code_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vega.Instrument.code)
}
#endif
inline void Instrument::set_code(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vega.Instrument.code)
}
inline void Instrument::set_code(const char* value, size_t size) {

  code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vega.Instrument.code)
}
inline ::std::string* Instrument::mutable_code() {

  // @@protoc_insertion_point(field_mutable:vega.Instrument.code)
  return code_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Instrument::release_code() {
  // @@protoc_insertion_point(field_release:vega.Instrument.code)

  return code_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Instrument::set_allocated_code(::std::string* code) {
  if (code != nullptr) {

  } else {

  }
  code_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), code);
  // @@protoc_insertion_point(field_set_allocated:vega.Instrument.code)
}

// string name = 3;
inline void Instrument::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Instrument::name() const {
  // @@protoc_insertion_point(field_get:vega.Instrument.name)
  return name_.GetNoArena();
}
inline void Instrument::set_name(const ::std::string& value) {

  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vega.Instrument.name)
}
#if LANG_CXX11
inline void Instrument::set_name(::std::string&& value) {

  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vega.Instrument.name)
}
#endif
inline void Instrument::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vega.Instrument.name)
}
inline void Instrument::set_name(const char* value, size_t size) {

  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vega.Instrument.name)
}
inline ::std::string* Instrument::mutable_name() {

  // @@protoc_insertion_point(field_mutable:vega.Instrument.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Instrument::release_name() {
  // @@protoc_insertion_point(field_release:vega.Instrument.name)

  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Instrument::set_allocated_name(::std::string* name) {
  if (name != nullptr) {

  } else {

  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:vega.Instrument.name)
}

// string baseName = 4;
inline void Instrument::clear_basename() {
  basename_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Instrument::basename() const {
  // @@protoc_insertion_point(field_get:vega.Instrument.baseName)
  return basename_.GetNoArena();
}
inline void Instrument::set_basename(const ::std::string& value) {

  basename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vega.Instrument.baseName)
}
#if LANG_CXX11
inline void Instrument::set_basename(::std::string&& value) {

  basename_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vega.Instrument.baseName)
}
#endif
inline void Instrument::set_basename(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  basename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vega.Instrument.baseName)
}
inline void Instrument::set_basename(const char* value, size_t size) {

  basename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vega.Instrument.baseName)
}
inline ::std::string* Instrument::mutable_basename() {

  // @@protoc_insertion_point(field_mutable:vega.Instrument.baseName)
  return basename_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Instrument::release_basename() {
  // @@protoc_insertion_point(field_release:vega.Instrument.baseName)

  return basename_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Instrument::set_allocated_basename(::std::string* basename) {
  if (basename != nullptr) {

  } else {

  }
  basename_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), basename);
  // @@protoc_insertion_point(field_set_allocated:vega.Instrument.baseName)
}

// string quoteName = 5;
inline void Instrument::clear_quotename() {
  quotename_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Instrument::quotename() const {
  // @@protoc_insertion_point(field_get:vega.Instrument.quoteName)
  return quotename_.GetNoArena();
}
inline void Instrument::set_quotename(const ::std::string& value) {

  quotename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vega.Instrument.quoteName)
}
#if LANG_CXX11
inline void Instrument::set_quotename(::std::string&& value) {

  quotename_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vega.Instrument.quoteName)
}
#endif
inline void Instrument::set_quotename(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  quotename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vega.Instrument.quoteName)
}
inline void Instrument::set_quotename(const char* value, size_t size) {

  quotename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vega.Instrument.quoteName)
}
inline ::std::string* Instrument::mutable_quotename() {

  // @@protoc_insertion_point(field_mutable:vega.Instrument.quoteName)
  return quotename_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Instrument::release_quotename() {
  // @@protoc_insertion_point(field_release:vega.Instrument.quoteName)

  return quotename_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Instrument::set_allocated_quotename(::std::string* quotename) {
  if (quotename != nullptr) {

  } else {

  }
  quotename_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), quotename);
  // @@protoc_insertion_point(field_set_allocated:vega.Instrument.quoteName)
}

// .vega.InstrumentMetadata metadata = 6;
inline bool Instrument::has_metadata() const {
  return this != internal_default_instance() && metadata_ != nullptr;
}
inline void Instrument::clear_metadata() {
  if (GetArenaNoVirtual() == nullptr && metadata_ != nullptr) {
    delete metadata_;
  }
  metadata_ = nullptr;
}
inline const ::vega::InstrumentMetadata& Instrument::metadata() const {
  const ::vega::InstrumentMetadata* p = metadata_;
  // @@protoc_insertion_point(field_get:vega.Instrument.metadata)
  return p != nullptr ? *p : *reinterpret_cast<const ::vega::InstrumentMetadata*>(
      &::vega::_InstrumentMetadata_default_instance_);
}
inline ::vega::InstrumentMetadata* Instrument::release_metadata() {
  // @@protoc_insertion_point(field_release:vega.Instrument.metadata)

  ::vega::InstrumentMetadata* temp = metadata_;
  metadata_ = nullptr;
  return temp;
}
inline ::vega::InstrumentMetadata* Instrument::mutable_metadata() {

  if (metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::vega::InstrumentMetadata>(GetArenaNoVirtual());
    metadata_ = p;
  }
  // @@protoc_insertion_point(field_mutable:vega.Instrument.metadata)
  return metadata_;
}
inline void Instrument::set_allocated_metadata(::vega::InstrumentMetadata* metadata) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete metadata_;
  }
  if (metadata) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      metadata = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }

  } else {

  }
  metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:vega.Instrument.metadata)
}

// uint64 initialMarkPrice = 7;
inline void Instrument::clear_initialmarkprice() {
  initialmarkprice_ = PROTOBUF_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Instrument::initialmarkprice() const {
  // @@protoc_insertion_point(field_get:vega.Instrument.initialMarkPrice)
  return initialmarkprice_;
}
inline void Instrument::set_initialmarkprice(::google::protobuf::uint64 value) {

  initialmarkprice_ = value;
  // @@protoc_insertion_point(field_set:vega.Instrument.initialMarkPrice)
}

// .vega.Future future = 100;
inline bool Instrument::has_future() const {
  return product_case() == kFuture;
}
inline void Instrument::set_has_future() {
  _oneof_case_[0] = kFuture;
}
inline void Instrument::clear_future() {
  if (has_future()) {
    delete product_.future_;
    clear_has_product();
  }
}
inline ::vega::Future* Instrument::release_future() {
  // @@protoc_insertion_point(field_release:vega.Instrument.future)
  if (has_future()) {
    clear_has_product();
      ::vega::Future* temp = product_.future_;
    product_.future_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vega::Future& Instrument::future() const {
  // @@protoc_insertion_point(field_get:vega.Instrument.future)
  return has_future()
      ? *product_.future_
      : *reinterpret_cast< ::vega::Future*>(&::vega::_Future_default_instance_);
}
inline ::vega::Future* Instrument::mutable_future() {
  if (!has_future()) {
    clear_product();
    set_has_future();
    product_.future_ = CreateMaybeMessage< ::vega::Future >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:vega.Instrument.future)
  return product_.future_;
}

inline bool Instrument::has_product() const {
  return product_case() != PRODUCT_NOT_SET;
}
inline void Instrument::clear_has_product() {
  _oneof_case_[0] = PRODUCT_NOT_SET;
}
inline Instrument::ProductCase Instrument::product_case() const {
  return Instrument::ProductCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// LogNormalRiskModel

// double riskAversionParameter = 1;
inline void LogNormalRiskModel::clear_riskaversionparameter() {
  riskaversionparameter_ = 0;
}
inline double LogNormalRiskModel::riskaversionparameter() const {
  // @@protoc_insertion_point(field_get:vega.LogNormalRiskModel.riskAversionParameter)
  return riskaversionparameter_;
}
inline void LogNormalRiskModel::set_riskaversionparameter(double value) {

  riskaversionparameter_ = value;
  // @@protoc_insertion_point(field_set:vega.LogNormalRiskModel.riskAversionParameter)
}

// double tau = 2;
inline void LogNormalRiskModel::clear_tau() {
  tau_ = 0;
}
inline double LogNormalRiskModel::tau() const {
  // @@protoc_insertion_point(field_get:vega.LogNormalRiskModel.tau)
  return tau_;
}
inline void LogNormalRiskModel::set_tau(double value) {

  tau_ = value;
  // @@protoc_insertion_point(field_set:vega.LogNormalRiskModel.tau)
}

// .vega.LogNormalModelParams params = 3;
inline bool LogNormalRiskModel::has_params() const {
  return this != internal_default_instance() && params_ != nullptr;
}
inline void LogNormalRiskModel::clear_params() {
  if (GetArenaNoVirtual() == nullptr && params_ != nullptr) {
    delete params_;
  }
  params_ = nullptr;
}
inline const ::vega::LogNormalModelParams& LogNormalRiskModel::params() const {
  const ::vega::LogNormalModelParams* p = params_;
  // @@protoc_insertion_point(field_get:vega.LogNormalRiskModel.params)
  return p != nullptr ? *p : *reinterpret_cast<const ::vega::LogNormalModelParams*>(
      &::vega::_LogNormalModelParams_default_instance_);
}
inline ::vega::LogNormalModelParams* LogNormalRiskModel::release_params() {
  // @@protoc_insertion_point(field_release:vega.LogNormalRiskModel.params)

  ::vega::LogNormalModelParams* temp = params_;
  params_ = nullptr;
  return temp;
}
inline ::vega::LogNormalModelParams* LogNormalRiskModel::mutable_params() {

  if (params_ == nullptr) {
    auto* p = CreateMaybeMessage<::vega::LogNormalModelParams>(GetArenaNoVirtual());
    params_ = p;
  }
  // @@protoc_insertion_point(field_mutable:vega.LogNormalRiskModel.params)
  return params_;
}
inline void LogNormalRiskModel::set_allocated_params(::vega::LogNormalModelParams* params) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete params_;
  }
  if (params) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      params = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, params, submessage_arena);
    }

  } else {

  }
  params_ = params;
  // @@protoc_insertion_point(field_set_allocated:vega.LogNormalRiskModel.params)
}

// -------------------------------------------------------------------

// LogNormalModelParams

// double mu = 1;
inline void LogNormalModelParams::clear_mu() {
  mu_ = 0;
}
inline double LogNormalModelParams::mu() const {
  // @@protoc_insertion_point(field_get:vega.LogNormalModelParams.mu)
  return mu_;
}
inline void LogNormalModelParams::set_mu(double value) {

  mu_ = value;
  // @@protoc_insertion_point(field_set:vega.LogNormalModelParams.mu)
}

// double r = 2;
inline void LogNormalModelParams::clear_r() {
  r_ = 0;
}
inline double LogNormalModelParams::r() const {
  // @@protoc_insertion_point(field_get:vega.LogNormalModelParams.r)
  return r_;
}
inline void LogNormalModelParams::set_r(double value) {

  r_ = value;
  // @@protoc_insertion_point(field_set:vega.LogNormalModelParams.r)
}

// double sigma = 3;
inline void LogNormalModelParams::clear_sigma() {
  sigma_ = 0;
}
inline double LogNormalModelParams::sigma() const {
  // @@protoc_insertion_point(field_get:vega.LogNormalModelParams.sigma)
  return sigma_;
}
inline void LogNormalModelParams::set_sigma(double value) {

  sigma_ = value;
  // @@protoc_insertion_point(field_set:vega.LogNormalModelParams.sigma)
}

// -------------------------------------------------------------------

// SimpleRiskModel

// .vega.SimpleModelParams params = 1;
inline bool SimpleRiskModel::has_params() const {
  return this != internal_default_instance() && params_ != nullptr;
}
inline void SimpleRiskModel::clear_params() {
  if (GetArenaNoVirtual() == nullptr && params_ != nullptr) {
    delete params_;
  }
  params_ = nullptr;
}
inline const ::vega::SimpleModelParams& SimpleRiskModel::params() const {
  const ::vega::SimpleModelParams* p = params_;
  // @@protoc_insertion_point(field_get:vega.SimpleRiskModel.params)
  return p != nullptr ? *p : *reinterpret_cast<const ::vega::SimpleModelParams*>(
      &::vega::_SimpleModelParams_default_instance_);
}
inline ::vega::SimpleModelParams* SimpleRiskModel::release_params() {
  // @@protoc_insertion_point(field_release:vega.SimpleRiskModel.params)

  ::vega::SimpleModelParams* temp = params_;
  params_ = nullptr;
  return temp;
}
inline ::vega::SimpleModelParams* SimpleRiskModel::mutable_params() {

  if (params_ == nullptr) {
    auto* p = CreateMaybeMessage<::vega::SimpleModelParams>(GetArenaNoVirtual());
    params_ = p;
  }
  // @@protoc_insertion_point(field_mutable:vega.SimpleRiskModel.params)
  return params_;
}
inline void SimpleRiskModel::set_allocated_params(::vega::SimpleModelParams* params) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete params_;
  }
  if (params) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      params = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, params, submessage_arena);
    }

  } else {

  }
  params_ = params;
  // @@protoc_insertion_point(field_set_allocated:vega.SimpleRiskModel.params)
}

// -------------------------------------------------------------------

// SimpleModelParams

// double factorLong = 1;
inline void SimpleModelParams::clear_factorlong() {
  factorlong_ = 0;
}
inline double SimpleModelParams::factorlong() const {
  // @@protoc_insertion_point(field_get:vega.SimpleModelParams.factorLong)
  return factorlong_;
}
inline void SimpleModelParams::set_factorlong(double value) {

  factorlong_ = value;
  // @@protoc_insertion_point(field_set:vega.SimpleModelParams.factorLong)
}

// double factorShort = 2;
inline void SimpleModelParams::clear_factorshort() {
  factorshort_ = 0;
}
inline double SimpleModelParams::factorshort() const {
  // @@protoc_insertion_point(field_get:vega.SimpleModelParams.factorShort)
  return factorshort_;
}
inline void SimpleModelParams::set_factorshort(double value) {

  factorshort_ = value;
  // @@protoc_insertion_point(field_set:vega.SimpleModelParams.factorShort)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ExternalRiskModel

// string name = 1;
inline void ExternalRiskModel::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ExternalRiskModel::name() const {
  // @@protoc_insertion_point(field_get:vega.ExternalRiskModel.name)
  return name_.GetNoArena();
}
inline void ExternalRiskModel::set_name(const ::std::string& value) {

  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vega.ExternalRiskModel.name)
}
#if LANG_CXX11
inline void ExternalRiskModel::set_name(::std::string&& value) {

  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vega.ExternalRiskModel.name)
}
#endif
inline void ExternalRiskModel::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vega.ExternalRiskModel.name)
}
inline void ExternalRiskModel::set_name(const char* value, size_t size) {

  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vega.ExternalRiskModel.name)
}
inline ::std::string* ExternalRiskModel::mutable_name() {

  // @@protoc_insertion_point(field_mutable:vega.ExternalRiskModel.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ExternalRiskModel::release_name() {
  // @@protoc_insertion_point(field_release:vega.ExternalRiskModel.name)

  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ExternalRiskModel::set_allocated_name(::std::string* name) {
  if (name != nullptr) {

  } else {

  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:vega.ExternalRiskModel.name)
}

// string socket = 2;
inline void ExternalRiskModel::clear_socket() {
  socket_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ExternalRiskModel::socket() const {
  // @@protoc_insertion_point(field_get:vega.ExternalRiskModel.socket)
  return socket_.GetNoArena();
}
inline void ExternalRiskModel::set_socket(const ::std::string& value) {

  socket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vega.ExternalRiskModel.socket)
}
#if LANG_CXX11
inline void ExternalRiskModel::set_socket(::std::string&& value) {

  socket_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vega.ExternalRiskModel.socket)
}
#endif
inline void ExternalRiskModel::set_socket(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  socket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vega.ExternalRiskModel.socket)
}
inline void ExternalRiskModel::set_socket(const char* value, size_t size) {

  socket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vega.ExternalRiskModel.socket)
}
inline ::std::string* ExternalRiskModel::mutable_socket() {

  // @@protoc_insertion_point(field_mutable:vega.ExternalRiskModel.socket)
  return socket_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ExternalRiskModel::release_socket() {
  // @@protoc_insertion_point(field_release:vega.ExternalRiskModel.socket)

  return socket_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ExternalRiskModel::set_allocated_socket(::std::string* socket) {
  if (socket != nullptr) {

  } else {

  }
  socket_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), socket);
  // @@protoc_insertion_point(field_set_allocated:vega.ExternalRiskModel.socket)
}

// map<string, string> config = 3;
inline int ExternalRiskModel::config_size() const {
  return config_.size();
}
inline void ExternalRiskModel::clear_config() {
  config_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::std::string >&
ExternalRiskModel::config() const {
  // @@protoc_insertion_point(field_map:vega.ExternalRiskModel.config)
  return config_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::std::string >*
ExternalRiskModel::mutable_config() {
  // @@protoc_insertion_point(field_mutable_map:vega.ExternalRiskModel.config)
  return config_.MutableMap();
}

// -------------------------------------------------------------------

// ScalingFactors

// double searchLevel = 1;
inline void ScalingFactors::clear_searchlevel() {
  searchlevel_ = 0;
}
inline double ScalingFactors::searchlevel() const {
  // @@protoc_insertion_point(field_get:vega.ScalingFactors.searchLevel)
  return searchlevel_;
}
inline void ScalingFactors::set_searchlevel(double value) {

  searchlevel_ = value;
  // @@protoc_insertion_point(field_set:vega.ScalingFactors.searchLevel)
}

// double initialMargin = 2;
inline void ScalingFactors::clear_initialmargin() {
  initialmargin_ = 0;
}
inline double ScalingFactors::initialmargin() const {
  // @@protoc_insertion_point(field_get:vega.ScalingFactors.initialMargin)
  return initialmargin_;
}
inline void ScalingFactors::set_initialmargin(double value) {

  initialmargin_ = value;
  // @@protoc_insertion_point(field_set:vega.ScalingFactors.initialMargin)
}

// double collateralRelease = 3;
inline void ScalingFactors::clear_collateralrelease() {
  collateralrelease_ = 0;
}
inline double ScalingFactors::collateralrelease() const {
  // @@protoc_insertion_point(field_get:vega.ScalingFactors.collateralRelease)
  return collateralrelease_;
}
inline void ScalingFactors::set_collateralrelease(double value) {

  collateralrelease_ = value;
  // @@protoc_insertion_point(field_set:vega.ScalingFactors.collateralRelease)
}

// -------------------------------------------------------------------

// MarginCalculator

// .vega.ScalingFactors scalingFactors = 1;
inline bool MarginCalculator::has_scalingfactors() const {
  return this != internal_default_instance() && scalingfactors_ != nullptr;
}
inline void MarginCalculator::clear_scalingfactors() {
  if (GetArenaNoVirtual() == nullptr && scalingfactors_ != nullptr) {
    delete scalingfactors_;
  }
  scalingfactors_ = nullptr;
}
inline const ::vega::ScalingFactors& MarginCalculator::scalingfactors() const {
  const ::vega::ScalingFactors* p = scalingfactors_;
  // @@protoc_insertion_point(field_get:vega.MarginCalculator.scalingFactors)
  return p != nullptr ? *p : *reinterpret_cast<const ::vega::ScalingFactors*>(
      &::vega::_ScalingFactors_default_instance_);
}
inline ::vega::ScalingFactors* MarginCalculator::release_scalingfactors() {
  // @@protoc_insertion_point(field_release:vega.MarginCalculator.scalingFactors)

  ::vega::ScalingFactors* temp = scalingfactors_;
  scalingfactors_ = nullptr;
  return temp;
}
inline ::vega::ScalingFactors* MarginCalculator::mutable_scalingfactors() {

  if (scalingfactors_ == nullptr) {
    auto* p = CreateMaybeMessage<::vega::ScalingFactors>(GetArenaNoVirtual());
    scalingfactors_ = p;
  }
  // @@protoc_insertion_point(field_mutable:vega.MarginCalculator.scalingFactors)
  return scalingfactors_;
}
inline void MarginCalculator::set_allocated_scalingfactors(::vega::ScalingFactors* scalingfactors) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete scalingfactors_;
  }
  if (scalingfactors) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      scalingfactors = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, scalingfactors, submessage_arena);
    }

  } else {

  }
  scalingfactors_ = scalingfactors;
  // @@protoc_insertion_point(field_set_allocated:vega.MarginCalculator.scalingFactors)
}

// -------------------------------------------------------------------

// TradableInstrument

// .vega.Instrument instrument = 1;
inline bool TradableInstrument::has_instrument() const {
  return this != internal_default_instance() && instrument_ != nullptr;
}
inline void TradableInstrument::clear_instrument() {
  if (GetArenaNoVirtual() == nullptr && instrument_ != nullptr) {
    delete instrument_;
  }
  instrument_ = nullptr;
}
inline const ::vega::Instrument& TradableInstrument::instrument() const {
  const ::vega::Instrument* p = instrument_;
  // @@protoc_insertion_point(field_get:vega.TradableInstrument.instrument)
  return p != nullptr ? *p : *reinterpret_cast<const ::vega::Instrument*>(
      &::vega::_Instrument_default_instance_);
}
inline ::vega::Instrument* TradableInstrument::release_instrument() {
  // @@protoc_insertion_point(field_release:vega.TradableInstrument.instrument)

  ::vega::Instrument* temp = instrument_;
  instrument_ = nullptr;
  return temp;
}
inline ::vega::Instrument* TradableInstrument::mutable_instrument() {

  if (instrument_ == nullptr) {
    auto* p = CreateMaybeMessage<::vega::Instrument>(GetArenaNoVirtual());
    instrument_ = p;
  }
  // @@protoc_insertion_point(field_mutable:vega.TradableInstrument.instrument)
  return instrument_;
}
inline void TradableInstrument::set_allocated_instrument(::vega::Instrument* instrument) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete instrument_;
  }
  if (instrument) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      instrument = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, instrument, submessage_arena);
    }

  } else {

  }
  instrument_ = instrument;
  // @@protoc_insertion_point(field_set_allocated:vega.TradableInstrument.instrument)
}

// .vega.MarginCalculator marginCalculator = 2;
inline bool TradableInstrument::has_margincalculator() const {
  return this != internal_default_instance() && margincalculator_ != nullptr;
}
inline void TradableInstrument::clear_margincalculator() {
  if (GetArenaNoVirtual() == nullptr && margincalculator_ != nullptr) {
    delete margincalculator_;
  }
  margincalculator_ = nullptr;
}
inline const ::vega::MarginCalculator& TradableInstrument::margincalculator() const {
  const ::vega::MarginCalculator* p = margincalculator_;
  // @@protoc_insertion_point(field_get:vega.TradableInstrument.marginCalculator)
  return p != nullptr ? *p : *reinterpret_cast<const ::vega::MarginCalculator*>(
      &::vega::_MarginCalculator_default_instance_);
}
inline ::vega::MarginCalculator* TradableInstrument::release_margincalculator() {
  // @@protoc_insertion_point(field_release:vega.TradableInstrument.marginCalculator)

  ::vega::MarginCalculator* temp = margincalculator_;
  margincalculator_ = nullptr;
  return temp;
}
inline ::vega::MarginCalculator* TradableInstrument::mutable_margincalculator() {

  if (margincalculator_ == nullptr) {
    auto* p = CreateMaybeMessage<::vega::MarginCalculator>(GetArenaNoVirtual());
    margincalculator_ = p;
  }
  // @@protoc_insertion_point(field_mutable:vega.TradableInstrument.marginCalculator)
  return margincalculator_;
}
inline void TradableInstrument::set_allocated_margincalculator(::vega::MarginCalculator* margincalculator) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete margincalculator_;
  }
  if (margincalculator) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      margincalculator = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, margincalculator, submessage_arena);
    }

  } else {

  }
  margincalculator_ = margincalculator;
  // @@protoc_insertion_point(field_set_allocated:vega.TradableInstrument.marginCalculator)
}

// .vega.LogNormalRiskModel logNormalRiskModel = 100;
inline bool TradableInstrument::has_lognormalriskmodel() const {
  return riskModel_case() == kLogNormalRiskModel;
}
inline void TradableInstrument::set_has_lognormalriskmodel() {
  _oneof_case_[0] = kLogNormalRiskModel;
}
inline void TradableInstrument::clear_lognormalriskmodel() {
  if (has_lognormalriskmodel()) {
    delete riskModel_.lognormalriskmodel_;
    clear_has_riskModel();
  }
}
inline ::vega::LogNormalRiskModel* TradableInstrument::release_lognormalriskmodel() {
  // @@protoc_insertion_point(field_release:vega.TradableInstrument.logNormalRiskModel)
  if (has_lognormalriskmodel()) {
    clear_has_riskModel();
      ::vega::LogNormalRiskModel* temp = riskModel_.lognormalriskmodel_;
    riskModel_.lognormalriskmodel_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vega::LogNormalRiskModel& TradableInstrument::lognormalriskmodel() const {
  // @@protoc_insertion_point(field_get:vega.TradableInstrument.logNormalRiskModel)
  return has_lognormalriskmodel()
      ? *riskModel_.lognormalriskmodel_
      : *reinterpret_cast< ::vega::LogNormalRiskModel*>(&::vega::_LogNormalRiskModel_default_instance_);
}
inline ::vega::LogNormalRiskModel* TradableInstrument::mutable_lognormalriskmodel() {
  if (!has_lognormalriskmodel()) {
    clear_riskModel();
    set_has_lognormalriskmodel();
    riskModel_.lognormalriskmodel_ = CreateMaybeMessage< ::vega::LogNormalRiskModel >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:vega.TradableInstrument.logNormalRiskModel)
  return riskModel_.lognormalriskmodel_;
}

// .vega.ExternalRiskModel externalRiskModel = 101;
inline bool TradableInstrument::has_externalriskmodel() const {
  return riskModel_case() == kExternalRiskModel;
}
inline void TradableInstrument::set_has_externalriskmodel() {
  _oneof_case_[0] = kExternalRiskModel;
}
inline void TradableInstrument::clear_externalriskmodel() {
  if (has_externalriskmodel()) {
    delete riskModel_.externalriskmodel_;
    clear_has_riskModel();
  }
}
inline ::vega::ExternalRiskModel* TradableInstrument::release_externalriskmodel() {
  // @@protoc_insertion_point(field_release:vega.TradableInstrument.externalRiskModel)
  if (has_externalriskmodel()) {
    clear_has_riskModel();
      ::vega::ExternalRiskModel* temp = riskModel_.externalriskmodel_;
    riskModel_.externalriskmodel_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vega::ExternalRiskModel& TradableInstrument::externalriskmodel() const {
  // @@protoc_insertion_point(field_get:vega.TradableInstrument.externalRiskModel)
  return has_externalriskmodel()
      ? *riskModel_.externalriskmodel_
      : *reinterpret_cast< ::vega::ExternalRiskModel*>(&::vega::_ExternalRiskModel_default_instance_);
}
inline ::vega::ExternalRiskModel* TradableInstrument::mutable_externalriskmodel() {
  if (!has_externalriskmodel()) {
    clear_riskModel();
    set_has_externalriskmodel();
    riskModel_.externalriskmodel_ = CreateMaybeMessage< ::vega::ExternalRiskModel >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:vega.TradableInstrument.externalRiskModel)
  return riskModel_.externalriskmodel_;
}

// .vega.SimpleRiskModel simpleRiskModel = 102;
inline bool TradableInstrument::has_simpleriskmodel() const {
  return riskModel_case() == kSimpleRiskModel;
}
inline void TradableInstrument::set_has_simpleriskmodel() {
  _oneof_case_[0] = kSimpleRiskModel;
}
inline void TradableInstrument::clear_simpleriskmodel() {
  if (has_simpleriskmodel()) {
    delete riskModel_.simpleriskmodel_;
    clear_has_riskModel();
  }
}
inline ::vega::SimpleRiskModel* TradableInstrument::release_simpleriskmodel() {
  // @@protoc_insertion_point(field_release:vega.TradableInstrument.simpleRiskModel)
  if (has_simpleriskmodel()) {
    clear_has_riskModel();
      ::vega::SimpleRiskModel* temp = riskModel_.simpleriskmodel_;
    riskModel_.simpleriskmodel_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vega::SimpleRiskModel& TradableInstrument::simpleriskmodel() const {
  // @@protoc_insertion_point(field_get:vega.TradableInstrument.simpleRiskModel)
  return has_simpleriskmodel()
      ? *riskModel_.simpleriskmodel_
      : *reinterpret_cast< ::vega::SimpleRiskModel*>(&::vega::_SimpleRiskModel_default_instance_);
}
inline ::vega::SimpleRiskModel* TradableInstrument::mutable_simpleriskmodel() {
  if (!has_simpleriskmodel()) {
    clear_riskModel();
    set_has_simpleriskmodel();
    riskModel_.simpleriskmodel_ = CreateMaybeMessage< ::vega::SimpleRiskModel >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:vega.TradableInstrument.simpleRiskModel)
  return riskModel_.simpleriskmodel_;
}

inline bool TradableInstrument::has_riskModel() const {
  return riskModel_case() != RISKMODEL_NOT_SET;
}
inline void TradableInstrument::clear_has_riskModel() {
  _oneof_case_[0] = RISKMODEL_NOT_SET;
}
inline TradableInstrument::RiskModelCase TradableInstrument::riskModel_case() const {
  return TradableInstrument::RiskModelCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Market

// string id = 1;
inline void Market::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Market::id() const {
  // @@protoc_insertion_point(field_get:vega.Market.id)
  return id_.GetNoArena();
}
inline void Market::set_id(const ::std::string& value) {

  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vega.Market.id)
}
#if LANG_CXX11
inline void Market::set_id(::std::string&& value) {

  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vega.Market.id)
}
#endif
inline void Market::set_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vega.Market.id)
}
inline void Market::set_id(const char* value, size_t size) {

  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vega.Market.id)
}
inline ::std::string* Market::mutable_id() {

  // @@protoc_insertion_point(field_mutable:vega.Market.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Market::release_id() {
  // @@protoc_insertion_point(field_release:vega.Market.id)

  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Market::set_allocated_id(::std::string* id) {
  if (id != nullptr) {

  } else {

  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:vega.Market.id)
}

// .vega.TradableInstrument tradableInstrument = 2;
inline bool Market::has_tradableinstrument() const {
  return this != internal_default_instance() && tradableinstrument_ != nullptr;
}
inline void Market::clear_tradableinstrument() {
  if (GetArenaNoVirtual() == nullptr && tradableinstrument_ != nullptr) {
    delete tradableinstrument_;
  }
  tradableinstrument_ = nullptr;
}
inline const ::vega::TradableInstrument& Market::tradableinstrument() const {
  const ::vega::TradableInstrument* p = tradableinstrument_;
  // @@protoc_insertion_point(field_get:vega.Market.tradableInstrument)
  return p != nullptr ? *p : *reinterpret_cast<const ::vega::TradableInstrument*>(
      &::vega::_TradableInstrument_default_instance_);
}
inline ::vega::TradableInstrument* Market::release_tradableinstrument() {
  // @@protoc_insertion_point(field_release:vega.Market.tradableInstrument)

  ::vega::TradableInstrument* temp = tradableinstrument_;
  tradableinstrument_ = nullptr;
  return temp;
}
inline ::vega::TradableInstrument* Market::mutable_tradableinstrument() {

  if (tradableinstrument_ == nullptr) {
    auto* p = CreateMaybeMessage<::vega::TradableInstrument>(GetArenaNoVirtual());
    tradableinstrument_ = p;
  }
  // @@protoc_insertion_point(field_mutable:vega.Market.tradableInstrument)
  return tradableinstrument_;
}
inline void Market::set_allocated_tradableinstrument(::vega::TradableInstrument* tradableinstrument) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete tradableinstrument_;
  }
  if (tradableinstrument) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      tradableinstrument = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, tradableinstrument, submessage_arena);
    }

  } else {

  }
  tradableinstrument_ = tradableinstrument;
  // @@protoc_insertion_point(field_set_allocated:vega.Market.tradableInstrument)
}

// uint64 decimalPlaces = 3;
inline void Market::clear_decimalplaces() {
  decimalplaces_ = PROTOBUF_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Market::decimalplaces() const {
  // @@protoc_insertion_point(field_get:vega.Market.decimalPlaces)
  return decimalplaces_;
}
inline void Market::set_decimalplaces(::google::protobuf::uint64 value) {

  decimalplaces_ = value;
  // @@protoc_insertion_point(field_set:vega.Market.decimalPlaces)
}

// .vega.ContinuousTrading continuous = 100;
inline bool Market::has_continuous() const {
  return tradingMode_case() == kContinuous;
}
inline void Market::set_has_continuous() {
  _oneof_case_[0] = kContinuous;
}
inline void Market::clear_continuous() {
  if (has_continuous()) {
    delete tradingMode_.continuous_;
    clear_has_tradingMode();
  }
}
inline ::vega::ContinuousTrading* Market::release_continuous() {
  // @@protoc_insertion_point(field_release:vega.Market.continuous)
  if (has_continuous()) {
    clear_has_tradingMode();
      ::vega::ContinuousTrading* temp = tradingMode_.continuous_;
    tradingMode_.continuous_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vega::ContinuousTrading& Market::continuous() const {
  // @@protoc_insertion_point(field_get:vega.Market.continuous)
  return has_continuous()
      ? *tradingMode_.continuous_
      : *reinterpret_cast< ::vega::ContinuousTrading*>(&::vega::_ContinuousTrading_default_instance_);
}
inline ::vega::ContinuousTrading* Market::mutable_continuous() {
  if (!has_continuous()) {
    clear_tradingMode();
    set_has_continuous();
    tradingMode_.continuous_ = CreateMaybeMessage< ::vega::ContinuousTrading >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:vega.Market.continuous)
  return tradingMode_.continuous_;
}

// .vega.DiscreteTrading discrete = 101;
inline bool Market::has_discrete() const {
  return tradingMode_case() == kDiscrete;
}
inline void Market::set_has_discrete() {
  _oneof_case_[0] = kDiscrete;
}
inline void Market::clear_discrete() {
  if (has_discrete()) {
    delete tradingMode_.discrete_;
    clear_has_tradingMode();
  }
}
inline ::vega::DiscreteTrading* Market::release_discrete() {
  // @@protoc_insertion_point(field_release:vega.Market.discrete)
  if (has_discrete()) {
    clear_has_tradingMode();
      ::vega::DiscreteTrading* temp = tradingMode_.discrete_;
    tradingMode_.discrete_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vega::DiscreteTrading& Market::discrete() const {
  // @@protoc_insertion_point(field_get:vega.Market.discrete)
  return has_discrete()
      ? *tradingMode_.discrete_
      : *reinterpret_cast< ::vega::DiscreteTrading*>(&::vega::_DiscreteTrading_default_instance_);
}
inline ::vega::DiscreteTrading* Market::mutable_discrete() {
  if (!has_discrete()) {
    clear_tradingMode();
    set_has_discrete();
    tradingMode_.discrete_ = CreateMaybeMessage< ::vega::DiscreteTrading >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:vega.Market.discrete)
  return tradingMode_.discrete_;
}

inline bool Market::has_tradingMode() const {
  return tradingMode_case() != TRADINGMODE_NOT_SET;
}
inline void Market::clear_has_tradingMode() {
  _oneof_case_[0] = TRADINGMODE_NOT_SET;
}
inline Market::TradingModeCase Market::tradingMode_case() const {
  return Market::TradingModeCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace vega

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // PROTOBUF_INCLUDED_proto_2fmarkets_2eproto

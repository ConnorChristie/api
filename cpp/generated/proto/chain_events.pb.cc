// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: proto/chain_events.proto

#include "proto/chain_events.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

extern PROTOBUF_INTERNAL_EXPORT_proto_2fchain_5fevents_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_BTCDeposit_proto_2fchain_5fevents_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_proto_2fchain_5fevents_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_BTCWithdrawal_proto_2fchain_5fevents_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_proto_2fchain_5fevents_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_BitcoinAddress_proto_2fchain_5fevents_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_proto_2fchain_5fevents_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_BuiltinAssetDeposit_proto_2fchain_5fevents_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_proto_2fchain_5fevents_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_BuiltinAssetWithdrawal_proto_2fchain_5fevents_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_proto_2fchain_5fevents_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_ERC20AssetDelist_proto_2fchain_5fevents_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_proto_2fchain_5fevents_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_ERC20AssetList_proto_2fchain_5fevents_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_proto_2fchain_5fevents_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_ERC20Deposit_proto_2fchain_5fevents_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_proto_2fchain_5fevents_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_ERC20Withdrawal_proto_2fchain_5fevents_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_proto_2fchain_5fevents_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_EthereumAddress_proto_2fchain_5fevents_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_proto_2fchain_5fevents_2eproto ::google::protobuf::internal::SCCInfo<1> scc_info_AddValidator_proto_2fchain_5fevents_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_proto_2fchain_5fevents_2eproto ::google::protobuf::internal::SCCInfo<1> scc_info_RemoveValidator_proto_2fchain_5fevents_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_proto_2fchain_5fevents_2eproto ::google::protobuf::internal::SCCInfo<2> scc_info_BTCEvent_proto_2fchain_5fevents_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_proto_2fchain_5fevents_2eproto ::google::protobuf::internal::SCCInfo<2> scc_info_BuiltinAssetEvent_proto_2fchain_5fevents_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_proto_2fchain_5fevents_2eproto ::google::protobuf::internal::SCCInfo<2> scc_info_Identifier_proto_2fchain_5fevents_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_proto_2fchain_5fevents_2eproto ::google::protobuf::internal::SCCInfo<2> scc_info_ValidatorEvent_proto_2fchain_5fevents_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_proto_2fchain_5fevents_2eproto ::google::protobuf::internal::SCCInfo<4> scc_info_ERC20Event_proto_2fchain_5fevents_2eproto;
namespace vega {
class BuiltinAssetDepositDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<BuiltinAssetDeposit> _instance;
} _BuiltinAssetDeposit_default_instance_;
class BuiltinAssetWithdrawalDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<BuiltinAssetWithdrawal> _instance;
} _BuiltinAssetWithdrawal_default_instance_;
class BuiltinAssetEventDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<BuiltinAssetEvent> _instance;
  const ::vega::BuiltinAssetDeposit* deposit_;
  const ::vega::BuiltinAssetWithdrawal* withdrawal_;
} _BuiltinAssetEvent_default_instance_;
class ERC20AssetListDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<ERC20AssetList> _instance;
} _ERC20AssetList_default_instance_;
class ERC20AssetDelistDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<ERC20AssetDelist> _instance;
} _ERC20AssetDelist_default_instance_;
class ERC20DepositDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<ERC20Deposit> _instance;
} _ERC20Deposit_default_instance_;
class ERC20WithdrawalDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<ERC20Withdrawal> _instance;
} _ERC20Withdrawal_default_instance_;
class ERC20EventDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<ERC20Event> _instance;
  const ::vega::ERC20AssetList* assetlist_;
  const ::vega::ERC20AssetDelist* assetdelist_;
  const ::vega::ERC20Deposit* deposit_;
  const ::vega::ERC20Withdrawal* withdrawal_;
} _ERC20Event_default_instance_;
class BTCDepositDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<BTCDeposit> _instance;
} _BTCDeposit_default_instance_;
class BTCWithdrawalDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<BTCWithdrawal> _instance;
} _BTCWithdrawal_default_instance_;
class BTCEventDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<BTCEvent> _instance;
  const ::vega::BTCDeposit* deposit_;
  const ::vega::BTCWithdrawal* withdrawal_;
} _BTCEvent_default_instance_;
class EthereumAddressDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<EthereumAddress> _instance;
} _EthereumAddress_default_instance_;
class BitcoinAddressDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<BitcoinAddress> _instance;
} _BitcoinAddress_default_instance_;
class IdentifierDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Identifier> _instance;
  const ::vega::EthereumAddress* ethereumaddress_;
  const ::vega::BitcoinAddress* bitcoinaddress_;
} _Identifier_default_instance_;
class AddValidatorDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<AddValidator> _instance;
} _AddValidator_default_instance_;
class RemoveValidatorDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<RemoveValidator> _instance;
} _RemoveValidator_default_instance_;
class ValidatorEventDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<ValidatorEvent> _instance;
  const ::vega::AddValidator* add_;
  const ::vega::RemoveValidator* rm_;
} _ValidatorEvent_default_instance_;
class ChainEventDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<ChainEvent> _instance;
  const ::vega::BuiltinAssetEvent* builtin_;
  const ::vega::ERC20Event* erc20_;
  const ::vega::BTCEvent* btc_;
  const ::vega::ValidatorEvent* validator_;
} _ChainEvent_default_instance_;
}  // namespace vega
static void InitDefaultsBuiltinAssetDeposit_proto_2fchain_5fevents_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::vega::_BuiltinAssetDeposit_default_instance_;
    new (ptr) ::vega::BuiltinAssetDeposit();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::vega::BuiltinAssetDeposit::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_BuiltinAssetDeposit_proto_2fchain_5fevents_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsBuiltinAssetDeposit_proto_2fchain_5fevents_2eproto}, {}};

static void InitDefaultsBuiltinAssetWithdrawal_proto_2fchain_5fevents_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::vega::_BuiltinAssetWithdrawal_default_instance_;
    new (ptr) ::vega::BuiltinAssetWithdrawal();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::vega::BuiltinAssetWithdrawal::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_BuiltinAssetWithdrawal_proto_2fchain_5fevents_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsBuiltinAssetWithdrawal_proto_2fchain_5fevents_2eproto}, {}};

static void InitDefaultsBuiltinAssetEvent_proto_2fchain_5fevents_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::vega::_BuiltinAssetEvent_default_instance_;
    new (ptr) ::vega::BuiltinAssetEvent();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::vega::BuiltinAssetEvent::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<2> scc_info_BuiltinAssetEvent_proto_2fchain_5fevents_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 2, InitDefaultsBuiltinAssetEvent_proto_2fchain_5fevents_2eproto}, {
      &scc_info_BuiltinAssetDeposit_proto_2fchain_5fevents_2eproto.base,
      &scc_info_BuiltinAssetWithdrawal_proto_2fchain_5fevents_2eproto.base,}};

static void InitDefaultsERC20AssetList_proto_2fchain_5fevents_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::vega::_ERC20AssetList_default_instance_;
    new (ptr) ::vega::ERC20AssetList();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::vega::ERC20AssetList::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_ERC20AssetList_proto_2fchain_5fevents_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsERC20AssetList_proto_2fchain_5fevents_2eproto}, {}};

static void InitDefaultsERC20AssetDelist_proto_2fchain_5fevents_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::vega::_ERC20AssetDelist_default_instance_;
    new (ptr) ::vega::ERC20AssetDelist();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::vega::ERC20AssetDelist::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_ERC20AssetDelist_proto_2fchain_5fevents_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsERC20AssetDelist_proto_2fchain_5fevents_2eproto}, {}};

static void InitDefaultsERC20Deposit_proto_2fchain_5fevents_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::vega::_ERC20Deposit_default_instance_;
    new (ptr) ::vega::ERC20Deposit();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::vega::ERC20Deposit::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_ERC20Deposit_proto_2fchain_5fevents_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsERC20Deposit_proto_2fchain_5fevents_2eproto}, {}};

static void InitDefaultsERC20Withdrawal_proto_2fchain_5fevents_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::vega::_ERC20Withdrawal_default_instance_;
    new (ptr) ::vega::ERC20Withdrawal();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::vega::ERC20Withdrawal::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_ERC20Withdrawal_proto_2fchain_5fevents_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsERC20Withdrawal_proto_2fchain_5fevents_2eproto}, {}};

static void InitDefaultsERC20Event_proto_2fchain_5fevents_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::vega::_ERC20Event_default_instance_;
    new (ptr) ::vega::ERC20Event();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::vega::ERC20Event::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<4> scc_info_ERC20Event_proto_2fchain_5fevents_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 4, InitDefaultsERC20Event_proto_2fchain_5fevents_2eproto}, {
      &scc_info_ERC20AssetList_proto_2fchain_5fevents_2eproto.base,
      &scc_info_ERC20AssetDelist_proto_2fchain_5fevents_2eproto.base,
      &scc_info_ERC20Deposit_proto_2fchain_5fevents_2eproto.base,
      &scc_info_ERC20Withdrawal_proto_2fchain_5fevents_2eproto.base,}};

static void InitDefaultsBTCDeposit_proto_2fchain_5fevents_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::vega::_BTCDeposit_default_instance_;
    new (ptr) ::vega::BTCDeposit();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::vega::BTCDeposit::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_BTCDeposit_proto_2fchain_5fevents_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsBTCDeposit_proto_2fchain_5fevents_2eproto}, {}};

static void InitDefaultsBTCWithdrawal_proto_2fchain_5fevents_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::vega::_BTCWithdrawal_default_instance_;
    new (ptr) ::vega::BTCWithdrawal();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::vega::BTCWithdrawal::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_BTCWithdrawal_proto_2fchain_5fevents_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsBTCWithdrawal_proto_2fchain_5fevents_2eproto}, {}};

static void InitDefaultsBTCEvent_proto_2fchain_5fevents_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::vega::_BTCEvent_default_instance_;
    new (ptr) ::vega::BTCEvent();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::vega::BTCEvent::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<2> scc_info_BTCEvent_proto_2fchain_5fevents_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 2, InitDefaultsBTCEvent_proto_2fchain_5fevents_2eproto}, {
      &scc_info_BTCDeposit_proto_2fchain_5fevents_2eproto.base,
      &scc_info_BTCWithdrawal_proto_2fchain_5fevents_2eproto.base,}};

static void InitDefaultsEthereumAddress_proto_2fchain_5fevents_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::vega::_EthereumAddress_default_instance_;
    new (ptr) ::vega::EthereumAddress();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::vega::EthereumAddress::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_EthereumAddress_proto_2fchain_5fevents_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsEthereumAddress_proto_2fchain_5fevents_2eproto}, {}};

static void InitDefaultsBitcoinAddress_proto_2fchain_5fevents_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::vega::_BitcoinAddress_default_instance_;
    new (ptr) ::vega::BitcoinAddress();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::vega::BitcoinAddress::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_BitcoinAddress_proto_2fchain_5fevents_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsBitcoinAddress_proto_2fchain_5fevents_2eproto}, {}};

static void InitDefaultsIdentifier_proto_2fchain_5fevents_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::vega::_Identifier_default_instance_;
    new (ptr) ::vega::Identifier();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::vega::Identifier::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<2> scc_info_Identifier_proto_2fchain_5fevents_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 2, InitDefaultsIdentifier_proto_2fchain_5fevents_2eproto}, {
      &scc_info_EthereumAddress_proto_2fchain_5fevents_2eproto.base,
      &scc_info_BitcoinAddress_proto_2fchain_5fevents_2eproto.base,}};

static void InitDefaultsAddValidator_proto_2fchain_5fevents_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::vega::_AddValidator_default_instance_;
    new (ptr) ::vega::AddValidator();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::vega::AddValidator::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_AddValidator_proto_2fchain_5fevents_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsAddValidator_proto_2fchain_5fevents_2eproto}, {
      &scc_info_Identifier_proto_2fchain_5fevents_2eproto.base,}};

static void InitDefaultsRemoveValidator_proto_2fchain_5fevents_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::vega::_RemoveValidator_default_instance_;
    new (ptr) ::vega::RemoveValidator();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::vega::RemoveValidator::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_RemoveValidator_proto_2fchain_5fevents_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsRemoveValidator_proto_2fchain_5fevents_2eproto}, {
      &scc_info_Identifier_proto_2fchain_5fevents_2eproto.base,}};

static void InitDefaultsValidatorEvent_proto_2fchain_5fevents_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::vega::_ValidatorEvent_default_instance_;
    new (ptr) ::vega::ValidatorEvent();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::vega::ValidatorEvent::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<2> scc_info_ValidatorEvent_proto_2fchain_5fevents_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 2, InitDefaultsValidatorEvent_proto_2fchain_5fevents_2eproto}, {
      &scc_info_AddValidator_proto_2fchain_5fevents_2eproto.base,
      &scc_info_RemoveValidator_proto_2fchain_5fevents_2eproto.base,}};

static void InitDefaultsChainEvent_proto_2fchain_5fevents_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::vega::_ChainEvent_default_instance_;
    new (ptr) ::vega::ChainEvent();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::vega::ChainEvent::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<4> scc_info_ChainEvent_proto_2fchain_5fevents_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 4, InitDefaultsChainEvent_proto_2fchain_5fevents_2eproto}, {
      &scc_info_BuiltinAssetEvent_proto_2fchain_5fevents_2eproto.base,
      &scc_info_ERC20Event_proto_2fchain_5fevents_2eproto.base,
      &scc_info_BTCEvent_proto_2fchain_5fevents_2eproto.base,
      &scc_info_ValidatorEvent_proto_2fchain_5fevents_2eproto.base,}};

void InitDefaults_proto_2fchain_5fevents_2eproto() {
  ::google::protobuf::internal::InitSCC(&scc_info_BuiltinAssetDeposit_proto_2fchain_5fevents_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_BuiltinAssetWithdrawal_proto_2fchain_5fevents_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_BuiltinAssetEvent_proto_2fchain_5fevents_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_ERC20AssetList_proto_2fchain_5fevents_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_ERC20AssetDelist_proto_2fchain_5fevents_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_ERC20Deposit_proto_2fchain_5fevents_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_ERC20Withdrawal_proto_2fchain_5fevents_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_ERC20Event_proto_2fchain_5fevents_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_BTCDeposit_proto_2fchain_5fevents_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_BTCWithdrawal_proto_2fchain_5fevents_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_BTCEvent_proto_2fchain_5fevents_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_EthereumAddress_proto_2fchain_5fevents_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_BitcoinAddress_proto_2fchain_5fevents_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_Identifier_proto_2fchain_5fevents_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_AddValidator_proto_2fchain_5fevents_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_RemoveValidator_proto_2fchain_5fevents_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_ValidatorEvent_proto_2fchain_5fevents_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_ChainEvent_proto_2fchain_5fevents_2eproto.base);
}

::google::protobuf::Metadata file_level_metadata_proto_2fchain_5fevents_2eproto[18];
constexpr ::google::protobuf::EnumDescriptor const** file_level_enum_descriptors_proto_2fchain_5fevents_2eproto = nullptr;
constexpr ::google::protobuf::ServiceDescriptor const** file_level_service_descriptors_proto_2fchain_5fevents_2eproto = nullptr;

const ::google::protobuf::uint32 TableStruct_proto_2fchain_5fevents_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vega::BuiltinAssetDeposit, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::vega::BuiltinAssetDeposit, vegaassetid_),
  PROTOBUF_FIELD_OFFSET(::vega::BuiltinAssetDeposit, partyid_),
  PROTOBUF_FIELD_OFFSET(::vega::BuiltinAssetDeposit, amount_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vega::BuiltinAssetWithdrawal, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::vega::BuiltinAssetWithdrawal, vegaassetid_),
  PROTOBUF_FIELD_OFFSET(::vega::BuiltinAssetWithdrawal, partyid_),
  PROTOBUF_FIELD_OFFSET(::vega::BuiltinAssetWithdrawal, amount_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vega::BuiltinAssetEvent, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::vega::BuiltinAssetEvent, _oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  offsetof(::vega::BuiltinAssetEventDefaultTypeInternal, deposit_),
  offsetof(::vega::BuiltinAssetEventDefaultTypeInternal, withdrawal_),
  PROTOBUF_FIELD_OFFSET(::vega::BuiltinAssetEvent, action_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vega::ERC20AssetList, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::vega::ERC20AssetList, vegaassetid_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vega::ERC20AssetDelist, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::vega::ERC20AssetDelist, vegaassetid_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vega::ERC20Deposit, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::vega::ERC20Deposit, vegaassetid_),
  PROTOBUF_FIELD_OFFSET(::vega::ERC20Deposit, sourceethereumaddress_),
  PROTOBUF_FIELD_OFFSET(::vega::ERC20Deposit, targetpartyid_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vega::ERC20Withdrawal, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::vega::ERC20Withdrawal, vegaassetid_),
  PROTOBUF_FIELD_OFFSET(::vega::ERC20Withdrawal, sourcepartyid_),
  PROTOBUF_FIELD_OFFSET(::vega::ERC20Withdrawal, targetethereumaddress_),
  PROTOBUF_FIELD_OFFSET(::vega::ERC20Withdrawal, referencenonce_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vega::ERC20Event, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::vega::ERC20Event, _oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::vega::ERC20Event, index_),
  PROTOBUF_FIELD_OFFSET(::vega::ERC20Event, block_),
  offsetof(::vega::ERC20EventDefaultTypeInternal, assetlist_),
  offsetof(::vega::ERC20EventDefaultTypeInternal, assetdelist_),
  offsetof(::vega::ERC20EventDefaultTypeInternal, deposit_),
  offsetof(::vega::ERC20EventDefaultTypeInternal, withdrawal_),
  PROTOBUF_FIELD_OFFSET(::vega::ERC20Event, action_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vega::BTCDeposit, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::vega::BTCDeposit, vegaassetid_),
  PROTOBUF_FIELD_OFFSET(::vega::BTCDeposit, sourcebtcaddress_),
  PROTOBUF_FIELD_OFFSET(::vega::BTCDeposit, targetpartyid_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vega::BTCWithdrawal, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::vega::BTCWithdrawal, vegaassetid_),
  PROTOBUF_FIELD_OFFSET(::vega::BTCWithdrawal, sourcepartyid_),
  PROTOBUF_FIELD_OFFSET(::vega::BTCWithdrawal, targetbtcaddress_),
  PROTOBUF_FIELD_OFFSET(::vega::BTCWithdrawal, referencenonce_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vega::BTCEvent, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::vega::BTCEvent, _oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::vega::BTCEvent, index_),
  PROTOBUF_FIELD_OFFSET(::vega::BTCEvent, block_),
  offsetof(::vega::BTCEventDefaultTypeInternal, deposit_),
  offsetof(::vega::BTCEventDefaultTypeInternal, withdrawal_),
  PROTOBUF_FIELD_OFFSET(::vega::BTCEvent, action_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vega::EthereumAddress, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::vega::EthereumAddress, address_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vega::BitcoinAddress, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::vega::BitcoinAddress, address_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vega::Identifier, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::vega::Identifier, _oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  offsetof(::vega::IdentifierDefaultTypeInternal, ethereumaddress_),
  offsetof(::vega::IdentifierDefaultTypeInternal, bitcoinaddress_),
  PROTOBUF_FIELD_OFFSET(::vega::Identifier, identifier_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vega::AddValidator, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::vega::AddValidator, id_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vega::RemoveValidator, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::vega::RemoveValidator, id_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vega::ValidatorEvent, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::vega::ValidatorEvent, _oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::vega::ValidatorEvent, sourceid_),
  offsetof(::vega::ValidatorEventDefaultTypeInternal, add_),
  offsetof(::vega::ValidatorEventDefaultTypeInternal, rm_),
  PROTOBUF_FIELD_OFFSET(::vega::ValidatorEvent, action_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vega::ChainEvent, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::vega::ChainEvent, _oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::vega::ChainEvent, txid_),
  PROTOBUF_FIELD_OFFSET(::vega::ChainEvent, nonce_),
  offsetof(::vega::ChainEventDefaultTypeInternal, builtin_),
  offsetof(::vega::ChainEventDefaultTypeInternal, erc20_),
  offsetof(::vega::ChainEventDefaultTypeInternal, btc_),
  offsetof(::vega::ChainEventDefaultTypeInternal, validator_),
  PROTOBUF_FIELD_OFFSET(::vega::ChainEvent, event_),
};
static const ::google::protobuf::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, sizeof(::vega::BuiltinAssetDeposit)},
  { 8, -1, sizeof(::vega::BuiltinAssetWithdrawal)},
  { 16, -1, sizeof(::vega::BuiltinAssetEvent)},
  { 24, -1, sizeof(::vega::ERC20AssetList)},
  { 30, -1, sizeof(::vega::ERC20AssetDelist)},
  { 36, -1, sizeof(::vega::ERC20Deposit)},
  { 44, -1, sizeof(::vega::ERC20Withdrawal)},
  { 53, -1, sizeof(::vega::ERC20Event)},
  { 65, -1, sizeof(::vega::BTCDeposit)},
  { 73, -1, sizeof(::vega::BTCWithdrawal)},
  { 82, -1, sizeof(::vega::BTCEvent)},
  { 92, -1, sizeof(::vega::EthereumAddress)},
  { 98, -1, sizeof(::vega::BitcoinAddress)},
  { 104, -1, sizeof(::vega::Identifier)},
  { 112, -1, sizeof(::vega::AddValidator)},
  { 118, -1, sizeof(::vega::RemoveValidator)},
  { 124, -1, sizeof(::vega::ValidatorEvent)},
  { 133, -1, sizeof(::vega::ChainEvent)},
};

static ::google::protobuf::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::google::protobuf::Message*>(&::vega::_BuiltinAssetDeposit_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::vega::_BuiltinAssetWithdrawal_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::vega::_BuiltinAssetEvent_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::vega::_ERC20AssetList_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::vega::_ERC20AssetDelist_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::vega::_ERC20Deposit_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::vega::_ERC20Withdrawal_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::vega::_ERC20Event_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::vega::_BTCDeposit_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::vega::_BTCWithdrawal_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::vega::_BTCEvent_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::vega::_EthereumAddress_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::vega::_BitcoinAddress_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::vega::_Identifier_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::vega::_AddValidator_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::vega::_RemoveValidator_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::vega::_ValidatorEvent_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::vega::_ChainEvent_default_instance_),
};

::google::protobuf::internal::AssignDescriptorsTable assign_descriptors_table_proto_2fchain_5fevents_2eproto = {
  {}, AddDescriptors_proto_2fchain_5fevents_2eproto, "proto/chain_events.proto", schemas,
  file_default_instances, TableStruct_proto_2fchain_5fevents_2eproto::offsets,
  file_level_metadata_proto_2fchain_5fevents_2eproto, 18, file_level_enum_descriptors_proto_2fchain_5fevents_2eproto, file_level_service_descriptors_proto_2fchain_5fevents_2eproto,
};

const char descriptor_table_protodef_proto_2fchain_5fevents_2eproto[] =
  "\n\030proto/chain_events.proto\022\004vega\"K\n\023Buil"
  "tinAssetDeposit\022\023\n\013vegaAssetID\030\001 \001(\t\022\017\n\007"
  "partyID\030\002 \001(\t\022\016\n\006amount\030\003 \001(\004\"N\n\026Builtin"
  "AssetWithdrawal\022\023\n\013vegaAssetID\030\001 \001(\t\022\017\n\007"
  "partyID\030\002 \001(\t\022\016\n\006amount\030\003 \001(\004\"\201\001\n\021Builti"
  "nAssetEvent\022-\n\007deposit\030\351\007 \001(\0132\031.vega.Bui"
  "ltinAssetDepositH\000\0223\n\nwithdrawal\030\352\007 \001(\0132"
  "\034.vega.BuiltinAssetWithdrawalH\000B\010\n\006actio"
  "n\"%\n\016ERC20AssetList\022\023\n\013vegaAssetID\030\001 \001(\t"
  "\"\'\n\020ERC20AssetDelist\022\023\n\013vegaAssetID\030\001 \001("
  "\t\"Y\n\014ERC20Deposit\022\023\n\013vegaAssetID\030\001 \001(\t\022\035"
  "\n\025sourceEthereumAddress\030\002 \001(\t\022\025\n\rtargetP"
  "artyID\030\003 \001(\t\"t\n\017ERC20Withdrawal\022\023\n\013vegaA"
  "ssetID\030\001 \001(\t\022\025\n\rsourcePartyId\030\002 \001(\t\022\035\n\025t"
  "argetEthereumAddress\030\003 \001(\t\022\026\n\016referenceN"
  "once\030\004 \001(\t\"\346\001\n\nERC20Event\022\r\n\005index\030\001 \001(\004"
  "\022\r\n\005block\030\002 \001(\004\022*\n\tassetList\030\351\007 \001(\0132\024.ve"
  "ga.ERC20AssetListH\000\022.\n\013assetDelist\030\352\007 \001("
  "\0132\026.vega.ERC20AssetDelistH\000\022&\n\007deposit\030\353"
  "\007 \001(\0132\022.vega.ERC20DepositH\000\022,\n\nwithdrawa"
  "l\030\354\007 \001(\0132\025.vega.ERC20WithdrawalH\000B\010\n\006act"
  "ion\"R\n\nBTCDeposit\022\023\n\013vegaAssetID\030\001 \001(\t\022\030"
  "\n\020sourceBTCAddress\030\002 \001(\t\022\025\n\rtargetPartyI"
  "d\030\003 \001(\t\"m\n\rBTCWithdrawal\022\023\n\013vegaAssetID\030"
  "\001 \001(\t\022\025\n\rsourcePartyId\030\002 \001(\t\022\030\n\020targetBT"
  "CAddress\030\003 \001(\t\022\026\n\016referenceNonce\030\004 \001(\t\"\204"
  "\001\n\010BTCEvent\022\r\n\005index\030\001 \001(\004\022\r\n\005block\030\002 \001("
  "\004\022$\n\007deposit\030\351\007 \001(\0132\020.vega.BTCDepositH\000\022"
  "*\n\nwithdrawal\030\352\007 \001(\0132\023.vega.BTCWithdrawa"
  "lH\000B\010\n\006action\"\"\n\017EthereumAddress\022\017\n\007addr"
  "ess\030\001 \001(\t\"!\n\016BitcoinAddress\022\017\n\007address\030\001"
  " \001(\t\"|\n\nIdentifier\0220\n\017ethereumAddress\030\001 "
  "\001(\0132\025.vega.EthereumAddressH\000\022.\n\016bitcoinA"
  "ddress\030\002 \001(\0132\024.vega.BitcoinAddressH\000B\014\n\n"
  "identifier\",\n\014AddValidator\022\034\n\002id\030\001 \001(\0132\020"
  ".vega.Identifier\"/\n\017RemoveValidator\022\034\n\002i"
  "d\030\001 \001(\0132\020.vega.Identifier\"v\n\016ValidatorEv"
  "ent\022\020\n\010sourceID\030\001 \001(\t\022\"\n\003add\030\351\007 \001(\0132\022.ve"
  "ga.AddValidatorH\000\022$\n\002rm\030\352\007 \001(\0132\025.vega.Re"
  "moveValidatorH\000B\010\n\006action\"\317\001\n\nChainEvent"
  "\022\014\n\004txID\030\001 \001(\t\022\r\n\005nonce\030\002 \001(\004\022+\n\007builtin"
  "\030\351\007 \001(\0132\027.vega.BuiltinAssetEventH\000\022\"\n\005er"
  "c20\030\352\007 \001(\0132\020.vega.ERC20EventH\000\022\036\n\003btc\030\353\007"
  " \001(\0132\016.vega.BTCEventH\000\022*\n\tvalidator\030\354\007 \001"
  "(\0132\024.vega.ValidatorEventH\000B\007\n\005eventB!Z\037c"
  "ode.vegaprotocol.io/vega/protob\006proto3"
  ;
::google::protobuf::internal::DescriptorTable descriptor_table_proto_2fchain_5fevents_2eproto = {
  false, InitDefaults_proto_2fchain_5fevents_2eproto, 
  descriptor_table_protodef_proto_2fchain_5fevents_2eproto,
  "proto/chain_events.proto", &assign_descriptors_table_proto_2fchain_5fevents_2eproto, 1838,
};

void AddDescriptors_proto_2fchain_5fevents_2eproto() {
  static constexpr ::google::protobuf::internal::InitFunc deps[1] =
  {
  };
 ::google::protobuf::internal::AddDescriptors(&descriptor_table_proto_2fchain_5fevents_2eproto, deps, 0);
}

// Force running AddDescriptors() at dynamic initialization time.
static bool dynamic_init_dummy_proto_2fchain_5fevents_2eproto = []() { AddDescriptors_proto_2fchain_5fevents_2eproto(); return true; }();
namespace vega {

// ===================================================================

void BuiltinAssetDeposit::InitAsDefaultInstance() {
}
class BuiltinAssetDeposit::HasBitSetters {
 public:
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int BuiltinAssetDeposit::kVegaAssetIDFieldNumber;
const int BuiltinAssetDeposit::kPartyIDFieldNumber;
const int BuiltinAssetDeposit::kAmountFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

BuiltinAssetDeposit::BuiltinAssetDeposit()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:vega.BuiltinAssetDeposit)
}
BuiltinAssetDeposit::BuiltinAssetDeposit(const BuiltinAssetDeposit& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  vegaassetid_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.vegaassetid().size() > 0) {
    vegaassetid_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.vegaassetid_);
  }
  partyid_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.partyid().size() > 0) {
    partyid_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.partyid_);
  }
  amount_ = from.amount_;
  // @@protoc_insertion_point(copy_constructor:vega.BuiltinAssetDeposit)
}

void BuiltinAssetDeposit::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_BuiltinAssetDeposit_proto_2fchain_5fevents_2eproto.base);
  vegaassetid_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  partyid_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  amount_ = PROTOBUF_ULONGLONG(0);
}

BuiltinAssetDeposit::~BuiltinAssetDeposit() {
  // @@protoc_insertion_point(destructor:vega.BuiltinAssetDeposit)
  SharedDtor();
}

void BuiltinAssetDeposit::SharedDtor() {
  vegaassetid_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  partyid_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void BuiltinAssetDeposit::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const BuiltinAssetDeposit& BuiltinAssetDeposit::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_BuiltinAssetDeposit_proto_2fchain_5fevents_2eproto.base);
  return *internal_default_instance();
}


void BuiltinAssetDeposit::Clear() {
// @@protoc_insertion_point(message_clear_start:vega.BuiltinAssetDeposit)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  vegaassetid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  partyid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  amount_ = PROTOBUF_ULONGLONG(0);
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* BuiltinAssetDeposit::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<BuiltinAssetDeposit*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // string vegaAssetID = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ctx->extra_parse_data().SetFieldName("vega.BuiltinAssetDeposit.vegaAssetID");
        object = msg->mutable_vegaassetid();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParserUTF8;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheckUTF8(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      // string partyID = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ctx->extra_parse_data().SetFieldName("vega.BuiltinAssetDeposit.partyID");
        object = msg->mutable_partyid();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParserUTF8;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheckUTF8(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      // uint64 amount = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 24) goto handle_unusual;
        msg->set_amount(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
string_till_end:
  static_cast<::std::string*>(object)->clear();
  static_cast<::std::string*>(object)->reserve(size);
  goto len_delim_till_end;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool BuiltinAssetDeposit::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vega.BuiltinAssetDeposit)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // string vegaAssetID = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_vegaassetid()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->vegaassetid().data(), static_cast<int>(this->vegaassetid().length()),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "vega.BuiltinAssetDeposit.vegaAssetID"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // string partyID = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_partyid()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->partyid().data(), static_cast<int>(this->partyid().length()),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "vega.BuiltinAssetDeposit.partyID"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // uint64 amount = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (24 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &amount_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vega.BuiltinAssetDeposit)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vega.BuiltinAssetDeposit)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void BuiltinAssetDeposit::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vega.BuiltinAssetDeposit)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // string vegaAssetID = 1;
  if (this->vegaassetid().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->vegaassetid().data(), static_cast<int>(this->vegaassetid().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "vega.BuiltinAssetDeposit.vegaAssetID");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->vegaassetid(), output);
  }

  // string partyID = 2;
  if (this->partyid().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->partyid().data(), static_cast<int>(this->partyid().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "vega.BuiltinAssetDeposit.partyID");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->partyid(), output);
  }

  // uint64 amount = 3;
  if (this->amount() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->amount(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:vega.BuiltinAssetDeposit)
}

::google::protobuf::uint8* BuiltinAssetDeposit::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:vega.BuiltinAssetDeposit)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // string vegaAssetID = 1;
  if (this->vegaassetid().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->vegaassetid().data(), static_cast<int>(this->vegaassetid().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "vega.BuiltinAssetDeposit.vegaAssetID");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->vegaassetid(), target);
  }

  // string partyID = 2;
  if (this->partyid().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->partyid().data(), static_cast<int>(this->partyid().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "vega.BuiltinAssetDeposit.partyID");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->partyid(), target);
  }

  // uint64 amount = 3;
  if (this->amount() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(3, this->amount(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vega.BuiltinAssetDeposit)
  return target;
}

size_t BuiltinAssetDeposit::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vega.BuiltinAssetDeposit)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string vegaAssetID = 1;
  if (this->vegaassetid().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->vegaassetid());
  }

  // string partyID = 2;
  if (this->partyid().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->partyid());
  }

  // uint64 amount = 3;
  if (this->amount() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->amount());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void BuiltinAssetDeposit::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:vega.BuiltinAssetDeposit)
  GOOGLE_DCHECK_NE(&from, this);
  const BuiltinAssetDeposit* source =
      ::google::protobuf::DynamicCastToGenerated<BuiltinAssetDeposit>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:vega.BuiltinAssetDeposit)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:vega.BuiltinAssetDeposit)
    MergeFrom(*source);
  }
}

void BuiltinAssetDeposit::MergeFrom(const BuiltinAssetDeposit& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vega.BuiltinAssetDeposit)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.vegaassetid().size() > 0) {

    vegaassetid_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.vegaassetid_);
  }
  if (from.partyid().size() > 0) {

    partyid_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.partyid_);
  }
  if (from.amount() != 0) {
    set_amount(from.amount());
  }
}

void BuiltinAssetDeposit::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:vega.BuiltinAssetDeposit)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void BuiltinAssetDeposit::CopyFrom(const BuiltinAssetDeposit& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vega.BuiltinAssetDeposit)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BuiltinAssetDeposit::IsInitialized() const {
  return true;
}

void BuiltinAssetDeposit::Swap(BuiltinAssetDeposit* other) {
  if (other == this) return;
  InternalSwap(other);
}
void BuiltinAssetDeposit::InternalSwap(BuiltinAssetDeposit* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  vegaassetid_.Swap(&other->vegaassetid_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  partyid_.Swap(&other->partyid_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(amount_, other->amount_);
}

::google::protobuf::Metadata BuiltinAssetDeposit::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_proto_2fchain_5fevents_2eproto);
  return ::file_level_metadata_proto_2fchain_5fevents_2eproto[kIndexInFileMessages];
}


// ===================================================================

void BuiltinAssetWithdrawal::InitAsDefaultInstance() {
}
class BuiltinAssetWithdrawal::HasBitSetters {
 public:
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int BuiltinAssetWithdrawal::kVegaAssetIDFieldNumber;
const int BuiltinAssetWithdrawal::kPartyIDFieldNumber;
const int BuiltinAssetWithdrawal::kAmountFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

BuiltinAssetWithdrawal::BuiltinAssetWithdrawal()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:vega.BuiltinAssetWithdrawal)
}
BuiltinAssetWithdrawal::BuiltinAssetWithdrawal(const BuiltinAssetWithdrawal& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  vegaassetid_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.vegaassetid().size() > 0) {
    vegaassetid_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.vegaassetid_);
  }
  partyid_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.partyid().size() > 0) {
    partyid_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.partyid_);
  }
  amount_ = from.amount_;
  // @@protoc_insertion_point(copy_constructor:vega.BuiltinAssetWithdrawal)
}

void BuiltinAssetWithdrawal::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_BuiltinAssetWithdrawal_proto_2fchain_5fevents_2eproto.base);
  vegaassetid_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  partyid_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  amount_ = PROTOBUF_ULONGLONG(0);
}

BuiltinAssetWithdrawal::~BuiltinAssetWithdrawal() {
  // @@protoc_insertion_point(destructor:vega.BuiltinAssetWithdrawal)
  SharedDtor();
}

void BuiltinAssetWithdrawal::SharedDtor() {
  vegaassetid_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  partyid_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void BuiltinAssetWithdrawal::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const BuiltinAssetWithdrawal& BuiltinAssetWithdrawal::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_BuiltinAssetWithdrawal_proto_2fchain_5fevents_2eproto.base);
  return *internal_default_instance();
}


void BuiltinAssetWithdrawal::Clear() {
// @@protoc_insertion_point(message_clear_start:vega.BuiltinAssetWithdrawal)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  vegaassetid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  partyid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  amount_ = PROTOBUF_ULONGLONG(0);
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* BuiltinAssetWithdrawal::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<BuiltinAssetWithdrawal*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // string vegaAssetID = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ctx->extra_parse_data().SetFieldName("vega.BuiltinAssetWithdrawal.vegaAssetID");
        object = msg->mutable_vegaassetid();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParserUTF8;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheckUTF8(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      // string partyID = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ctx->extra_parse_data().SetFieldName("vega.BuiltinAssetWithdrawal.partyID");
        object = msg->mutable_partyid();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParserUTF8;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheckUTF8(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      // uint64 amount = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 24) goto handle_unusual;
        msg->set_amount(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
string_till_end:
  static_cast<::std::string*>(object)->clear();
  static_cast<::std::string*>(object)->reserve(size);
  goto len_delim_till_end;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool BuiltinAssetWithdrawal::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vega.BuiltinAssetWithdrawal)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // string vegaAssetID = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_vegaassetid()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->vegaassetid().data(), static_cast<int>(this->vegaassetid().length()),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "vega.BuiltinAssetWithdrawal.vegaAssetID"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // string partyID = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_partyid()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->partyid().data(), static_cast<int>(this->partyid().length()),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "vega.BuiltinAssetWithdrawal.partyID"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // uint64 amount = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (24 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &amount_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vega.BuiltinAssetWithdrawal)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vega.BuiltinAssetWithdrawal)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void BuiltinAssetWithdrawal::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vega.BuiltinAssetWithdrawal)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // string vegaAssetID = 1;
  if (this->vegaassetid().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->vegaassetid().data(), static_cast<int>(this->vegaassetid().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "vega.BuiltinAssetWithdrawal.vegaAssetID");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->vegaassetid(), output);
  }

  // string partyID = 2;
  if (this->partyid().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->partyid().data(), static_cast<int>(this->partyid().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "vega.BuiltinAssetWithdrawal.partyID");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->partyid(), output);
  }

  // uint64 amount = 3;
  if (this->amount() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->amount(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:vega.BuiltinAssetWithdrawal)
}

::google::protobuf::uint8* BuiltinAssetWithdrawal::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:vega.BuiltinAssetWithdrawal)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // string vegaAssetID = 1;
  if (this->vegaassetid().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->vegaassetid().data(), static_cast<int>(this->vegaassetid().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "vega.BuiltinAssetWithdrawal.vegaAssetID");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->vegaassetid(), target);
  }

  // string partyID = 2;
  if (this->partyid().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->partyid().data(), static_cast<int>(this->partyid().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "vega.BuiltinAssetWithdrawal.partyID");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->partyid(), target);
  }

  // uint64 amount = 3;
  if (this->amount() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(3, this->amount(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vega.BuiltinAssetWithdrawal)
  return target;
}

size_t BuiltinAssetWithdrawal::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vega.BuiltinAssetWithdrawal)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string vegaAssetID = 1;
  if (this->vegaassetid().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->vegaassetid());
  }

  // string partyID = 2;
  if (this->partyid().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->partyid());
  }

  // uint64 amount = 3;
  if (this->amount() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->amount());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void BuiltinAssetWithdrawal::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:vega.BuiltinAssetWithdrawal)
  GOOGLE_DCHECK_NE(&from, this);
  const BuiltinAssetWithdrawal* source =
      ::google::protobuf::DynamicCastToGenerated<BuiltinAssetWithdrawal>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:vega.BuiltinAssetWithdrawal)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:vega.BuiltinAssetWithdrawal)
    MergeFrom(*source);
  }
}

void BuiltinAssetWithdrawal::MergeFrom(const BuiltinAssetWithdrawal& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vega.BuiltinAssetWithdrawal)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.vegaassetid().size() > 0) {

    vegaassetid_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.vegaassetid_);
  }
  if (from.partyid().size() > 0) {

    partyid_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.partyid_);
  }
  if (from.amount() != 0) {
    set_amount(from.amount());
  }
}

void BuiltinAssetWithdrawal::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:vega.BuiltinAssetWithdrawal)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void BuiltinAssetWithdrawal::CopyFrom(const BuiltinAssetWithdrawal& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vega.BuiltinAssetWithdrawal)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BuiltinAssetWithdrawal::IsInitialized() const {
  return true;
}

void BuiltinAssetWithdrawal::Swap(BuiltinAssetWithdrawal* other) {
  if (other == this) return;
  InternalSwap(other);
}
void BuiltinAssetWithdrawal::InternalSwap(BuiltinAssetWithdrawal* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  vegaassetid_.Swap(&other->vegaassetid_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  partyid_.Swap(&other->partyid_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(amount_, other->amount_);
}

::google::protobuf::Metadata BuiltinAssetWithdrawal::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_proto_2fchain_5fevents_2eproto);
  return ::file_level_metadata_proto_2fchain_5fevents_2eproto[kIndexInFileMessages];
}


// ===================================================================

void BuiltinAssetEvent::InitAsDefaultInstance() {
  ::vega::_BuiltinAssetEvent_default_instance_.deposit_ = const_cast< ::vega::BuiltinAssetDeposit*>(
      ::vega::BuiltinAssetDeposit::internal_default_instance());
  ::vega::_BuiltinAssetEvent_default_instance_.withdrawal_ = const_cast< ::vega::BuiltinAssetWithdrawal*>(
      ::vega::BuiltinAssetWithdrawal::internal_default_instance());
}
class BuiltinAssetEvent::HasBitSetters {
 public:
  static const ::vega::BuiltinAssetDeposit& deposit(const BuiltinAssetEvent* msg);
  static const ::vega::BuiltinAssetWithdrawal& withdrawal(const BuiltinAssetEvent* msg);
};

const ::vega::BuiltinAssetDeposit&
BuiltinAssetEvent::HasBitSetters::deposit(const BuiltinAssetEvent* msg) {
  return *msg->action_.deposit_;
}
const ::vega::BuiltinAssetWithdrawal&
BuiltinAssetEvent::HasBitSetters::withdrawal(const BuiltinAssetEvent* msg) {
  return *msg->action_.withdrawal_;
}
void BuiltinAssetEvent::set_allocated_deposit(::vega::BuiltinAssetDeposit* deposit) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  clear_action();
  if (deposit) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      deposit = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, deposit, submessage_arena);
    }
    set_has_deposit();
    action_.deposit_ = deposit;
  }
  // @@protoc_insertion_point(field_set_allocated:vega.BuiltinAssetEvent.deposit)
}
void BuiltinAssetEvent::set_allocated_withdrawal(::vega::BuiltinAssetWithdrawal* withdrawal) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  clear_action();
  if (withdrawal) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      withdrawal = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, withdrawal, submessage_arena);
    }
    set_has_withdrawal();
    action_.withdrawal_ = withdrawal;
  }
  // @@protoc_insertion_point(field_set_allocated:vega.BuiltinAssetEvent.withdrawal)
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int BuiltinAssetEvent::kDepositFieldNumber;
const int BuiltinAssetEvent::kWithdrawalFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

BuiltinAssetEvent::BuiltinAssetEvent()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:vega.BuiltinAssetEvent)
}
BuiltinAssetEvent::BuiltinAssetEvent(const BuiltinAssetEvent& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  clear_has_action();
  switch (from.action_case()) {
    case kDeposit: {
      mutable_deposit()->::vega::BuiltinAssetDeposit::MergeFrom(from.deposit());
      break;
    }
    case kWithdrawal: {
      mutable_withdrawal()->::vega::BuiltinAssetWithdrawal::MergeFrom(from.withdrawal());
      break;
    }
    case ACTION_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:vega.BuiltinAssetEvent)
}

void BuiltinAssetEvent::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_BuiltinAssetEvent_proto_2fchain_5fevents_2eproto.base);
  clear_has_action();
}

BuiltinAssetEvent::~BuiltinAssetEvent() {
  // @@protoc_insertion_point(destructor:vega.BuiltinAssetEvent)
  SharedDtor();
}

void BuiltinAssetEvent::SharedDtor() {
  if (has_action()) {
    clear_action();
  }
}

void BuiltinAssetEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const BuiltinAssetEvent& BuiltinAssetEvent::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_BuiltinAssetEvent_proto_2fchain_5fevents_2eproto.base);
  return *internal_default_instance();
}


void BuiltinAssetEvent::clear_action() {
// @@protoc_insertion_point(one_of_clear_start:vega.BuiltinAssetEvent)
  switch (action_case()) {
    case kDeposit: {
      delete action_.deposit_;
      break;
    }
    case kWithdrawal: {
      delete action_.withdrawal_;
      break;
    }
    case ACTION_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = ACTION_NOT_SET;
}


void BuiltinAssetEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:vega.BuiltinAssetEvent)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_action();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* BuiltinAssetEvent::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<BuiltinAssetEvent*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // .vega.BuiltinAssetDeposit deposit = 1001;
      case 1001: {
        if (static_cast<::google::protobuf::uint8>(tag) != 74) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::vega::BuiltinAssetDeposit::_InternalParse;
        object = msg->mutable_deposit();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // .vega.BuiltinAssetWithdrawal withdrawal = 1002;
      case 1002: {
        if (static_cast<::google::protobuf::uint8>(tag) != 82) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::vega::BuiltinAssetWithdrawal::_InternalParse;
        object = msg->mutable_withdrawal();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool BuiltinAssetEvent::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vega.BuiltinAssetEvent)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(16383u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // .vega.BuiltinAssetDeposit deposit = 1001;
      case 1001: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8010 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_deposit()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .vega.BuiltinAssetWithdrawal withdrawal = 1002;
      case 1002: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8018 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_withdrawal()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vega.BuiltinAssetEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vega.BuiltinAssetEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void BuiltinAssetEvent::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vega.BuiltinAssetEvent)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .vega.BuiltinAssetDeposit deposit = 1001;
  if (has_deposit()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1001, HasBitSetters::deposit(this), output);
  }

  // .vega.BuiltinAssetWithdrawal withdrawal = 1002;
  if (has_withdrawal()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1002, HasBitSetters::withdrawal(this), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:vega.BuiltinAssetEvent)
}

::google::protobuf::uint8* BuiltinAssetEvent::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:vega.BuiltinAssetEvent)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .vega.BuiltinAssetDeposit deposit = 1001;
  if (has_deposit()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1001, HasBitSetters::deposit(this), target);
  }

  // .vega.BuiltinAssetWithdrawal withdrawal = 1002;
  if (has_withdrawal()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1002, HasBitSetters::withdrawal(this), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vega.BuiltinAssetEvent)
  return target;
}

size_t BuiltinAssetEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vega.BuiltinAssetEvent)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (action_case()) {
    // .vega.BuiltinAssetDeposit deposit = 1001;
    case kDeposit: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *action_.deposit_);
      break;
    }
    // .vega.BuiltinAssetWithdrawal withdrawal = 1002;
    case kWithdrawal: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *action_.withdrawal_);
      break;
    }
    case ACTION_NOT_SET: {
      break;
    }
  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void BuiltinAssetEvent::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:vega.BuiltinAssetEvent)
  GOOGLE_DCHECK_NE(&from, this);
  const BuiltinAssetEvent* source =
      ::google::protobuf::DynamicCastToGenerated<BuiltinAssetEvent>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:vega.BuiltinAssetEvent)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:vega.BuiltinAssetEvent)
    MergeFrom(*source);
  }
}

void BuiltinAssetEvent::MergeFrom(const BuiltinAssetEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vega.BuiltinAssetEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.action_case()) {
    case kDeposit: {
      mutable_deposit()->::vega::BuiltinAssetDeposit::MergeFrom(from.deposit());
      break;
    }
    case kWithdrawal: {
      mutable_withdrawal()->::vega::BuiltinAssetWithdrawal::MergeFrom(from.withdrawal());
      break;
    }
    case ACTION_NOT_SET: {
      break;
    }
  }
}

void BuiltinAssetEvent::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:vega.BuiltinAssetEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void BuiltinAssetEvent::CopyFrom(const BuiltinAssetEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vega.BuiltinAssetEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BuiltinAssetEvent::IsInitialized() const {
  return true;
}

void BuiltinAssetEvent::Swap(BuiltinAssetEvent* other) {
  if (other == this) return;
  InternalSwap(other);
}
void BuiltinAssetEvent::InternalSwap(BuiltinAssetEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(action_, other->action_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

::google::protobuf::Metadata BuiltinAssetEvent::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_proto_2fchain_5fevents_2eproto);
  return ::file_level_metadata_proto_2fchain_5fevents_2eproto[kIndexInFileMessages];
}


// ===================================================================

void ERC20AssetList::InitAsDefaultInstance() {
}
class ERC20AssetList::HasBitSetters {
 public:
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ERC20AssetList::kVegaAssetIDFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ERC20AssetList::ERC20AssetList()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:vega.ERC20AssetList)
}
ERC20AssetList::ERC20AssetList(const ERC20AssetList& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  vegaassetid_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.vegaassetid().size() > 0) {
    vegaassetid_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.vegaassetid_);
  }
  // @@protoc_insertion_point(copy_constructor:vega.ERC20AssetList)
}

void ERC20AssetList::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_ERC20AssetList_proto_2fchain_5fevents_2eproto.base);
  vegaassetid_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

ERC20AssetList::~ERC20AssetList() {
  // @@protoc_insertion_point(destructor:vega.ERC20AssetList)
  SharedDtor();
}

void ERC20AssetList::SharedDtor() {
  vegaassetid_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void ERC20AssetList::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ERC20AssetList& ERC20AssetList::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_ERC20AssetList_proto_2fchain_5fevents_2eproto.base);
  return *internal_default_instance();
}


void ERC20AssetList::Clear() {
// @@protoc_insertion_point(message_clear_start:vega.ERC20AssetList)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  vegaassetid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* ERC20AssetList::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<ERC20AssetList*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // string vegaAssetID = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ctx->extra_parse_data().SetFieldName("vega.ERC20AssetList.vegaAssetID");
        object = msg->mutable_vegaassetid();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParserUTF8;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheckUTF8(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
string_till_end:
  static_cast<::std::string*>(object)->clear();
  static_cast<::std::string*>(object)->reserve(size);
  goto len_delim_till_end;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool ERC20AssetList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vega.ERC20AssetList)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // string vegaAssetID = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_vegaassetid()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->vegaassetid().data(), static_cast<int>(this->vegaassetid().length()),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "vega.ERC20AssetList.vegaAssetID"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vega.ERC20AssetList)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vega.ERC20AssetList)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void ERC20AssetList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vega.ERC20AssetList)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // string vegaAssetID = 1;
  if (this->vegaassetid().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->vegaassetid().data(), static_cast<int>(this->vegaassetid().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "vega.ERC20AssetList.vegaAssetID");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->vegaassetid(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:vega.ERC20AssetList)
}

::google::protobuf::uint8* ERC20AssetList::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:vega.ERC20AssetList)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // string vegaAssetID = 1;
  if (this->vegaassetid().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->vegaassetid().data(), static_cast<int>(this->vegaassetid().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "vega.ERC20AssetList.vegaAssetID");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->vegaassetid(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vega.ERC20AssetList)
  return target;
}

size_t ERC20AssetList::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vega.ERC20AssetList)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string vegaAssetID = 1;
  if (this->vegaassetid().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->vegaassetid());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ERC20AssetList::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:vega.ERC20AssetList)
  GOOGLE_DCHECK_NE(&from, this);
  const ERC20AssetList* source =
      ::google::protobuf::DynamicCastToGenerated<ERC20AssetList>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:vega.ERC20AssetList)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:vega.ERC20AssetList)
    MergeFrom(*source);
  }
}

void ERC20AssetList::MergeFrom(const ERC20AssetList& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vega.ERC20AssetList)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.vegaassetid().size() > 0) {

    vegaassetid_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.vegaassetid_);
  }
}

void ERC20AssetList::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:vega.ERC20AssetList)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ERC20AssetList::CopyFrom(const ERC20AssetList& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vega.ERC20AssetList)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ERC20AssetList::IsInitialized() const {
  return true;
}

void ERC20AssetList::Swap(ERC20AssetList* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ERC20AssetList::InternalSwap(ERC20AssetList* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  vegaassetid_.Swap(&other->vegaassetid_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
}

::google::protobuf::Metadata ERC20AssetList::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_proto_2fchain_5fevents_2eproto);
  return ::file_level_metadata_proto_2fchain_5fevents_2eproto[kIndexInFileMessages];
}


// ===================================================================

void ERC20AssetDelist::InitAsDefaultInstance() {
}
class ERC20AssetDelist::HasBitSetters {
 public:
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ERC20AssetDelist::kVegaAssetIDFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ERC20AssetDelist::ERC20AssetDelist()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:vega.ERC20AssetDelist)
}
ERC20AssetDelist::ERC20AssetDelist(const ERC20AssetDelist& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  vegaassetid_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.vegaassetid().size() > 0) {
    vegaassetid_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.vegaassetid_);
  }
  // @@protoc_insertion_point(copy_constructor:vega.ERC20AssetDelist)
}

void ERC20AssetDelist::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_ERC20AssetDelist_proto_2fchain_5fevents_2eproto.base);
  vegaassetid_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

ERC20AssetDelist::~ERC20AssetDelist() {
  // @@protoc_insertion_point(destructor:vega.ERC20AssetDelist)
  SharedDtor();
}

void ERC20AssetDelist::SharedDtor() {
  vegaassetid_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void ERC20AssetDelist::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ERC20AssetDelist& ERC20AssetDelist::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_ERC20AssetDelist_proto_2fchain_5fevents_2eproto.base);
  return *internal_default_instance();
}


void ERC20AssetDelist::Clear() {
// @@protoc_insertion_point(message_clear_start:vega.ERC20AssetDelist)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  vegaassetid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* ERC20AssetDelist::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<ERC20AssetDelist*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // string vegaAssetID = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ctx->extra_parse_data().SetFieldName("vega.ERC20AssetDelist.vegaAssetID");
        object = msg->mutable_vegaassetid();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParserUTF8;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheckUTF8(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
string_till_end:
  static_cast<::std::string*>(object)->clear();
  static_cast<::std::string*>(object)->reserve(size);
  goto len_delim_till_end;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool ERC20AssetDelist::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vega.ERC20AssetDelist)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // string vegaAssetID = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_vegaassetid()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->vegaassetid().data(), static_cast<int>(this->vegaassetid().length()),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "vega.ERC20AssetDelist.vegaAssetID"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vega.ERC20AssetDelist)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vega.ERC20AssetDelist)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void ERC20AssetDelist::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vega.ERC20AssetDelist)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // string vegaAssetID = 1;
  if (this->vegaassetid().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->vegaassetid().data(), static_cast<int>(this->vegaassetid().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "vega.ERC20AssetDelist.vegaAssetID");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->vegaassetid(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:vega.ERC20AssetDelist)
}

::google::protobuf::uint8* ERC20AssetDelist::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:vega.ERC20AssetDelist)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // string vegaAssetID = 1;
  if (this->vegaassetid().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->vegaassetid().data(), static_cast<int>(this->vegaassetid().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "vega.ERC20AssetDelist.vegaAssetID");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->vegaassetid(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vega.ERC20AssetDelist)
  return target;
}

size_t ERC20AssetDelist::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vega.ERC20AssetDelist)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string vegaAssetID = 1;
  if (this->vegaassetid().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->vegaassetid());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ERC20AssetDelist::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:vega.ERC20AssetDelist)
  GOOGLE_DCHECK_NE(&from, this);
  const ERC20AssetDelist* source =
      ::google::protobuf::DynamicCastToGenerated<ERC20AssetDelist>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:vega.ERC20AssetDelist)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:vega.ERC20AssetDelist)
    MergeFrom(*source);
  }
}

void ERC20AssetDelist::MergeFrom(const ERC20AssetDelist& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vega.ERC20AssetDelist)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.vegaassetid().size() > 0) {

    vegaassetid_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.vegaassetid_);
  }
}

void ERC20AssetDelist::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:vega.ERC20AssetDelist)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ERC20AssetDelist::CopyFrom(const ERC20AssetDelist& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vega.ERC20AssetDelist)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ERC20AssetDelist::IsInitialized() const {
  return true;
}

void ERC20AssetDelist::Swap(ERC20AssetDelist* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ERC20AssetDelist::InternalSwap(ERC20AssetDelist* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  vegaassetid_.Swap(&other->vegaassetid_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
}

::google::protobuf::Metadata ERC20AssetDelist::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_proto_2fchain_5fevents_2eproto);
  return ::file_level_metadata_proto_2fchain_5fevents_2eproto[kIndexInFileMessages];
}


// ===================================================================

void ERC20Deposit::InitAsDefaultInstance() {
}
class ERC20Deposit::HasBitSetters {
 public:
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ERC20Deposit::kVegaAssetIDFieldNumber;
const int ERC20Deposit::kSourceEthereumAddressFieldNumber;
const int ERC20Deposit::kTargetPartyIDFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ERC20Deposit::ERC20Deposit()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:vega.ERC20Deposit)
}
ERC20Deposit::ERC20Deposit(const ERC20Deposit& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  vegaassetid_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.vegaassetid().size() > 0) {
    vegaassetid_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.vegaassetid_);
  }
  sourceethereumaddress_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.sourceethereumaddress().size() > 0) {
    sourceethereumaddress_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.sourceethereumaddress_);
  }
  targetpartyid_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.targetpartyid().size() > 0) {
    targetpartyid_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.targetpartyid_);
  }
  // @@protoc_insertion_point(copy_constructor:vega.ERC20Deposit)
}

void ERC20Deposit::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_ERC20Deposit_proto_2fchain_5fevents_2eproto.base);
  vegaassetid_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  sourceethereumaddress_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  targetpartyid_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

ERC20Deposit::~ERC20Deposit() {
  // @@protoc_insertion_point(destructor:vega.ERC20Deposit)
  SharedDtor();
}

void ERC20Deposit::SharedDtor() {
  vegaassetid_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  sourceethereumaddress_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  targetpartyid_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void ERC20Deposit::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ERC20Deposit& ERC20Deposit::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_ERC20Deposit_proto_2fchain_5fevents_2eproto.base);
  return *internal_default_instance();
}


void ERC20Deposit::Clear() {
// @@protoc_insertion_point(message_clear_start:vega.ERC20Deposit)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  vegaassetid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  sourceethereumaddress_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  targetpartyid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* ERC20Deposit::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<ERC20Deposit*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // string vegaAssetID = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ctx->extra_parse_data().SetFieldName("vega.ERC20Deposit.vegaAssetID");
        object = msg->mutable_vegaassetid();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParserUTF8;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheckUTF8(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      // string sourceEthereumAddress = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ctx->extra_parse_data().SetFieldName("vega.ERC20Deposit.sourceEthereumAddress");
        object = msg->mutable_sourceethereumaddress();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParserUTF8;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheckUTF8(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      // string targetPartyID = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 26) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ctx->extra_parse_data().SetFieldName("vega.ERC20Deposit.targetPartyID");
        object = msg->mutable_targetpartyid();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParserUTF8;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheckUTF8(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
string_till_end:
  static_cast<::std::string*>(object)->clear();
  static_cast<::std::string*>(object)->reserve(size);
  goto len_delim_till_end;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool ERC20Deposit::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vega.ERC20Deposit)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // string vegaAssetID = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_vegaassetid()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->vegaassetid().data(), static_cast<int>(this->vegaassetid().length()),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "vega.ERC20Deposit.vegaAssetID"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // string sourceEthereumAddress = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_sourceethereumaddress()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->sourceethereumaddress().data(), static_cast<int>(this->sourceethereumaddress().length()),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "vega.ERC20Deposit.sourceEthereumAddress"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // string targetPartyID = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (26 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_targetpartyid()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->targetpartyid().data(), static_cast<int>(this->targetpartyid().length()),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "vega.ERC20Deposit.targetPartyID"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vega.ERC20Deposit)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vega.ERC20Deposit)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void ERC20Deposit::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vega.ERC20Deposit)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // string vegaAssetID = 1;
  if (this->vegaassetid().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->vegaassetid().data(), static_cast<int>(this->vegaassetid().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "vega.ERC20Deposit.vegaAssetID");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->vegaassetid(), output);
  }

  // string sourceEthereumAddress = 2;
  if (this->sourceethereumaddress().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->sourceethereumaddress().data(), static_cast<int>(this->sourceethereumaddress().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "vega.ERC20Deposit.sourceEthereumAddress");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->sourceethereumaddress(), output);
  }

  // string targetPartyID = 3;
  if (this->targetpartyid().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->targetpartyid().data(), static_cast<int>(this->targetpartyid().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "vega.ERC20Deposit.targetPartyID");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->targetpartyid(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:vega.ERC20Deposit)
}

::google::protobuf::uint8* ERC20Deposit::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:vega.ERC20Deposit)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // string vegaAssetID = 1;
  if (this->vegaassetid().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->vegaassetid().data(), static_cast<int>(this->vegaassetid().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "vega.ERC20Deposit.vegaAssetID");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->vegaassetid(), target);
  }

  // string sourceEthereumAddress = 2;
  if (this->sourceethereumaddress().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->sourceethereumaddress().data(), static_cast<int>(this->sourceethereumaddress().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "vega.ERC20Deposit.sourceEthereumAddress");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->sourceethereumaddress(), target);
  }

  // string targetPartyID = 3;
  if (this->targetpartyid().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->targetpartyid().data(), static_cast<int>(this->targetpartyid().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "vega.ERC20Deposit.targetPartyID");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->targetpartyid(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vega.ERC20Deposit)
  return target;
}

size_t ERC20Deposit::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vega.ERC20Deposit)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string vegaAssetID = 1;
  if (this->vegaassetid().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->vegaassetid());
  }

  // string sourceEthereumAddress = 2;
  if (this->sourceethereumaddress().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->sourceethereumaddress());
  }

  // string targetPartyID = 3;
  if (this->targetpartyid().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->targetpartyid());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ERC20Deposit::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:vega.ERC20Deposit)
  GOOGLE_DCHECK_NE(&from, this);
  const ERC20Deposit* source =
      ::google::protobuf::DynamicCastToGenerated<ERC20Deposit>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:vega.ERC20Deposit)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:vega.ERC20Deposit)
    MergeFrom(*source);
  }
}

void ERC20Deposit::MergeFrom(const ERC20Deposit& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vega.ERC20Deposit)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.vegaassetid().size() > 0) {

    vegaassetid_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.vegaassetid_);
  }
  if (from.sourceethereumaddress().size() > 0) {

    sourceethereumaddress_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.sourceethereumaddress_);
  }
  if (from.targetpartyid().size() > 0) {

    targetpartyid_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.targetpartyid_);
  }
}

void ERC20Deposit::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:vega.ERC20Deposit)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ERC20Deposit::CopyFrom(const ERC20Deposit& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vega.ERC20Deposit)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ERC20Deposit::IsInitialized() const {
  return true;
}

void ERC20Deposit::Swap(ERC20Deposit* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ERC20Deposit::InternalSwap(ERC20Deposit* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  vegaassetid_.Swap(&other->vegaassetid_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  sourceethereumaddress_.Swap(&other->sourceethereumaddress_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  targetpartyid_.Swap(&other->targetpartyid_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
}

::google::protobuf::Metadata ERC20Deposit::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_proto_2fchain_5fevents_2eproto);
  return ::file_level_metadata_proto_2fchain_5fevents_2eproto[kIndexInFileMessages];
}


// ===================================================================

void ERC20Withdrawal::InitAsDefaultInstance() {
}
class ERC20Withdrawal::HasBitSetters {
 public:
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ERC20Withdrawal::kVegaAssetIDFieldNumber;
const int ERC20Withdrawal::kSourcePartyIdFieldNumber;
const int ERC20Withdrawal::kTargetEthereumAddressFieldNumber;
const int ERC20Withdrawal::kReferenceNonceFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ERC20Withdrawal::ERC20Withdrawal()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:vega.ERC20Withdrawal)
}
ERC20Withdrawal::ERC20Withdrawal(const ERC20Withdrawal& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  vegaassetid_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.vegaassetid().size() > 0) {
    vegaassetid_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.vegaassetid_);
  }
  sourcepartyid_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.sourcepartyid().size() > 0) {
    sourcepartyid_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.sourcepartyid_);
  }
  targetethereumaddress_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.targetethereumaddress().size() > 0) {
    targetethereumaddress_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.targetethereumaddress_);
  }
  referencenonce_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.referencenonce().size() > 0) {
    referencenonce_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.referencenonce_);
  }
  // @@protoc_insertion_point(copy_constructor:vega.ERC20Withdrawal)
}

void ERC20Withdrawal::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_ERC20Withdrawal_proto_2fchain_5fevents_2eproto.base);
  vegaassetid_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  sourcepartyid_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  targetethereumaddress_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  referencenonce_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

ERC20Withdrawal::~ERC20Withdrawal() {
  // @@protoc_insertion_point(destructor:vega.ERC20Withdrawal)
  SharedDtor();
}

void ERC20Withdrawal::SharedDtor() {
  vegaassetid_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  sourcepartyid_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  targetethereumaddress_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  referencenonce_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void ERC20Withdrawal::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ERC20Withdrawal& ERC20Withdrawal::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_ERC20Withdrawal_proto_2fchain_5fevents_2eproto.base);
  return *internal_default_instance();
}


void ERC20Withdrawal::Clear() {
// @@protoc_insertion_point(message_clear_start:vega.ERC20Withdrawal)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  vegaassetid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  sourcepartyid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  targetethereumaddress_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  referencenonce_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* ERC20Withdrawal::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<ERC20Withdrawal*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // string vegaAssetID = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ctx->extra_parse_data().SetFieldName("vega.ERC20Withdrawal.vegaAssetID");
        object = msg->mutable_vegaassetid();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParserUTF8;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheckUTF8(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      // string sourcePartyId = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ctx->extra_parse_data().SetFieldName("vega.ERC20Withdrawal.sourcePartyId");
        object = msg->mutable_sourcepartyid();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParserUTF8;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheckUTF8(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      // string targetEthereumAddress = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 26) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ctx->extra_parse_data().SetFieldName("vega.ERC20Withdrawal.targetEthereumAddress");
        object = msg->mutable_targetethereumaddress();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParserUTF8;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheckUTF8(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      // string referenceNonce = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 34) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ctx->extra_parse_data().SetFieldName("vega.ERC20Withdrawal.referenceNonce");
        object = msg->mutable_referencenonce();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParserUTF8;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheckUTF8(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
string_till_end:
  static_cast<::std::string*>(object)->clear();
  static_cast<::std::string*>(object)->reserve(size);
  goto len_delim_till_end;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool ERC20Withdrawal::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vega.ERC20Withdrawal)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // string vegaAssetID = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_vegaassetid()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->vegaassetid().data(), static_cast<int>(this->vegaassetid().length()),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "vega.ERC20Withdrawal.vegaAssetID"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // string sourcePartyId = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_sourcepartyid()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->sourcepartyid().data(), static_cast<int>(this->sourcepartyid().length()),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "vega.ERC20Withdrawal.sourcePartyId"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // string targetEthereumAddress = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (26 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_targetethereumaddress()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->targetethereumaddress().data(), static_cast<int>(this->targetethereumaddress().length()),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "vega.ERC20Withdrawal.targetEthereumAddress"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // string referenceNonce = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (34 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_referencenonce()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->referencenonce().data(), static_cast<int>(this->referencenonce().length()),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "vega.ERC20Withdrawal.referenceNonce"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vega.ERC20Withdrawal)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vega.ERC20Withdrawal)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void ERC20Withdrawal::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vega.ERC20Withdrawal)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // string vegaAssetID = 1;
  if (this->vegaassetid().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->vegaassetid().data(), static_cast<int>(this->vegaassetid().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "vega.ERC20Withdrawal.vegaAssetID");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->vegaassetid(), output);
  }

  // string sourcePartyId = 2;
  if (this->sourcepartyid().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->sourcepartyid().data(), static_cast<int>(this->sourcepartyid().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "vega.ERC20Withdrawal.sourcePartyId");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->sourcepartyid(), output);
  }

  // string targetEthereumAddress = 3;
  if (this->targetethereumaddress().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->targetethereumaddress().data(), static_cast<int>(this->targetethereumaddress().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "vega.ERC20Withdrawal.targetEthereumAddress");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->targetethereumaddress(), output);
  }

  // string referenceNonce = 4;
  if (this->referencenonce().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->referencenonce().data(), static_cast<int>(this->referencenonce().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "vega.ERC20Withdrawal.referenceNonce");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->referencenonce(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:vega.ERC20Withdrawal)
}

::google::protobuf::uint8* ERC20Withdrawal::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:vega.ERC20Withdrawal)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // string vegaAssetID = 1;
  if (this->vegaassetid().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->vegaassetid().data(), static_cast<int>(this->vegaassetid().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "vega.ERC20Withdrawal.vegaAssetID");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->vegaassetid(), target);
  }

  // string sourcePartyId = 2;
  if (this->sourcepartyid().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->sourcepartyid().data(), static_cast<int>(this->sourcepartyid().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "vega.ERC20Withdrawal.sourcePartyId");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->sourcepartyid(), target);
  }

  // string targetEthereumAddress = 3;
  if (this->targetethereumaddress().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->targetethereumaddress().data(), static_cast<int>(this->targetethereumaddress().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "vega.ERC20Withdrawal.targetEthereumAddress");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->targetethereumaddress(), target);
  }

  // string referenceNonce = 4;
  if (this->referencenonce().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->referencenonce().data(), static_cast<int>(this->referencenonce().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "vega.ERC20Withdrawal.referenceNonce");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->referencenonce(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vega.ERC20Withdrawal)
  return target;
}

size_t ERC20Withdrawal::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vega.ERC20Withdrawal)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string vegaAssetID = 1;
  if (this->vegaassetid().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->vegaassetid());
  }

  // string sourcePartyId = 2;
  if (this->sourcepartyid().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->sourcepartyid());
  }

  // string targetEthereumAddress = 3;
  if (this->targetethereumaddress().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->targetethereumaddress());
  }

  // string referenceNonce = 4;
  if (this->referencenonce().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->referencenonce());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ERC20Withdrawal::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:vega.ERC20Withdrawal)
  GOOGLE_DCHECK_NE(&from, this);
  const ERC20Withdrawal* source =
      ::google::protobuf::DynamicCastToGenerated<ERC20Withdrawal>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:vega.ERC20Withdrawal)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:vega.ERC20Withdrawal)
    MergeFrom(*source);
  }
}

void ERC20Withdrawal::MergeFrom(const ERC20Withdrawal& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vega.ERC20Withdrawal)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.vegaassetid().size() > 0) {

    vegaassetid_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.vegaassetid_);
  }
  if (from.sourcepartyid().size() > 0) {

    sourcepartyid_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.sourcepartyid_);
  }
  if (from.targetethereumaddress().size() > 0) {

    targetethereumaddress_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.targetethereumaddress_);
  }
  if (from.referencenonce().size() > 0) {

    referencenonce_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.referencenonce_);
  }
}

void ERC20Withdrawal::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:vega.ERC20Withdrawal)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ERC20Withdrawal::CopyFrom(const ERC20Withdrawal& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vega.ERC20Withdrawal)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ERC20Withdrawal::IsInitialized() const {
  return true;
}

void ERC20Withdrawal::Swap(ERC20Withdrawal* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ERC20Withdrawal::InternalSwap(ERC20Withdrawal* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  vegaassetid_.Swap(&other->vegaassetid_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  sourcepartyid_.Swap(&other->sourcepartyid_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  targetethereumaddress_.Swap(&other->targetethereumaddress_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  referencenonce_.Swap(&other->referencenonce_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
}

::google::protobuf::Metadata ERC20Withdrawal::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_proto_2fchain_5fevents_2eproto);
  return ::file_level_metadata_proto_2fchain_5fevents_2eproto[kIndexInFileMessages];
}


// ===================================================================

void ERC20Event::InitAsDefaultInstance() {
  ::vega::_ERC20Event_default_instance_.assetlist_ = const_cast< ::vega::ERC20AssetList*>(
      ::vega::ERC20AssetList::internal_default_instance());
  ::vega::_ERC20Event_default_instance_.assetdelist_ = const_cast< ::vega::ERC20AssetDelist*>(
      ::vega::ERC20AssetDelist::internal_default_instance());
  ::vega::_ERC20Event_default_instance_.deposit_ = const_cast< ::vega::ERC20Deposit*>(
      ::vega::ERC20Deposit::internal_default_instance());
  ::vega::_ERC20Event_default_instance_.withdrawal_ = const_cast< ::vega::ERC20Withdrawal*>(
      ::vega::ERC20Withdrawal::internal_default_instance());
}
class ERC20Event::HasBitSetters {
 public:
  static const ::vega::ERC20AssetList& assetlist(const ERC20Event* msg);
  static const ::vega::ERC20AssetDelist& assetdelist(const ERC20Event* msg);
  static const ::vega::ERC20Deposit& deposit(const ERC20Event* msg);
  static const ::vega::ERC20Withdrawal& withdrawal(const ERC20Event* msg);
};

const ::vega::ERC20AssetList&
ERC20Event::HasBitSetters::assetlist(const ERC20Event* msg) {
  return *msg->action_.assetlist_;
}
const ::vega::ERC20AssetDelist&
ERC20Event::HasBitSetters::assetdelist(const ERC20Event* msg) {
  return *msg->action_.assetdelist_;
}
const ::vega::ERC20Deposit&
ERC20Event::HasBitSetters::deposit(const ERC20Event* msg) {
  return *msg->action_.deposit_;
}
const ::vega::ERC20Withdrawal&
ERC20Event::HasBitSetters::withdrawal(const ERC20Event* msg) {
  return *msg->action_.withdrawal_;
}
void ERC20Event::set_allocated_assetlist(::vega::ERC20AssetList* assetlist) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  clear_action();
  if (assetlist) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      assetlist = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, assetlist, submessage_arena);
    }
    set_has_assetlist();
    action_.assetlist_ = assetlist;
  }
  // @@protoc_insertion_point(field_set_allocated:vega.ERC20Event.assetList)
}
void ERC20Event::set_allocated_assetdelist(::vega::ERC20AssetDelist* assetdelist) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  clear_action();
  if (assetdelist) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      assetdelist = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, assetdelist, submessage_arena);
    }
    set_has_assetdelist();
    action_.assetdelist_ = assetdelist;
  }
  // @@protoc_insertion_point(field_set_allocated:vega.ERC20Event.assetDelist)
}
void ERC20Event::set_allocated_deposit(::vega::ERC20Deposit* deposit) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  clear_action();
  if (deposit) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      deposit = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, deposit, submessage_arena);
    }
    set_has_deposit();
    action_.deposit_ = deposit;
  }
  // @@protoc_insertion_point(field_set_allocated:vega.ERC20Event.deposit)
}
void ERC20Event::set_allocated_withdrawal(::vega::ERC20Withdrawal* withdrawal) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  clear_action();
  if (withdrawal) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      withdrawal = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, withdrawal, submessage_arena);
    }
    set_has_withdrawal();
    action_.withdrawal_ = withdrawal;
  }
  // @@protoc_insertion_point(field_set_allocated:vega.ERC20Event.withdrawal)
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ERC20Event::kIndexFieldNumber;
const int ERC20Event::kBlockFieldNumber;
const int ERC20Event::kAssetListFieldNumber;
const int ERC20Event::kAssetDelistFieldNumber;
const int ERC20Event::kDepositFieldNumber;
const int ERC20Event::kWithdrawalFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ERC20Event::ERC20Event()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:vega.ERC20Event)
}
ERC20Event::ERC20Event(const ERC20Event& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&index_, &from.index_,
    static_cast<size_t>(reinterpret_cast<char*>(&block_) -
    reinterpret_cast<char*>(&index_)) + sizeof(block_));
  clear_has_action();
  switch (from.action_case()) {
    case kAssetList: {
      mutable_assetlist()->::vega::ERC20AssetList::MergeFrom(from.assetlist());
      break;
    }
    case kAssetDelist: {
      mutable_assetdelist()->::vega::ERC20AssetDelist::MergeFrom(from.assetdelist());
      break;
    }
    case kDeposit: {
      mutable_deposit()->::vega::ERC20Deposit::MergeFrom(from.deposit());
      break;
    }
    case kWithdrawal: {
      mutable_withdrawal()->::vega::ERC20Withdrawal::MergeFrom(from.withdrawal());
      break;
    }
    case ACTION_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:vega.ERC20Event)
}

void ERC20Event::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_ERC20Event_proto_2fchain_5fevents_2eproto.base);
  ::memset(&index_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&block_) -
      reinterpret_cast<char*>(&index_)) + sizeof(block_));
  clear_has_action();
}

ERC20Event::~ERC20Event() {
  // @@protoc_insertion_point(destructor:vega.ERC20Event)
  SharedDtor();
}

void ERC20Event::SharedDtor() {
  if (has_action()) {
    clear_action();
  }
}

void ERC20Event::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ERC20Event& ERC20Event::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_ERC20Event_proto_2fchain_5fevents_2eproto.base);
  return *internal_default_instance();
}


void ERC20Event::clear_action() {
// @@protoc_insertion_point(one_of_clear_start:vega.ERC20Event)
  switch (action_case()) {
    case kAssetList: {
      delete action_.assetlist_;
      break;
    }
    case kAssetDelist: {
      delete action_.assetdelist_;
      break;
    }
    case kDeposit: {
      delete action_.deposit_;
      break;
    }
    case kWithdrawal: {
      delete action_.withdrawal_;
      break;
    }
    case ACTION_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = ACTION_NOT_SET;
}


void ERC20Event::Clear() {
// @@protoc_insertion_point(message_clear_start:vega.ERC20Event)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&index_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&block_) -
      reinterpret_cast<char*>(&index_)) + sizeof(block_));
  clear_action();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* ERC20Event::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<ERC20Event*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // uint64 index = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        msg->set_index(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // uint64 block = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 16) goto handle_unusual;
        msg->set_block(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // .vega.ERC20AssetList assetList = 1001;
      case 1001: {
        if (static_cast<::google::protobuf::uint8>(tag) != 74) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::vega::ERC20AssetList::_InternalParse;
        object = msg->mutable_assetlist();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // .vega.ERC20AssetDelist assetDelist = 1002;
      case 1002: {
        if (static_cast<::google::protobuf::uint8>(tag) != 82) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::vega::ERC20AssetDelist::_InternalParse;
        object = msg->mutable_assetdelist();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // .vega.ERC20Deposit deposit = 1003;
      case 1003: {
        if (static_cast<::google::protobuf::uint8>(tag) != 90) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::vega::ERC20Deposit::_InternalParse;
        object = msg->mutable_deposit();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // .vega.ERC20Withdrawal withdrawal = 1004;
      case 1004: {
        if (static_cast<::google::protobuf::uint8>(tag) != 98) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::vega::ERC20Withdrawal::_InternalParse;
        object = msg->mutable_withdrawal();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool ERC20Event::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vega.ERC20Event)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(16383u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // uint64 index = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &index_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // uint64 block = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (16 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &block_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .vega.ERC20AssetList assetList = 1001;
      case 1001: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8010 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_assetlist()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .vega.ERC20AssetDelist assetDelist = 1002;
      case 1002: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8018 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_assetdelist()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .vega.ERC20Deposit deposit = 1003;
      case 1003: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8026 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_deposit()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .vega.ERC20Withdrawal withdrawal = 1004;
      case 1004: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8034 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_withdrawal()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vega.ERC20Event)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vega.ERC20Event)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void ERC20Event::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vega.ERC20Event)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 index = 1;
  if (this->index() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->index(), output);
  }

  // uint64 block = 2;
  if (this->block() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->block(), output);
  }

  // .vega.ERC20AssetList assetList = 1001;
  if (has_assetlist()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1001, HasBitSetters::assetlist(this), output);
  }

  // .vega.ERC20AssetDelist assetDelist = 1002;
  if (has_assetdelist()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1002, HasBitSetters::assetdelist(this), output);
  }

  // .vega.ERC20Deposit deposit = 1003;
  if (has_deposit()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1003, HasBitSetters::deposit(this), output);
  }

  // .vega.ERC20Withdrawal withdrawal = 1004;
  if (has_withdrawal()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1004, HasBitSetters::withdrawal(this), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:vega.ERC20Event)
}

::google::protobuf::uint8* ERC20Event::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:vega.ERC20Event)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 index = 1;
  if (this->index() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(1, this->index(), target);
  }

  // uint64 block = 2;
  if (this->block() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(2, this->block(), target);
  }

  // .vega.ERC20AssetList assetList = 1001;
  if (has_assetlist()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1001, HasBitSetters::assetlist(this), target);
  }

  // .vega.ERC20AssetDelist assetDelist = 1002;
  if (has_assetdelist()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1002, HasBitSetters::assetdelist(this), target);
  }

  // .vega.ERC20Deposit deposit = 1003;
  if (has_deposit()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1003, HasBitSetters::deposit(this), target);
  }

  // .vega.ERC20Withdrawal withdrawal = 1004;
  if (has_withdrawal()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1004, HasBitSetters::withdrawal(this), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vega.ERC20Event)
  return target;
}

size_t ERC20Event::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vega.ERC20Event)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint64 index = 1;
  if (this->index() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->index());
  }

  // uint64 block = 2;
  if (this->block() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->block());
  }

  switch (action_case()) {
    // .vega.ERC20AssetList assetList = 1001;
    case kAssetList: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *action_.assetlist_);
      break;
    }
    // .vega.ERC20AssetDelist assetDelist = 1002;
    case kAssetDelist: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *action_.assetdelist_);
      break;
    }
    // .vega.ERC20Deposit deposit = 1003;
    case kDeposit: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *action_.deposit_);
      break;
    }
    // .vega.ERC20Withdrawal withdrawal = 1004;
    case kWithdrawal: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *action_.withdrawal_);
      break;
    }
    case ACTION_NOT_SET: {
      break;
    }
  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ERC20Event::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:vega.ERC20Event)
  GOOGLE_DCHECK_NE(&from, this);
  const ERC20Event* source =
      ::google::protobuf::DynamicCastToGenerated<ERC20Event>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:vega.ERC20Event)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:vega.ERC20Event)
    MergeFrom(*source);
  }
}

void ERC20Event::MergeFrom(const ERC20Event& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vega.ERC20Event)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.index() != 0) {
    set_index(from.index());
  }
  if (from.block() != 0) {
    set_block(from.block());
  }
  switch (from.action_case()) {
    case kAssetList: {
      mutable_assetlist()->::vega::ERC20AssetList::MergeFrom(from.assetlist());
      break;
    }
    case kAssetDelist: {
      mutable_assetdelist()->::vega::ERC20AssetDelist::MergeFrom(from.assetdelist());
      break;
    }
    case kDeposit: {
      mutable_deposit()->::vega::ERC20Deposit::MergeFrom(from.deposit());
      break;
    }
    case kWithdrawal: {
      mutable_withdrawal()->::vega::ERC20Withdrawal::MergeFrom(from.withdrawal());
      break;
    }
    case ACTION_NOT_SET: {
      break;
    }
  }
}

void ERC20Event::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:vega.ERC20Event)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ERC20Event::CopyFrom(const ERC20Event& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vega.ERC20Event)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ERC20Event::IsInitialized() const {
  return true;
}

void ERC20Event::Swap(ERC20Event* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ERC20Event::InternalSwap(ERC20Event* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(index_, other->index_);
  swap(block_, other->block_);
  swap(action_, other->action_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

::google::protobuf::Metadata ERC20Event::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_proto_2fchain_5fevents_2eproto);
  return ::file_level_metadata_proto_2fchain_5fevents_2eproto[kIndexInFileMessages];
}


// ===================================================================

void BTCDeposit::InitAsDefaultInstance() {
}
class BTCDeposit::HasBitSetters {
 public:
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int BTCDeposit::kVegaAssetIDFieldNumber;
const int BTCDeposit::kSourceBTCAddressFieldNumber;
const int BTCDeposit::kTargetPartyIdFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

BTCDeposit::BTCDeposit()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:vega.BTCDeposit)
}
BTCDeposit::BTCDeposit(const BTCDeposit& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  vegaassetid_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.vegaassetid().size() > 0) {
    vegaassetid_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.vegaassetid_);
  }
  sourcebtcaddress_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.sourcebtcaddress().size() > 0) {
    sourcebtcaddress_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.sourcebtcaddress_);
  }
  targetpartyid_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.targetpartyid().size() > 0) {
    targetpartyid_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.targetpartyid_);
  }
  // @@protoc_insertion_point(copy_constructor:vega.BTCDeposit)
}

void BTCDeposit::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_BTCDeposit_proto_2fchain_5fevents_2eproto.base);
  vegaassetid_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  sourcebtcaddress_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  targetpartyid_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

BTCDeposit::~BTCDeposit() {
  // @@protoc_insertion_point(destructor:vega.BTCDeposit)
  SharedDtor();
}

void BTCDeposit::SharedDtor() {
  vegaassetid_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  sourcebtcaddress_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  targetpartyid_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void BTCDeposit::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const BTCDeposit& BTCDeposit::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_BTCDeposit_proto_2fchain_5fevents_2eproto.base);
  return *internal_default_instance();
}


void BTCDeposit::Clear() {
// @@protoc_insertion_point(message_clear_start:vega.BTCDeposit)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  vegaassetid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  sourcebtcaddress_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  targetpartyid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* BTCDeposit::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<BTCDeposit*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // string vegaAssetID = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ctx->extra_parse_data().SetFieldName("vega.BTCDeposit.vegaAssetID");
        object = msg->mutable_vegaassetid();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParserUTF8;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheckUTF8(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      // string sourceBTCAddress = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ctx->extra_parse_data().SetFieldName("vega.BTCDeposit.sourceBTCAddress");
        object = msg->mutable_sourcebtcaddress();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParserUTF8;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheckUTF8(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      // string targetPartyId = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 26) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ctx->extra_parse_data().SetFieldName("vega.BTCDeposit.targetPartyId");
        object = msg->mutable_targetpartyid();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParserUTF8;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheckUTF8(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
string_till_end:
  static_cast<::std::string*>(object)->clear();
  static_cast<::std::string*>(object)->reserve(size);
  goto len_delim_till_end;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool BTCDeposit::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vega.BTCDeposit)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // string vegaAssetID = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_vegaassetid()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->vegaassetid().data(), static_cast<int>(this->vegaassetid().length()),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "vega.BTCDeposit.vegaAssetID"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // string sourceBTCAddress = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_sourcebtcaddress()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->sourcebtcaddress().data(), static_cast<int>(this->sourcebtcaddress().length()),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "vega.BTCDeposit.sourceBTCAddress"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // string targetPartyId = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (26 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_targetpartyid()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->targetpartyid().data(), static_cast<int>(this->targetpartyid().length()),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "vega.BTCDeposit.targetPartyId"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vega.BTCDeposit)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vega.BTCDeposit)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void BTCDeposit::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vega.BTCDeposit)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // string vegaAssetID = 1;
  if (this->vegaassetid().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->vegaassetid().data(), static_cast<int>(this->vegaassetid().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "vega.BTCDeposit.vegaAssetID");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->vegaassetid(), output);
  }

  // string sourceBTCAddress = 2;
  if (this->sourcebtcaddress().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->sourcebtcaddress().data(), static_cast<int>(this->sourcebtcaddress().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "vega.BTCDeposit.sourceBTCAddress");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->sourcebtcaddress(), output);
  }

  // string targetPartyId = 3;
  if (this->targetpartyid().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->targetpartyid().data(), static_cast<int>(this->targetpartyid().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "vega.BTCDeposit.targetPartyId");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->targetpartyid(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:vega.BTCDeposit)
}

::google::protobuf::uint8* BTCDeposit::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:vega.BTCDeposit)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // string vegaAssetID = 1;
  if (this->vegaassetid().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->vegaassetid().data(), static_cast<int>(this->vegaassetid().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "vega.BTCDeposit.vegaAssetID");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->vegaassetid(), target);
  }

  // string sourceBTCAddress = 2;
  if (this->sourcebtcaddress().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->sourcebtcaddress().data(), static_cast<int>(this->sourcebtcaddress().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "vega.BTCDeposit.sourceBTCAddress");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->sourcebtcaddress(), target);
  }

  // string targetPartyId = 3;
  if (this->targetpartyid().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->targetpartyid().data(), static_cast<int>(this->targetpartyid().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "vega.BTCDeposit.targetPartyId");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->targetpartyid(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vega.BTCDeposit)
  return target;
}

size_t BTCDeposit::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vega.BTCDeposit)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string vegaAssetID = 1;
  if (this->vegaassetid().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->vegaassetid());
  }

  // string sourceBTCAddress = 2;
  if (this->sourcebtcaddress().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->sourcebtcaddress());
  }

  // string targetPartyId = 3;
  if (this->targetpartyid().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->targetpartyid());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void BTCDeposit::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:vega.BTCDeposit)
  GOOGLE_DCHECK_NE(&from, this);
  const BTCDeposit* source =
      ::google::protobuf::DynamicCastToGenerated<BTCDeposit>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:vega.BTCDeposit)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:vega.BTCDeposit)
    MergeFrom(*source);
  }
}

void BTCDeposit::MergeFrom(const BTCDeposit& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vega.BTCDeposit)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.vegaassetid().size() > 0) {

    vegaassetid_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.vegaassetid_);
  }
  if (from.sourcebtcaddress().size() > 0) {

    sourcebtcaddress_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.sourcebtcaddress_);
  }
  if (from.targetpartyid().size() > 0) {

    targetpartyid_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.targetpartyid_);
  }
}

void BTCDeposit::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:vega.BTCDeposit)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void BTCDeposit::CopyFrom(const BTCDeposit& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vega.BTCDeposit)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BTCDeposit::IsInitialized() const {
  return true;
}

void BTCDeposit::Swap(BTCDeposit* other) {
  if (other == this) return;
  InternalSwap(other);
}
void BTCDeposit::InternalSwap(BTCDeposit* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  vegaassetid_.Swap(&other->vegaassetid_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  sourcebtcaddress_.Swap(&other->sourcebtcaddress_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  targetpartyid_.Swap(&other->targetpartyid_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
}

::google::protobuf::Metadata BTCDeposit::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_proto_2fchain_5fevents_2eproto);
  return ::file_level_metadata_proto_2fchain_5fevents_2eproto[kIndexInFileMessages];
}


// ===================================================================

void BTCWithdrawal::InitAsDefaultInstance() {
}
class BTCWithdrawal::HasBitSetters {
 public:
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int BTCWithdrawal::kVegaAssetIDFieldNumber;
const int BTCWithdrawal::kSourcePartyIdFieldNumber;
const int BTCWithdrawal::kTargetBTCAddressFieldNumber;
const int BTCWithdrawal::kReferenceNonceFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

BTCWithdrawal::BTCWithdrawal()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:vega.BTCWithdrawal)
}
BTCWithdrawal::BTCWithdrawal(const BTCWithdrawal& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  vegaassetid_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.vegaassetid().size() > 0) {
    vegaassetid_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.vegaassetid_);
  }
  sourcepartyid_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.sourcepartyid().size() > 0) {
    sourcepartyid_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.sourcepartyid_);
  }
  targetbtcaddress_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.targetbtcaddress().size() > 0) {
    targetbtcaddress_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.targetbtcaddress_);
  }
  referencenonce_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.referencenonce().size() > 0) {
    referencenonce_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.referencenonce_);
  }
  // @@protoc_insertion_point(copy_constructor:vega.BTCWithdrawal)
}

void BTCWithdrawal::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_BTCWithdrawal_proto_2fchain_5fevents_2eproto.base);
  vegaassetid_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  sourcepartyid_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  targetbtcaddress_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  referencenonce_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

BTCWithdrawal::~BTCWithdrawal() {
  // @@protoc_insertion_point(destructor:vega.BTCWithdrawal)
  SharedDtor();
}

void BTCWithdrawal::SharedDtor() {
  vegaassetid_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  sourcepartyid_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  targetbtcaddress_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  referencenonce_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void BTCWithdrawal::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const BTCWithdrawal& BTCWithdrawal::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_BTCWithdrawal_proto_2fchain_5fevents_2eproto.base);
  return *internal_default_instance();
}


void BTCWithdrawal::Clear() {
// @@protoc_insertion_point(message_clear_start:vega.BTCWithdrawal)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  vegaassetid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  sourcepartyid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  targetbtcaddress_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  referencenonce_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* BTCWithdrawal::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<BTCWithdrawal*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // string vegaAssetID = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ctx->extra_parse_data().SetFieldName("vega.BTCWithdrawal.vegaAssetID");
        object = msg->mutable_vegaassetid();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParserUTF8;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheckUTF8(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      // string sourcePartyId = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ctx->extra_parse_data().SetFieldName("vega.BTCWithdrawal.sourcePartyId");
        object = msg->mutable_sourcepartyid();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParserUTF8;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheckUTF8(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      // string targetBTCAddress = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 26) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ctx->extra_parse_data().SetFieldName("vega.BTCWithdrawal.targetBTCAddress");
        object = msg->mutable_targetbtcaddress();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParserUTF8;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheckUTF8(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      // string referenceNonce = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 34) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ctx->extra_parse_data().SetFieldName("vega.BTCWithdrawal.referenceNonce");
        object = msg->mutable_referencenonce();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParserUTF8;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheckUTF8(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
string_till_end:
  static_cast<::std::string*>(object)->clear();
  static_cast<::std::string*>(object)->reserve(size);
  goto len_delim_till_end;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool BTCWithdrawal::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vega.BTCWithdrawal)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // string vegaAssetID = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_vegaassetid()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->vegaassetid().data(), static_cast<int>(this->vegaassetid().length()),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "vega.BTCWithdrawal.vegaAssetID"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // string sourcePartyId = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_sourcepartyid()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->sourcepartyid().data(), static_cast<int>(this->sourcepartyid().length()),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "vega.BTCWithdrawal.sourcePartyId"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // string targetBTCAddress = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (26 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_targetbtcaddress()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->targetbtcaddress().data(), static_cast<int>(this->targetbtcaddress().length()),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "vega.BTCWithdrawal.targetBTCAddress"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // string referenceNonce = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (34 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_referencenonce()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->referencenonce().data(), static_cast<int>(this->referencenonce().length()),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "vega.BTCWithdrawal.referenceNonce"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vega.BTCWithdrawal)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vega.BTCWithdrawal)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void BTCWithdrawal::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vega.BTCWithdrawal)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // string vegaAssetID = 1;
  if (this->vegaassetid().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->vegaassetid().data(), static_cast<int>(this->vegaassetid().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "vega.BTCWithdrawal.vegaAssetID");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->vegaassetid(), output);
  }

  // string sourcePartyId = 2;
  if (this->sourcepartyid().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->sourcepartyid().data(), static_cast<int>(this->sourcepartyid().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "vega.BTCWithdrawal.sourcePartyId");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->sourcepartyid(), output);
  }

  // string targetBTCAddress = 3;
  if (this->targetbtcaddress().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->targetbtcaddress().data(), static_cast<int>(this->targetbtcaddress().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "vega.BTCWithdrawal.targetBTCAddress");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->targetbtcaddress(), output);
  }

  // string referenceNonce = 4;
  if (this->referencenonce().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->referencenonce().data(), static_cast<int>(this->referencenonce().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "vega.BTCWithdrawal.referenceNonce");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->referencenonce(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:vega.BTCWithdrawal)
}

::google::protobuf::uint8* BTCWithdrawal::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:vega.BTCWithdrawal)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // string vegaAssetID = 1;
  if (this->vegaassetid().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->vegaassetid().data(), static_cast<int>(this->vegaassetid().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "vega.BTCWithdrawal.vegaAssetID");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->vegaassetid(), target);
  }

  // string sourcePartyId = 2;
  if (this->sourcepartyid().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->sourcepartyid().data(), static_cast<int>(this->sourcepartyid().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "vega.BTCWithdrawal.sourcePartyId");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->sourcepartyid(), target);
  }

  // string targetBTCAddress = 3;
  if (this->targetbtcaddress().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->targetbtcaddress().data(), static_cast<int>(this->targetbtcaddress().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "vega.BTCWithdrawal.targetBTCAddress");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->targetbtcaddress(), target);
  }

  // string referenceNonce = 4;
  if (this->referencenonce().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->referencenonce().data(), static_cast<int>(this->referencenonce().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "vega.BTCWithdrawal.referenceNonce");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->referencenonce(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vega.BTCWithdrawal)
  return target;
}

size_t BTCWithdrawal::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vega.BTCWithdrawal)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string vegaAssetID = 1;
  if (this->vegaassetid().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->vegaassetid());
  }

  // string sourcePartyId = 2;
  if (this->sourcepartyid().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->sourcepartyid());
  }

  // string targetBTCAddress = 3;
  if (this->targetbtcaddress().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->targetbtcaddress());
  }

  // string referenceNonce = 4;
  if (this->referencenonce().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->referencenonce());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void BTCWithdrawal::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:vega.BTCWithdrawal)
  GOOGLE_DCHECK_NE(&from, this);
  const BTCWithdrawal* source =
      ::google::protobuf::DynamicCastToGenerated<BTCWithdrawal>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:vega.BTCWithdrawal)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:vega.BTCWithdrawal)
    MergeFrom(*source);
  }
}

void BTCWithdrawal::MergeFrom(const BTCWithdrawal& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vega.BTCWithdrawal)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.vegaassetid().size() > 0) {

    vegaassetid_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.vegaassetid_);
  }
  if (from.sourcepartyid().size() > 0) {

    sourcepartyid_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.sourcepartyid_);
  }
  if (from.targetbtcaddress().size() > 0) {

    targetbtcaddress_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.targetbtcaddress_);
  }
  if (from.referencenonce().size() > 0) {

    referencenonce_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.referencenonce_);
  }
}

void BTCWithdrawal::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:vega.BTCWithdrawal)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void BTCWithdrawal::CopyFrom(const BTCWithdrawal& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vega.BTCWithdrawal)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BTCWithdrawal::IsInitialized() const {
  return true;
}

void BTCWithdrawal::Swap(BTCWithdrawal* other) {
  if (other == this) return;
  InternalSwap(other);
}
void BTCWithdrawal::InternalSwap(BTCWithdrawal* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  vegaassetid_.Swap(&other->vegaassetid_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  sourcepartyid_.Swap(&other->sourcepartyid_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  targetbtcaddress_.Swap(&other->targetbtcaddress_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  referencenonce_.Swap(&other->referencenonce_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
}

::google::protobuf::Metadata BTCWithdrawal::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_proto_2fchain_5fevents_2eproto);
  return ::file_level_metadata_proto_2fchain_5fevents_2eproto[kIndexInFileMessages];
}


// ===================================================================

void BTCEvent::InitAsDefaultInstance() {
  ::vega::_BTCEvent_default_instance_.deposit_ = const_cast< ::vega::BTCDeposit*>(
      ::vega::BTCDeposit::internal_default_instance());
  ::vega::_BTCEvent_default_instance_.withdrawal_ = const_cast< ::vega::BTCWithdrawal*>(
      ::vega::BTCWithdrawal::internal_default_instance());
}
class BTCEvent::HasBitSetters {
 public:
  static const ::vega::BTCDeposit& deposit(const BTCEvent* msg);
  static const ::vega::BTCWithdrawal& withdrawal(const BTCEvent* msg);
};

const ::vega::BTCDeposit&
BTCEvent::HasBitSetters::deposit(const BTCEvent* msg) {
  return *msg->action_.deposit_;
}
const ::vega::BTCWithdrawal&
BTCEvent::HasBitSetters::withdrawal(const BTCEvent* msg) {
  return *msg->action_.withdrawal_;
}
void BTCEvent::set_allocated_deposit(::vega::BTCDeposit* deposit) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  clear_action();
  if (deposit) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      deposit = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, deposit, submessage_arena);
    }
    set_has_deposit();
    action_.deposit_ = deposit;
  }
  // @@protoc_insertion_point(field_set_allocated:vega.BTCEvent.deposit)
}
void BTCEvent::set_allocated_withdrawal(::vega::BTCWithdrawal* withdrawal) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  clear_action();
  if (withdrawal) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      withdrawal = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, withdrawal, submessage_arena);
    }
    set_has_withdrawal();
    action_.withdrawal_ = withdrawal;
  }
  // @@protoc_insertion_point(field_set_allocated:vega.BTCEvent.withdrawal)
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int BTCEvent::kIndexFieldNumber;
const int BTCEvent::kBlockFieldNumber;
const int BTCEvent::kDepositFieldNumber;
const int BTCEvent::kWithdrawalFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

BTCEvent::BTCEvent()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:vega.BTCEvent)
}
BTCEvent::BTCEvent(const BTCEvent& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&index_, &from.index_,
    static_cast<size_t>(reinterpret_cast<char*>(&block_) -
    reinterpret_cast<char*>(&index_)) + sizeof(block_));
  clear_has_action();
  switch (from.action_case()) {
    case kDeposit: {
      mutable_deposit()->::vega::BTCDeposit::MergeFrom(from.deposit());
      break;
    }
    case kWithdrawal: {
      mutable_withdrawal()->::vega::BTCWithdrawal::MergeFrom(from.withdrawal());
      break;
    }
    case ACTION_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:vega.BTCEvent)
}

void BTCEvent::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_BTCEvent_proto_2fchain_5fevents_2eproto.base);
  ::memset(&index_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&block_) -
      reinterpret_cast<char*>(&index_)) + sizeof(block_));
  clear_has_action();
}

BTCEvent::~BTCEvent() {
  // @@protoc_insertion_point(destructor:vega.BTCEvent)
  SharedDtor();
}

void BTCEvent::SharedDtor() {
  if (has_action()) {
    clear_action();
  }
}

void BTCEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const BTCEvent& BTCEvent::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_BTCEvent_proto_2fchain_5fevents_2eproto.base);
  return *internal_default_instance();
}


void BTCEvent::clear_action() {
// @@protoc_insertion_point(one_of_clear_start:vega.BTCEvent)
  switch (action_case()) {
    case kDeposit: {
      delete action_.deposit_;
      break;
    }
    case kWithdrawal: {
      delete action_.withdrawal_;
      break;
    }
    case ACTION_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = ACTION_NOT_SET;
}


void BTCEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:vega.BTCEvent)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&index_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&block_) -
      reinterpret_cast<char*>(&index_)) + sizeof(block_));
  clear_action();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* BTCEvent::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<BTCEvent*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // uint64 index = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        msg->set_index(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // uint64 block = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 16) goto handle_unusual;
        msg->set_block(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // .vega.BTCDeposit deposit = 1001;
      case 1001: {
        if (static_cast<::google::protobuf::uint8>(tag) != 74) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::vega::BTCDeposit::_InternalParse;
        object = msg->mutable_deposit();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // .vega.BTCWithdrawal withdrawal = 1002;
      case 1002: {
        if (static_cast<::google::protobuf::uint8>(tag) != 82) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::vega::BTCWithdrawal::_InternalParse;
        object = msg->mutable_withdrawal();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool BTCEvent::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vega.BTCEvent)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(16383u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // uint64 index = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &index_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // uint64 block = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (16 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &block_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .vega.BTCDeposit deposit = 1001;
      case 1001: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8010 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_deposit()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .vega.BTCWithdrawal withdrawal = 1002;
      case 1002: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8018 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_withdrawal()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vega.BTCEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vega.BTCEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void BTCEvent::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vega.BTCEvent)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 index = 1;
  if (this->index() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->index(), output);
  }

  // uint64 block = 2;
  if (this->block() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->block(), output);
  }

  // .vega.BTCDeposit deposit = 1001;
  if (has_deposit()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1001, HasBitSetters::deposit(this), output);
  }

  // .vega.BTCWithdrawal withdrawal = 1002;
  if (has_withdrawal()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1002, HasBitSetters::withdrawal(this), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:vega.BTCEvent)
}

::google::protobuf::uint8* BTCEvent::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:vega.BTCEvent)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 index = 1;
  if (this->index() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(1, this->index(), target);
  }

  // uint64 block = 2;
  if (this->block() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(2, this->block(), target);
  }

  // .vega.BTCDeposit deposit = 1001;
  if (has_deposit()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1001, HasBitSetters::deposit(this), target);
  }

  // .vega.BTCWithdrawal withdrawal = 1002;
  if (has_withdrawal()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1002, HasBitSetters::withdrawal(this), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vega.BTCEvent)
  return target;
}

size_t BTCEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vega.BTCEvent)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint64 index = 1;
  if (this->index() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->index());
  }

  // uint64 block = 2;
  if (this->block() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->block());
  }

  switch (action_case()) {
    // .vega.BTCDeposit deposit = 1001;
    case kDeposit: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *action_.deposit_);
      break;
    }
    // .vega.BTCWithdrawal withdrawal = 1002;
    case kWithdrawal: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *action_.withdrawal_);
      break;
    }
    case ACTION_NOT_SET: {
      break;
    }
  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void BTCEvent::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:vega.BTCEvent)
  GOOGLE_DCHECK_NE(&from, this);
  const BTCEvent* source =
      ::google::protobuf::DynamicCastToGenerated<BTCEvent>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:vega.BTCEvent)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:vega.BTCEvent)
    MergeFrom(*source);
  }
}

void BTCEvent::MergeFrom(const BTCEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vega.BTCEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.index() != 0) {
    set_index(from.index());
  }
  if (from.block() != 0) {
    set_block(from.block());
  }
  switch (from.action_case()) {
    case kDeposit: {
      mutable_deposit()->::vega::BTCDeposit::MergeFrom(from.deposit());
      break;
    }
    case kWithdrawal: {
      mutable_withdrawal()->::vega::BTCWithdrawal::MergeFrom(from.withdrawal());
      break;
    }
    case ACTION_NOT_SET: {
      break;
    }
  }
}

void BTCEvent::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:vega.BTCEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void BTCEvent::CopyFrom(const BTCEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vega.BTCEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BTCEvent::IsInitialized() const {
  return true;
}

void BTCEvent::Swap(BTCEvent* other) {
  if (other == this) return;
  InternalSwap(other);
}
void BTCEvent::InternalSwap(BTCEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(index_, other->index_);
  swap(block_, other->block_);
  swap(action_, other->action_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

::google::protobuf::Metadata BTCEvent::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_proto_2fchain_5fevents_2eproto);
  return ::file_level_metadata_proto_2fchain_5fevents_2eproto[kIndexInFileMessages];
}


// ===================================================================

void EthereumAddress::InitAsDefaultInstance() {
}
class EthereumAddress::HasBitSetters {
 public:
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int EthereumAddress::kAddressFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

EthereumAddress::EthereumAddress()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:vega.EthereumAddress)
}
EthereumAddress::EthereumAddress(const EthereumAddress& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  address_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.address().size() > 0) {
    address_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.address_);
  }
  // @@protoc_insertion_point(copy_constructor:vega.EthereumAddress)
}

void EthereumAddress::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_EthereumAddress_proto_2fchain_5fevents_2eproto.base);
  address_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

EthereumAddress::~EthereumAddress() {
  // @@protoc_insertion_point(destructor:vega.EthereumAddress)
  SharedDtor();
}

void EthereumAddress::SharedDtor() {
  address_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void EthereumAddress::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const EthereumAddress& EthereumAddress::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_EthereumAddress_proto_2fchain_5fevents_2eproto.base);
  return *internal_default_instance();
}


void EthereumAddress::Clear() {
// @@protoc_insertion_point(message_clear_start:vega.EthereumAddress)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* EthereumAddress::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<EthereumAddress*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // string address = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ctx->extra_parse_data().SetFieldName("vega.EthereumAddress.address");
        object = msg->mutable_address();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParserUTF8;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheckUTF8(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
string_till_end:
  static_cast<::std::string*>(object)->clear();
  static_cast<::std::string*>(object)->reserve(size);
  goto len_delim_till_end;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool EthereumAddress::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vega.EthereumAddress)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // string address = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_address()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->address().data(), static_cast<int>(this->address().length()),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "vega.EthereumAddress.address"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vega.EthereumAddress)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vega.EthereumAddress)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void EthereumAddress::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vega.EthereumAddress)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // string address = 1;
  if (this->address().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->address().data(), static_cast<int>(this->address().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "vega.EthereumAddress.address");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->address(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:vega.EthereumAddress)
}

::google::protobuf::uint8* EthereumAddress::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:vega.EthereumAddress)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // string address = 1;
  if (this->address().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->address().data(), static_cast<int>(this->address().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "vega.EthereumAddress.address");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->address(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vega.EthereumAddress)
  return target;
}

size_t EthereumAddress::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vega.EthereumAddress)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string address = 1;
  if (this->address().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->address());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void EthereumAddress::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:vega.EthereumAddress)
  GOOGLE_DCHECK_NE(&from, this);
  const EthereumAddress* source =
      ::google::protobuf::DynamicCastToGenerated<EthereumAddress>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:vega.EthereumAddress)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:vega.EthereumAddress)
    MergeFrom(*source);
  }
}

void EthereumAddress::MergeFrom(const EthereumAddress& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vega.EthereumAddress)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.address().size() > 0) {

    address_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.address_);
  }
}

void EthereumAddress::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:vega.EthereumAddress)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EthereumAddress::CopyFrom(const EthereumAddress& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vega.EthereumAddress)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EthereumAddress::IsInitialized() const {
  return true;
}

void EthereumAddress::Swap(EthereumAddress* other) {
  if (other == this) return;
  InternalSwap(other);
}
void EthereumAddress::InternalSwap(EthereumAddress* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  address_.Swap(&other->address_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
}

::google::protobuf::Metadata EthereumAddress::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_proto_2fchain_5fevents_2eproto);
  return ::file_level_metadata_proto_2fchain_5fevents_2eproto[kIndexInFileMessages];
}


// ===================================================================

void BitcoinAddress::InitAsDefaultInstance() {
}
class BitcoinAddress::HasBitSetters {
 public:
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int BitcoinAddress::kAddressFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

BitcoinAddress::BitcoinAddress()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:vega.BitcoinAddress)
}
BitcoinAddress::BitcoinAddress(const BitcoinAddress& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  address_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.address().size() > 0) {
    address_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.address_);
  }
  // @@protoc_insertion_point(copy_constructor:vega.BitcoinAddress)
}

void BitcoinAddress::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_BitcoinAddress_proto_2fchain_5fevents_2eproto.base);
  address_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

BitcoinAddress::~BitcoinAddress() {
  // @@protoc_insertion_point(destructor:vega.BitcoinAddress)
  SharedDtor();
}

void BitcoinAddress::SharedDtor() {
  address_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void BitcoinAddress::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const BitcoinAddress& BitcoinAddress::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_BitcoinAddress_proto_2fchain_5fevents_2eproto.base);
  return *internal_default_instance();
}


void BitcoinAddress::Clear() {
// @@protoc_insertion_point(message_clear_start:vega.BitcoinAddress)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* BitcoinAddress::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<BitcoinAddress*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // string address = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ctx->extra_parse_data().SetFieldName("vega.BitcoinAddress.address");
        object = msg->mutable_address();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParserUTF8;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheckUTF8(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
string_till_end:
  static_cast<::std::string*>(object)->clear();
  static_cast<::std::string*>(object)->reserve(size);
  goto len_delim_till_end;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool BitcoinAddress::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vega.BitcoinAddress)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // string address = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_address()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->address().data(), static_cast<int>(this->address().length()),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "vega.BitcoinAddress.address"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vega.BitcoinAddress)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vega.BitcoinAddress)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void BitcoinAddress::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vega.BitcoinAddress)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // string address = 1;
  if (this->address().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->address().data(), static_cast<int>(this->address().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "vega.BitcoinAddress.address");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->address(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:vega.BitcoinAddress)
}

::google::protobuf::uint8* BitcoinAddress::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:vega.BitcoinAddress)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // string address = 1;
  if (this->address().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->address().data(), static_cast<int>(this->address().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "vega.BitcoinAddress.address");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->address(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vega.BitcoinAddress)
  return target;
}

size_t BitcoinAddress::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vega.BitcoinAddress)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string address = 1;
  if (this->address().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->address());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void BitcoinAddress::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:vega.BitcoinAddress)
  GOOGLE_DCHECK_NE(&from, this);
  const BitcoinAddress* source =
      ::google::protobuf::DynamicCastToGenerated<BitcoinAddress>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:vega.BitcoinAddress)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:vega.BitcoinAddress)
    MergeFrom(*source);
  }
}

void BitcoinAddress::MergeFrom(const BitcoinAddress& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vega.BitcoinAddress)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.address().size() > 0) {

    address_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.address_);
  }
}

void BitcoinAddress::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:vega.BitcoinAddress)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void BitcoinAddress::CopyFrom(const BitcoinAddress& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vega.BitcoinAddress)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BitcoinAddress::IsInitialized() const {
  return true;
}

void BitcoinAddress::Swap(BitcoinAddress* other) {
  if (other == this) return;
  InternalSwap(other);
}
void BitcoinAddress::InternalSwap(BitcoinAddress* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  address_.Swap(&other->address_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
}

::google::protobuf::Metadata BitcoinAddress::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_proto_2fchain_5fevents_2eproto);
  return ::file_level_metadata_proto_2fchain_5fevents_2eproto[kIndexInFileMessages];
}


// ===================================================================

void Identifier::InitAsDefaultInstance() {
  ::vega::_Identifier_default_instance_.ethereumaddress_ = const_cast< ::vega::EthereumAddress*>(
      ::vega::EthereumAddress::internal_default_instance());
  ::vega::_Identifier_default_instance_.bitcoinaddress_ = const_cast< ::vega::BitcoinAddress*>(
      ::vega::BitcoinAddress::internal_default_instance());
}
class Identifier::HasBitSetters {
 public:
  static const ::vega::EthereumAddress& ethereumaddress(const Identifier* msg);
  static const ::vega::BitcoinAddress& bitcoinaddress(const Identifier* msg);
};

const ::vega::EthereumAddress&
Identifier::HasBitSetters::ethereumaddress(const Identifier* msg) {
  return *msg->identifier_.ethereumaddress_;
}
const ::vega::BitcoinAddress&
Identifier::HasBitSetters::bitcoinaddress(const Identifier* msg) {
  return *msg->identifier_.bitcoinaddress_;
}
void Identifier::set_allocated_ethereumaddress(::vega::EthereumAddress* ethereumaddress) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  clear_identifier();
  if (ethereumaddress) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      ethereumaddress = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ethereumaddress, submessage_arena);
    }
    set_has_ethereumaddress();
    identifier_.ethereumaddress_ = ethereumaddress;
  }
  // @@protoc_insertion_point(field_set_allocated:vega.Identifier.ethereumAddress)
}
void Identifier::set_allocated_bitcoinaddress(::vega::BitcoinAddress* bitcoinaddress) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  clear_identifier();
  if (bitcoinaddress) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      bitcoinaddress = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, bitcoinaddress, submessage_arena);
    }
    set_has_bitcoinaddress();
    identifier_.bitcoinaddress_ = bitcoinaddress;
  }
  // @@protoc_insertion_point(field_set_allocated:vega.Identifier.bitcoinAddress)
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Identifier::kEthereumAddressFieldNumber;
const int Identifier::kBitcoinAddressFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Identifier::Identifier()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:vega.Identifier)
}
Identifier::Identifier(const Identifier& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  clear_has_identifier();
  switch (from.identifier_case()) {
    case kEthereumAddress: {
      mutable_ethereumaddress()->::vega::EthereumAddress::MergeFrom(from.ethereumaddress());
      break;
    }
    case kBitcoinAddress: {
      mutable_bitcoinaddress()->::vega::BitcoinAddress::MergeFrom(from.bitcoinaddress());
      break;
    }
    case IDENTIFIER_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:vega.Identifier)
}

void Identifier::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_Identifier_proto_2fchain_5fevents_2eproto.base);
  clear_has_identifier();
}

Identifier::~Identifier() {
  // @@protoc_insertion_point(destructor:vega.Identifier)
  SharedDtor();
}

void Identifier::SharedDtor() {
  if (has_identifier()) {
    clear_identifier();
  }
}

void Identifier::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Identifier& Identifier::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_Identifier_proto_2fchain_5fevents_2eproto.base);
  return *internal_default_instance();
}


void Identifier::clear_identifier() {
// @@protoc_insertion_point(one_of_clear_start:vega.Identifier)
  switch (identifier_case()) {
    case kEthereumAddress: {
      delete identifier_.ethereumaddress_;
      break;
    }
    case kBitcoinAddress: {
      delete identifier_.bitcoinaddress_;
      break;
    }
    case IDENTIFIER_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = IDENTIFIER_NOT_SET;
}


void Identifier::Clear() {
// @@protoc_insertion_point(message_clear_start:vega.Identifier)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_identifier();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Identifier::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<Identifier*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // .vega.EthereumAddress ethereumAddress = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::vega::EthereumAddress::_InternalParse;
        object = msg->mutable_ethereumaddress();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // .vega.BitcoinAddress bitcoinAddress = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::vega::BitcoinAddress::_InternalParse;
        object = msg->mutable_bitcoinaddress();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Identifier::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vega.Identifier)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // .vega.EthereumAddress ethereumAddress = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_ethereumaddress()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .vega.BitcoinAddress bitcoinAddress = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_bitcoinaddress()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vega.Identifier)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vega.Identifier)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Identifier::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vega.Identifier)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .vega.EthereumAddress ethereumAddress = 1;
  if (has_ethereumaddress()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, HasBitSetters::ethereumaddress(this), output);
  }

  // .vega.BitcoinAddress bitcoinAddress = 2;
  if (has_bitcoinaddress()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, HasBitSetters::bitcoinaddress(this), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:vega.Identifier)
}

::google::protobuf::uint8* Identifier::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:vega.Identifier)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .vega.EthereumAddress ethereumAddress = 1;
  if (has_ethereumaddress()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, HasBitSetters::ethereumaddress(this), target);
  }

  // .vega.BitcoinAddress bitcoinAddress = 2;
  if (has_bitcoinaddress()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, HasBitSetters::bitcoinaddress(this), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vega.Identifier)
  return target;
}

size_t Identifier::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vega.Identifier)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (identifier_case()) {
    // .vega.EthereumAddress ethereumAddress = 1;
    case kEthereumAddress: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *identifier_.ethereumaddress_);
      break;
    }
    // .vega.BitcoinAddress bitcoinAddress = 2;
    case kBitcoinAddress: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *identifier_.bitcoinaddress_);
      break;
    }
    case IDENTIFIER_NOT_SET: {
      break;
    }
  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Identifier::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:vega.Identifier)
  GOOGLE_DCHECK_NE(&from, this);
  const Identifier* source =
      ::google::protobuf::DynamicCastToGenerated<Identifier>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:vega.Identifier)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:vega.Identifier)
    MergeFrom(*source);
  }
}

void Identifier::MergeFrom(const Identifier& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vega.Identifier)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.identifier_case()) {
    case kEthereumAddress: {
      mutable_ethereumaddress()->::vega::EthereumAddress::MergeFrom(from.ethereumaddress());
      break;
    }
    case kBitcoinAddress: {
      mutable_bitcoinaddress()->::vega::BitcoinAddress::MergeFrom(from.bitcoinaddress());
      break;
    }
    case IDENTIFIER_NOT_SET: {
      break;
    }
  }
}

void Identifier::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:vega.Identifier)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Identifier::CopyFrom(const Identifier& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vega.Identifier)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Identifier::IsInitialized() const {
  return true;
}

void Identifier::Swap(Identifier* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Identifier::InternalSwap(Identifier* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(identifier_, other->identifier_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

::google::protobuf::Metadata Identifier::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_proto_2fchain_5fevents_2eproto);
  return ::file_level_metadata_proto_2fchain_5fevents_2eproto[kIndexInFileMessages];
}


// ===================================================================

void AddValidator::InitAsDefaultInstance() {
  ::vega::_AddValidator_default_instance_._instance.get_mutable()->id_ = const_cast< ::vega::Identifier*>(
      ::vega::Identifier::internal_default_instance());
}
class AddValidator::HasBitSetters {
 public:
  static const ::vega::Identifier& id(const AddValidator* msg);
};

const ::vega::Identifier&
AddValidator::HasBitSetters::id(const AddValidator* msg) {
  return *msg->id_;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int AddValidator::kIdFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

AddValidator::AddValidator()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:vega.AddValidator)
}
AddValidator::AddValidator(const AddValidator& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_id()) {
    id_ = new ::vega::Identifier(*from.id_);
  } else {
    id_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:vega.AddValidator)
}

void AddValidator::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_AddValidator_proto_2fchain_5fevents_2eproto.base);
  id_ = nullptr;
}

AddValidator::~AddValidator() {
  // @@protoc_insertion_point(destructor:vega.AddValidator)
  SharedDtor();
}

void AddValidator::SharedDtor() {
  if (this != internal_default_instance()) delete id_;
}

void AddValidator::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const AddValidator& AddValidator::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_AddValidator_proto_2fchain_5fevents_2eproto.base);
  return *internal_default_instance();
}


void AddValidator::Clear() {
// @@protoc_insertion_point(message_clear_start:vega.AddValidator)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaNoVirtual() == nullptr && id_ != nullptr) {
    delete id_;
  }
  id_ = nullptr;
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* AddValidator::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<AddValidator*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // .vega.Identifier id = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::vega::Identifier::_InternalParse;
        object = msg->mutable_id();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool AddValidator::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vega.AddValidator)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // .vega.Identifier id = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_id()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vega.AddValidator)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vega.AddValidator)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void AddValidator::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vega.AddValidator)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .vega.Identifier id = 1;
  if (this->has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, HasBitSetters::id(this), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:vega.AddValidator)
}

::google::protobuf::uint8* AddValidator::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:vega.AddValidator)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .vega.Identifier id = 1;
  if (this->has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, HasBitSetters::id(this), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vega.AddValidator)
  return target;
}

size_t AddValidator::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vega.AddValidator)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .vega.Identifier id = 1;
  if (this->has_id()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *id_);
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AddValidator::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:vega.AddValidator)
  GOOGLE_DCHECK_NE(&from, this);
  const AddValidator* source =
      ::google::protobuf::DynamicCastToGenerated<AddValidator>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:vega.AddValidator)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:vega.AddValidator)
    MergeFrom(*source);
  }
}

void AddValidator::MergeFrom(const AddValidator& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vega.AddValidator)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_id()) {
    mutable_id()->::vega::Identifier::MergeFrom(from.id());
  }
}

void AddValidator::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:vega.AddValidator)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AddValidator::CopyFrom(const AddValidator& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vega.AddValidator)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AddValidator::IsInitialized() const {
  return true;
}

void AddValidator::Swap(AddValidator* other) {
  if (other == this) return;
  InternalSwap(other);
}
void AddValidator::InternalSwap(AddValidator* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(id_, other->id_);
}

::google::protobuf::Metadata AddValidator::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_proto_2fchain_5fevents_2eproto);
  return ::file_level_metadata_proto_2fchain_5fevents_2eproto[kIndexInFileMessages];
}


// ===================================================================

void RemoveValidator::InitAsDefaultInstance() {
  ::vega::_RemoveValidator_default_instance_._instance.get_mutable()->id_ = const_cast< ::vega::Identifier*>(
      ::vega::Identifier::internal_default_instance());
}
class RemoveValidator::HasBitSetters {
 public:
  static const ::vega::Identifier& id(const RemoveValidator* msg);
};

const ::vega::Identifier&
RemoveValidator::HasBitSetters::id(const RemoveValidator* msg) {
  return *msg->id_;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int RemoveValidator::kIdFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

RemoveValidator::RemoveValidator()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:vega.RemoveValidator)
}
RemoveValidator::RemoveValidator(const RemoveValidator& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_id()) {
    id_ = new ::vega::Identifier(*from.id_);
  } else {
    id_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:vega.RemoveValidator)
}

void RemoveValidator::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_RemoveValidator_proto_2fchain_5fevents_2eproto.base);
  id_ = nullptr;
}

RemoveValidator::~RemoveValidator() {
  // @@protoc_insertion_point(destructor:vega.RemoveValidator)
  SharedDtor();
}

void RemoveValidator::SharedDtor() {
  if (this != internal_default_instance()) delete id_;
}

void RemoveValidator::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const RemoveValidator& RemoveValidator::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_RemoveValidator_proto_2fchain_5fevents_2eproto.base);
  return *internal_default_instance();
}


void RemoveValidator::Clear() {
// @@protoc_insertion_point(message_clear_start:vega.RemoveValidator)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaNoVirtual() == nullptr && id_ != nullptr) {
    delete id_;
  }
  id_ = nullptr;
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* RemoveValidator::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<RemoveValidator*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // .vega.Identifier id = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::vega::Identifier::_InternalParse;
        object = msg->mutable_id();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool RemoveValidator::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vega.RemoveValidator)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // .vega.Identifier id = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_id()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vega.RemoveValidator)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vega.RemoveValidator)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void RemoveValidator::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vega.RemoveValidator)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .vega.Identifier id = 1;
  if (this->has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, HasBitSetters::id(this), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:vega.RemoveValidator)
}

::google::protobuf::uint8* RemoveValidator::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:vega.RemoveValidator)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .vega.Identifier id = 1;
  if (this->has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, HasBitSetters::id(this), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vega.RemoveValidator)
  return target;
}

size_t RemoveValidator::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vega.RemoveValidator)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .vega.Identifier id = 1;
  if (this->has_id()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *id_);
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void RemoveValidator::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:vega.RemoveValidator)
  GOOGLE_DCHECK_NE(&from, this);
  const RemoveValidator* source =
      ::google::protobuf::DynamicCastToGenerated<RemoveValidator>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:vega.RemoveValidator)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:vega.RemoveValidator)
    MergeFrom(*source);
  }
}

void RemoveValidator::MergeFrom(const RemoveValidator& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vega.RemoveValidator)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_id()) {
    mutable_id()->::vega::Identifier::MergeFrom(from.id());
  }
}

void RemoveValidator::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:vega.RemoveValidator)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RemoveValidator::CopyFrom(const RemoveValidator& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vega.RemoveValidator)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RemoveValidator::IsInitialized() const {
  return true;
}

void RemoveValidator::Swap(RemoveValidator* other) {
  if (other == this) return;
  InternalSwap(other);
}
void RemoveValidator::InternalSwap(RemoveValidator* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(id_, other->id_);
}

::google::protobuf::Metadata RemoveValidator::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_proto_2fchain_5fevents_2eproto);
  return ::file_level_metadata_proto_2fchain_5fevents_2eproto[kIndexInFileMessages];
}


// ===================================================================

void ValidatorEvent::InitAsDefaultInstance() {
  ::vega::_ValidatorEvent_default_instance_.add_ = const_cast< ::vega::AddValidator*>(
      ::vega::AddValidator::internal_default_instance());
  ::vega::_ValidatorEvent_default_instance_.rm_ = const_cast< ::vega::RemoveValidator*>(
      ::vega::RemoveValidator::internal_default_instance());
}
class ValidatorEvent::HasBitSetters {
 public:
  static const ::vega::AddValidator& add(const ValidatorEvent* msg);
  static const ::vega::RemoveValidator& rm(const ValidatorEvent* msg);
};

const ::vega::AddValidator&
ValidatorEvent::HasBitSetters::add(const ValidatorEvent* msg) {
  return *msg->action_.add_;
}
const ::vega::RemoveValidator&
ValidatorEvent::HasBitSetters::rm(const ValidatorEvent* msg) {
  return *msg->action_.rm_;
}
void ValidatorEvent::set_allocated_add(::vega::AddValidator* add) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  clear_action();
  if (add) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      add = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, add, submessage_arena);
    }
    set_has_add();
    action_.add_ = add;
  }
  // @@protoc_insertion_point(field_set_allocated:vega.ValidatorEvent.add)
}
void ValidatorEvent::set_allocated_rm(::vega::RemoveValidator* rm) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  clear_action();
  if (rm) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      rm = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, rm, submessage_arena);
    }
    set_has_rm();
    action_.rm_ = rm;
  }
  // @@protoc_insertion_point(field_set_allocated:vega.ValidatorEvent.rm)
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ValidatorEvent::kSourceIDFieldNumber;
const int ValidatorEvent::kAddFieldNumber;
const int ValidatorEvent::kRmFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ValidatorEvent::ValidatorEvent()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:vega.ValidatorEvent)
}
ValidatorEvent::ValidatorEvent(const ValidatorEvent& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  sourceid_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.sourceid().size() > 0) {
    sourceid_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.sourceid_);
  }
  clear_has_action();
  switch (from.action_case()) {
    case kAdd: {
      mutable_add()->::vega::AddValidator::MergeFrom(from.add());
      break;
    }
    case kRm: {
      mutable_rm()->::vega::RemoveValidator::MergeFrom(from.rm());
      break;
    }
    case ACTION_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:vega.ValidatorEvent)
}

void ValidatorEvent::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_ValidatorEvent_proto_2fchain_5fevents_2eproto.base);
  sourceid_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_action();
}

ValidatorEvent::~ValidatorEvent() {
  // @@protoc_insertion_point(destructor:vega.ValidatorEvent)
  SharedDtor();
}

void ValidatorEvent::SharedDtor() {
  sourceid_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (has_action()) {
    clear_action();
  }
}

void ValidatorEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ValidatorEvent& ValidatorEvent::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_ValidatorEvent_proto_2fchain_5fevents_2eproto.base);
  return *internal_default_instance();
}


void ValidatorEvent::clear_action() {
// @@protoc_insertion_point(one_of_clear_start:vega.ValidatorEvent)
  switch (action_case()) {
    case kAdd: {
      delete action_.add_;
      break;
    }
    case kRm: {
      delete action_.rm_;
      break;
    }
    case ACTION_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = ACTION_NOT_SET;
}


void ValidatorEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:vega.ValidatorEvent)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  sourceid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_action();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* ValidatorEvent::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<ValidatorEvent*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // string sourceID = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ctx->extra_parse_data().SetFieldName("vega.ValidatorEvent.sourceID");
        object = msg->mutable_sourceid();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParserUTF8;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheckUTF8(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      // .vega.AddValidator add = 1001;
      case 1001: {
        if (static_cast<::google::protobuf::uint8>(tag) != 74) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::vega::AddValidator::_InternalParse;
        object = msg->mutable_add();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // .vega.RemoveValidator rm = 1002;
      case 1002: {
        if (static_cast<::google::protobuf::uint8>(tag) != 82) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::vega::RemoveValidator::_InternalParse;
        object = msg->mutable_rm();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
string_till_end:
  static_cast<::std::string*>(object)->clear();
  static_cast<::std::string*>(object)->reserve(size);
  goto len_delim_till_end;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool ValidatorEvent::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vega.ValidatorEvent)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(16383u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // string sourceID = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_sourceid()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->sourceid().data(), static_cast<int>(this->sourceid().length()),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "vega.ValidatorEvent.sourceID"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .vega.AddValidator add = 1001;
      case 1001: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8010 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_add()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .vega.RemoveValidator rm = 1002;
      case 1002: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8018 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_rm()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vega.ValidatorEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vega.ValidatorEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void ValidatorEvent::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vega.ValidatorEvent)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // string sourceID = 1;
  if (this->sourceid().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->sourceid().data(), static_cast<int>(this->sourceid().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "vega.ValidatorEvent.sourceID");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->sourceid(), output);
  }

  // .vega.AddValidator add = 1001;
  if (has_add()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1001, HasBitSetters::add(this), output);
  }

  // .vega.RemoveValidator rm = 1002;
  if (has_rm()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1002, HasBitSetters::rm(this), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:vega.ValidatorEvent)
}

::google::protobuf::uint8* ValidatorEvent::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:vega.ValidatorEvent)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // string sourceID = 1;
  if (this->sourceid().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->sourceid().data(), static_cast<int>(this->sourceid().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "vega.ValidatorEvent.sourceID");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->sourceid(), target);
  }

  // .vega.AddValidator add = 1001;
  if (has_add()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1001, HasBitSetters::add(this), target);
  }

  // .vega.RemoveValidator rm = 1002;
  if (has_rm()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1002, HasBitSetters::rm(this), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vega.ValidatorEvent)
  return target;
}

size_t ValidatorEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vega.ValidatorEvent)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string sourceID = 1;
  if (this->sourceid().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->sourceid());
  }

  switch (action_case()) {
    // .vega.AddValidator add = 1001;
    case kAdd: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *action_.add_);
      break;
    }
    // .vega.RemoveValidator rm = 1002;
    case kRm: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *action_.rm_);
      break;
    }
    case ACTION_NOT_SET: {
      break;
    }
  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ValidatorEvent::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:vega.ValidatorEvent)
  GOOGLE_DCHECK_NE(&from, this);
  const ValidatorEvent* source =
      ::google::protobuf::DynamicCastToGenerated<ValidatorEvent>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:vega.ValidatorEvent)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:vega.ValidatorEvent)
    MergeFrom(*source);
  }
}

void ValidatorEvent::MergeFrom(const ValidatorEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vega.ValidatorEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.sourceid().size() > 0) {

    sourceid_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.sourceid_);
  }
  switch (from.action_case()) {
    case kAdd: {
      mutable_add()->::vega::AddValidator::MergeFrom(from.add());
      break;
    }
    case kRm: {
      mutable_rm()->::vega::RemoveValidator::MergeFrom(from.rm());
      break;
    }
    case ACTION_NOT_SET: {
      break;
    }
  }
}

void ValidatorEvent::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:vega.ValidatorEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ValidatorEvent::CopyFrom(const ValidatorEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vega.ValidatorEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ValidatorEvent::IsInitialized() const {
  return true;
}

void ValidatorEvent::Swap(ValidatorEvent* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ValidatorEvent::InternalSwap(ValidatorEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  sourceid_.Swap(&other->sourceid_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(action_, other->action_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

::google::protobuf::Metadata ValidatorEvent::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_proto_2fchain_5fevents_2eproto);
  return ::file_level_metadata_proto_2fchain_5fevents_2eproto[kIndexInFileMessages];
}


// ===================================================================

void ChainEvent::InitAsDefaultInstance() {
  ::vega::_ChainEvent_default_instance_.builtin_ = const_cast< ::vega::BuiltinAssetEvent*>(
      ::vega::BuiltinAssetEvent::internal_default_instance());
  ::vega::_ChainEvent_default_instance_.erc20_ = const_cast< ::vega::ERC20Event*>(
      ::vega::ERC20Event::internal_default_instance());
  ::vega::_ChainEvent_default_instance_.btc_ = const_cast< ::vega::BTCEvent*>(
      ::vega::BTCEvent::internal_default_instance());
  ::vega::_ChainEvent_default_instance_.validator_ = const_cast< ::vega::ValidatorEvent*>(
      ::vega::ValidatorEvent::internal_default_instance());
}
class ChainEvent::HasBitSetters {
 public:
  static const ::vega::BuiltinAssetEvent& builtin(const ChainEvent* msg);
  static const ::vega::ERC20Event& erc20(const ChainEvent* msg);
  static const ::vega::BTCEvent& btc(const ChainEvent* msg);
  static const ::vega::ValidatorEvent& validator(const ChainEvent* msg);
};

const ::vega::BuiltinAssetEvent&
ChainEvent::HasBitSetters::builtin(const ChainEvent* msg) {
  return *msg->event_.builtin_;
}
const ::vega::ERC20Event&
ChainEvent::HasBitSetters::erc20(const ChainEvent* msg) {
  return *msg->event_.erc20_;
}
const ::vega::BTCEvent&
ChainEvent::HasBitSetters::btc(const ChainEvent* msg) {
  return *msg->event_.btc_;
}
const ::vega::ValidatorEvent&
ChainEvent::HasBitSetters::validator(const ChainEvent* msg) {
  return *msg->event_.validator_;
}
void ChainEvent::set_allocated_builtin(::vega::BuiltinAssetEvent* builtin) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  clear_event();
  if (builtin) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      builtin = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, builtin, submessage_arena);
    }
    set_has_builtin();
    event_.builtin_ = builtin;
  }
  // @@protoc_insertion_point(field_set_allocated:vega.ChainEvent.builtin)
}
void ChainEvent::set_allocated_erc20(::vega::ERC20Event* erc20) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  clear_event();
  if (erc20) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      erc20 = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, erc20, submessage_arena);
    }
    set_has_erc20();
    event_.erc20_ = erc20;
  }
  // @@protoc_insertion_point(field_set_allocated:vega.ChainEvent.erc20)
}
void ChainEvent::set_allocated_btc(::vega::BTCEvent* btc) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  clear_event();
  if (btc) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      btc = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, btc, submessage_arena);
    }
    set_has_btc();
    event_.btc_ = btc;
  }
  // @@protoc_insertion_point(field_set_allocated:vega.ChainEvent.btc)
}
void ChainEvent::set_allocated_validator(::vega::ValidatorEvent* validator) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  clear_event();
  if (validator) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      validator = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, validator, submessage_arena);
    }
    set_has_validator();
    event_.validator_ = validator;
  }
  // @@protoc_insertion_point(field_set_allocated:vega.ChainEvent.validator)
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ChainEvent::kTxIDFieldNumber;
const int ChainEvent::kNonceFieldNumber;
const int ChainEvent::kBuiltinFieldNumber;
const int ChainEvent::kErc20FieldNumber;
const int ChainEvent::kBtcFieldNumber;
const int ChainEvent::kValidatorFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ChainEvent::ChainEvent()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:vega.ChainEvent)
}
ChainEvent::ChainEvent(const ChainEvent& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  txid_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.txid().size() > 0) {
    txid_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.txid_);
  }
  nonce_ = from.nonce_;
  clear_has_event();
  switch (from.event_case()) {
    case kBuiltin: {
      mutable_builtin()->::vega::BuiltinAssetEvent::MergeFrom(from.builtin());
      break;
    }
    case kErc20: {
      mutable_erc20()->::vega::ERC20Event::MergeFrom(from.erc20());
      break;
    }
    case kBtc: {
      mutable_btc()->::vega::BTCEvent::MergeFrom(from.btc());
      break;
    }
    case kValidator: {
      mutable_validator()->::vega::ValidatorEvent::MergeFrom(from.validator());
      break;
    }
    case EVENT_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:vega.ChainEvent)
}

void ChainEvent::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_ChainEvent_proto_2fchain_5fevents_2eproto.base);
  txid_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  nonce_ = PROTOBUF_ULONGLONG(0);
  clear_has_event();
}

ChainEvent::~ChainEvent() {
  // @@protoc_insertion_point(destructor:vega.ChainEvent)
  SharedDtor();
}

void ChainEvent::SharedDtor() {
  txid_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (has_event()) {
    clear_event();
  }
}

void ChainEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ChainEvent& ChainEvent::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_ChainEvent_proto_2fchain_5fevents_2eproto.base);
  return *internal_default_instance();
}


void ChainEvent::clear_event() {
// @@protoc_insertion_point(one_of_clear_start:vega.ChainEvent)
  switch (event_case()) {
    case kBuiltin: {
      delete event_.builtin_;
      break;
    }
    case kErc20: {
      delete event_.erc20_;
      break;
    }
    case kBtc: {
      delete event_.btc_;
      break;
    }
    case kValidator: {
      delete event_.validator_;
      break;
    }
    case EVENT_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = EVENT_NOT_SET;
}


void ChainEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:vega.ChainEvent)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  txid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  nonce_ = PROTOBUF_ULONGLONG(0);
  clear_event();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* ChainEvent::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<ChainEvent*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // string txID = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ctx->extra_parse_data().SetFieldName("vega.ChainEvent.txID");
        object = msg->mutable_txid();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParserUTF8;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheckUTF8(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      // uint64 nonce = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 16) goto handle_unusual;
        msg->set_nonce(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // .vega.BuiltinAssetEvent builtin = 1001;
      case 1001: {
        if (static_cast<::google::protobuf::uint8>(tag) != 74) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::vega::BuiltinAssetEvent::_InternalParse;
        object = msg->mutable_builtin();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // .vega.ERC20Event erc20 = 1002;
      case 1002: {
        if (static_cast<::google::protobuf::uint8>(tag) != 82) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::vega::ERC20Event::_InternalParse;
        object = msg->mutable_erc20();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // .vega.BTCEvent btc = 1003;
      case 1003: {
        if (static_cast<::google::protobuf::uint8>(tag) != 90) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::vega::BTCEvent::_InternalParse;
        object = msg->mutable_btc();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // .vega.ValidatorEvent validator = 1004;
      case 1004: {
        if (static_cast<::google::protobuf::uint8>(tag) != 98) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::vega::ValidatorEvent::_InternalParse;
        object = msg->mutable_validator();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
string_till_end:
  static_cast<::std::string*>(object)->clear();
  static_cast<::std::string*>(object)->reserve(size);
  goto len_delim_till_end;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool ChainEvent::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vega.ChainEvent)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(16383u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // string txID = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_txid()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->txid().data(), static_cast<int>(this->txid().length()),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "vega.ChainEvent.txID"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // uint64 nonce = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (16 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &nonce_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .vega.BuiltinAssetEvent builtin = 1001;
      case 1001: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8010 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_builtin()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .vega.ERC20Event erc20 = 1002;
      case 1002: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8018 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_erc20()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .vega.BTCEvent btc = 1003;
      case 1003: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8026 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_btc()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .vega.ValidatorEvent validator = 1004;
      case 1004: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8034 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_validator()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vega.ChainEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vega.ChainEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void ChainEvent::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vega.ChainEvent)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // string txID = 1;
  if (this->txid().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->txid().data(), static_cast<int>(this->txid().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "vega.ChainEvent.txID");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->txid(), output);
  }

  // uint64 nonce = 2;
  if (this->nonce() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->nonce(), output);
  }

  // .vega.BuiltinAssetEvent builtin = 1001;
  if (has_builtin()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1001, HasBitSetters::builtin(this), output);
  }

  // .vega.ERC20Event erc20 = 1002;
  if (has_erc20()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1002, HasBitSetters::erc20(this), output);
  }

  // .vega.BTCEvent btc = 1003;
  if (has_btc()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1003, HasBitSetters::btc(this), output);
  }

  // .vega.ValidatorEvent validator = 1004;
  if (has_validator()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1004, HasBitSetters::validator(this), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:vega.ChainEvent)
}

::google::protobuf::uint8* ChainEvent::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:vega.ChainEvent)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // string txID = 1;
  if (this->txid().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->txid().data(), static_cast<int>(this->txid().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "vega.ChainEvent.txID");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->txid(), target);
  }

  // uint64 nonce = 2;
  if (this->nonce() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(2, this->nonce(), target);
  }

  // .vega.BuiltinAssetEvent builtin = 1001;
  if (has_builtin()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1001, HasBitSetters::builtin(this), target);
  }

  // .vega.ERC20Event erc20 = 1002;
  if (has_erc20()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1002, HasBitSetters::erc20(this), target);
  }

  // .vega.BTCEvent btc = 1003;
  if (has_btc()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1003, HasBitSetters::btc(this), target);
  }

  // .vega.ValidatorEvent validator = 1004;
  if (has_validator()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1004, HasBitSetters::validator(this), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vega.ChainEvent)
  return target;
}

size_t ChainEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vega.ChainEvent)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string txID = 1;
  if (this->txid().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->txid());
  }

  // uint64 nonce = 2;
  if (this->nonce() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->nonce());
  }

  switch (event_case()) {
    // .vega.BuiltinAssetEvent builtin = 1001;
    case kBuiltin: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *event_.builtin_);
      break;
    }
    // .vega.ERC20Event erc20 = 1002;
    case kErc20: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *event_.erc20_);
      break;
    }
    // .vega.BTCEvent btc = 1003;
    case kBtc: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *event_.btc_);
      break;
    }
    // .vega.ValidatorEvent validator = 1004;
    case kValidator: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *event_.validator_);
      break;
    }
    case EVENT_NOT_SET: {
      break;
    }
  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ChainEvent::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:vega.ChainEvent)
  GOOGLE_DCHECK_NE(&from, this);
  const ChainEvent* source =
      ::google::protobuf::DynamicCastToGenerated<ChainEvent>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:vega.ChainEvent)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:vega.ChainEvent)
    MergeFrom(*source);
  }
}

void ChainEvent::MergeFrom(const ChainEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vega.ChainEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.txid().size() > 0) {

    txid_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.txid_);
  }
  if (from.nonce() != 0) {
    set_nonce(from.nonce());
  }
  switch (from.event_case()) {
    case kBuiltin: {
      mutable_builtin()->::vega::BuiltinAssetEvent::MergeFrom(from.builtin());
      break;
    }
    case kErc20: {
      mutable_erc20()->::vega::ERC20Event::MergeFrom(from.erc20());
      break;
    }
    case kBtc: {
      mutable_btc()->::vega::BTCEvent::MergeFrom(from.btc());
      break;
    }
    case kValidator: {
      mutable_validator()->::vega::ValidatorEvent::MergeFrom(from.validator());
      break;
    }
    case EVENT_NOT_SET: {
      break;
    }
  }
}

void ChainEvent::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:vega.ChainEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ChainEvent::CopyFrom(const ChainEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vega.ChainEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ChainEvent::IsInitialized() const {
  return true;
}

void ChainEvent::Swap(ChainEvent* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ChainEvent::InternalSwap(ChainEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  txid_.Swap(&other->txid_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(nonce_, other->nonce_);
  swap(event_, other->event_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

::google::protobuf::Metadata ChainEvent::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_proto_2fchain_5fevents_2eproto);
  return ::file_level_metadata_proto_2fchain_5fevents_2eproto[kIndexInFileMessages];
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace vega
namespace google {
namespace protobuf {
template<> PROTOBUF_NOINLINE ::vega::BuiltinAssetDeposit* Arena::CreateMaybeMessage< ::vega::BuiltinAssetDeposit >(Arena* arena) {
  return Arena::CreateInternal< ::vega::BuiltinAssetDeposit >(arena);
}
template<> PROTOBUF_NOINLINE ::vega::BuiltinAssetWithdrawal* Arena::CreateMaybeMessage< ::vega::BuiltinAssetWithdrawal >(Arena* arena) {
  return Arena::CreateInternal< ::vega::BuiltinAssetWithdrawal >(arena);
}
template<> PROTOBUF_NOINLINE ::vega::BuiltinAssetEvent* Arena::CreateMaybeMessage< ::vega::BuiltinAssetEvent >(Arena* arena) {
  return Arena::CreateInternal< ::vega::BuiltinAssetEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::vega::ERC20AssetList* Arena::CreateMaybeMessage< ::vega::ERC20AssetList >(Arena* arena) {
  return Arena::CreateInternal< ::vega::ERC20AssetList >(arena);
}
template<> PROTOBUF_NOINLINE ::vega::ERC20AssetDelist* Arena::CreateMaybeMessage< ::vega::ERC20AssetDelist >(Arena* arena) {
  return Arena::CreateInternal< ::vega::ERC20AssetDelist >(arena);
}
template<> PROTOBUF_NOINLINE ::vega::ERC20Deposit* Arena::CreateMaybeMessage< ::vega::ERC20Deposit >(Arena* arena) {
  return Arena::CreateInternal< ::vega::ERC20Deposit >(arena);
}
template<> PROTOBUF_NOINLINE ::vega::ERC20Withdrawal* Arena::CreateMaybeMessage< ::vega::ERC20Withdrawal >(Arena* arena) {
  return Arena::CreateInternal< ::vega::ERC20Withdrawal >(arena);
}
template<> PROTOBUF_NOINLINE ::vega::ERC20Event* Arena::CreateMaybeMessage< ::vega::ERC20Event >(Arena* arena) {
  return Arena::CreateInternal< ::vega::ERC20Event >(arena);
}
template<> PROTOBUF_NOINLINE ::vega::BTCDeposit* Arena::CreateMaybeMessage< ::vega::BTCDeposit >(Arena* arena) {
  return Arena::CreateInternal< ::vega::BTCDeposit >(arena);
}
template<> PROTOBUF_NOINLINE ::vega::BTCWithdrawal* Arena::CreateMaybeMessage< ::vega::BTCWithdrawal >(Arena* arena) {
  return Arena::CreateInternal< ::vega::BTCWithdrawal >(arena);
}
template<> PROTOBUF_NOINLINE ::vega::BTCEvent* Arena::CreateMaybeMessage< ::vega::BTCEvent >(Arena* arena) {
  return Arena::CreateInternal< ::vega::BTCEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::vega::EthereumAddress* Arena::CreateMaybeMessage< ::vega::EthereumAddress >(Arena* arena) {
  return Arena::CreateInternal< ::vega::EthereumAddress >(arena);
}
template<> PROTOBUF_NOINLINE ::vega::BitcoinAddress* Arena::CreateMaybeMessage< ::vega::BitcoinAddress >(Arena* arena) {
  return Arena::CreateInternal< ::vega::BitcoinAddress >(arena);
}
template<> PROTOBUF_NOINLINE ::vega::Identifier* Arena::CreateMaybeMessage< ::vega::Identifier >(Arena* arena) {
  return Arena::CreateInternal< ::vega::Identifier >(arena);
}
template<> PROTOBUF_NOINLINE ::vega::AddValidator* Arena::CreateMaybeMessage< ::vega::AddValidator >(Arena* arena) {
  return Arena::CreateInternal< ::vega::AddValidator >(arena);
}
template<> PROTOBUF_NOINLINE ::vega::RemoveValidator* Arena::CreateMaybeMessage< ::vega::RemoveValidator >(Arena* arena) {
  return Arena::CreateInternal< ::vega::RemoveValidator >(arena);
}
template<> PROTOBUF_NOINLINE ::vega::ValidatorEvent* Arena::CreateMaybeMessage< ::vega::ValidatorEvent >(Arena* arena) {
  return Arena::CreateInternal< ::vega::ValidatorEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::vega::ChainEvent* Arena::CreateMaybeMessage< ::vega::ChainEvent >(Arena* arena) {
  return Arena::CreateInternal< ::vega::ChainEvent >(arena);
}
}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>

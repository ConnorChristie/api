// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: proto/events.proto

#ifndef PROTOBUF_INCLUDED_proto_2fevents_2eproto
#define PROTOBUF_INCLUDED_proto_2fevents_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3007000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3007001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "proto/markets.pb.h"
#include "proto/assets.pb.h"
#include "proto/governance.pb.h"
#include "proto/vega.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_proto_2fevents_2eproto

// Internal implementation detail -- do not use these members.
struct TableStruct_proto_2fevents_2eproto {
  static const ::google::protobuf::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::ParseTable schema[11]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors_proto_2fevents_2eproto();
namespace vega {
class AuctionEvent;
class AuctionEventDefaultTypeInternal;
extern AuctionEventDefaultTypeInternal _AuctionEvent_default_instance_;
class BusEvent;
class BusEventDefaultTypeInternal;
extern BusEventDefaultTypeInternal _BusEvent_default_instance_;
class LossSocialization;
class LossSocializationDefaultTypeInternal;
extern LossSocializationDefaultTypeInternal _LossSocialization_default_instance_;
class MarketEvent;
class MarketEventDefaultTypeInternal;
extern MarketEventDefaultTypeInternal _MarketEvent_default_instance_;
class MarketTick;
class MarketTickDefaultTypeInternal;
extern MarketTickDefaultTypeInternal _MarketTick_default_instance_;
class PositionResolution;
class PositionResolutionDefaultTypeInternal;
extern PositionResolutionDefaultTypeInternal _PositionResolution_default_instance_;
class SettleDistressed;
class SettleDistressedDefaultTypeInternal;
extern SettleDistressedDefaultTypeInternal _SettleDistressed_default_instance_;
class SettlePosition;
class SettlePositionDefaultTypeInternal;
extern SettlePositionDefaultTypeInternal _SettlePosition_default_instance_;
class TimeUpdate;
class TimeUpdateDefaultTypeInternal;
extern TimeUpdateDefaultTypeInternal _TimeUpdate_default_instance_;
class TradeSettlement;
class TradeSettlementDefaultTypeInternal;
extern TradeSettlementDefaultTypeInternal _TradeSettlement_default_instance_;
class TransferResponses;
class TransferResponsesDefaultTypeInternal;
extern TransferResponsesDefaultTypeInternal _TransferResponses_default_instance_;
}  // namespace vega
namespace google {
namespace protobuf {
template<> ::vega::AuctionEvent* Arena::CreateMaybeMessage<::vega::AuctionEvent>(Arena*);
template<> ::vega::BusEvent* Arena::CreateMaybeMessage<::vega::BusEvent>(Arena*);
template<> ::vega::LossSocialization* Arena::CreateMaybeMessage<::vega::LossSocialization>(Arena*);
template<> ::vega::MarketEvent* Arena::CreateMaybeMessage<::vega::MarketEvent>(Arena*);
template<> ::vega::MarketTick* Arena::CreateMaybeMessage<::vega::MarketTick>(Arena*);
template<> ::vega::PositionResolution* Arena::CreateMaybeMessage<::vega::PositionResolution>(Arena*);
template<> ::vega::SettleDistressed* Arena::CreateMaybeMessage<::vega::SettleDistressed>(Arena*);
template<> ::vega::SettlePosition* Arena::CreateMaybeMessage<::vega::SettlePosition>(Arena*);
template<> ::vega::TimeUpdate* Arena::CreateMaybeMessage<::vega::TimeUpdate>(Arena*);
template<> ::vega::TradeSettlement* Arena::CreateMaybeMessage<::vega::TradeSettlement>(Arena*);
template<> ::vega::TransferResponses* Arena::CreateMaybeMessage<::vega::TransferResponses>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace vega {

enum BusEventType {
  BUS_EVENT_TYPE_UNSPECIFIED = 0,
  BUS_EVENT_TYPE_ALL = 1,
  BUS_EVENT_TYPE_TIME_UPDATE = 2,
  BUS_EVENT_TYPE_TRANSFER_RESPONSES = 3,
  BUS_EVENT_TYPE_POSITION_RESOLUTION = 4,
  BUS_EVENT_TYPE_ORDER = 5,
  BUS_EVENT_TYPE_ACCOUNT = 6,
  BUS_EVENT_TYPE_PARTY = 7,
  BUS_EVENT_TYPE_TRADE = 8,
  BUS_EVENT_TYPE_MARGIN_LEVELS = 9,
  BUS_EVENT_TYPE_PROPOSAL = 10,
  BUS_EVENT_TYPE_VOTE = 11,
  BUS_EVENT_TYPE_MARKET_DATA = 12,
  BUS_EVENT_TYPE_NODE_SIGNATURE = 13,
  BUS_EVENT_TYPE_LOSS_SOCIALIZATION = 14,
  BUS_EVENT_TYPE_SETTLE_POSITION = 15,
  BUS_EVENT_TYPE_SETTLE_DISTRESSED = 16,
  BUS_EVENT_TYPE_MARKET_CREATED = 17,
  BUS_EVENT_TYPE_ASSET = 18,
  BUS_EVENT_TYPE_MARKET_TICK = 19,
  BUS_EVENT_TYPE_WITHDRAWAL = 20,
  BUS_EVENT_TYPE_DEPOSIT = 21,
  BUS_EVENT_TYPE_AUCTION = 22,
  BUS_EVENT_TYPE_RISK_FACTOR = 23,
  BUS_EVENT_TYPE_NETWORK_PARAMETER = 24,
  BUS_EVENT_TYPE_LIQUIDITY_PROVISION = 25,
  BUS_EVENT_TYPE_MARKET = 101,
  BusEventType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::min(),
  BusEventType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::max()
};
bool BusEventType_IsValid(int value);
const BusEventType BusEventType_MIN = BUS_EVENT_TYPE_UNSPECIFIED;
const BusEventType BusEventType_MAX = BUS_EVENT_TYPE_MARKET;
const int BusEventType_ARRAYSIZE = BusEventType_MAX + 1;

const ::google::protobuf::EnumDescriptor* BusEventType_descriptor();
inline const ::std::string& BusEventType_Name(BusEventType value) {
  return ::google::protobuf::internal::NameOfEnum(
    BusEventType_descriptor(), value);
}
inline bool BusEventType_Parse(
    const ::std::string& name, BusEventType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<BusEventType>(
    BusEventType_descriptor(), name, value);
}
// ===================================================================

class MarketEvent :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vega.MarketEvent) */ {
 public:
  MarketEvent();
  virtual ~MarketEvent();

  MarketEvent(const MarketEvent& from);

  inline MarketEvent& operator=(const MarketEvent& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MarketEvent(MarketEvent&& from) noexcept
    : MarketEvent() {
    *this = ::std::move(from);
  }

  inline MarketEvent& operator=(MarketEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const MarketEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MarketEvent* internal_default_instance() {
    return reinterpret_cast<const MarketEvent*>(
               &_MarketEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(MarketEvent* other);
  friend void swap(MarketEvent& a, MarketEvent& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MarketEvent* New() const final {
    return CreateMaybeMessage<MarketEvent>(nullptr);
  }

  MarketEvent* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MarketEvent>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MarketEvent& from);
  void MergeFrom(const MarketEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MarketEvent* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string marketID = 1;
  void clear_marketid();
  static const int kMarketIDFieldNumber = 1;
  const ::std::string& marketid() const;
  void set_marketid(const ::std::string& value);
  #if LANG_CXX11
  void set_marketid(::std::string&& value);
  #endif
  void set_marketid(const char* value);
  void set_marketid(const char* value, size_t size);
  ::std::string* mutable_marketid();
  ::std::string* release_marketid();
  void set_allocated_marketid(::std::string* marketid);

  // string payload = 2;
  void clear_payload();
  static const int kPayloadFieldNumber = 2;
  const ::std::string& payload() const;
  void set_payload(const ::std::string& value);
  #if LANG_CXX11
  void set_payload(::std::string&& value);
  #endif
  void set_payload(const char* value);
  void set_payload(const char* value, size_t size);
  ::std::string* mutable_payload();
  ::std::string* release_payload();
  void set_allocated_payload(::std::string* payload);

  // @@protoc_insertion_point(class_scope:vega.MarketEvent)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr marketid_;
  ::google::protobuf::internal::ArenaStringPtr payload_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fevents_2eproto;
};
// -------------------------------------------------------------------

class TimeUpdate :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vega.TimeUpdate) */ {
 public:
  TimeUpdate();
  virtual ~TimeUpdate();

  TimeUpdate(const TimeUpdate& from);

  inline TimeUpdate& operator=(const TimeUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TimeUpdate(TimeUpdate&& from) noexcept
    : TimeUpdate() {
    *this = ::std::move(from);
  }

  inline TimeUpdate& operator=(TimeUpdate&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const TimeUpdate& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TimeUpdate* internal_default_instance() {
    return reinterpret_cast<const TimeUpdate*>(
               &_TimeUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(TimeUpdate* other);
  friend void swap(TimeUpdate& a, TimeUpdate& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TimeUpdate* New() const final {
    return CreateMaybeMessage<TimeUpdate>(nullptr);
  }

  TimeUpdate* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TimeUpdate>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TimeUpdate& from);
  void MergeFrom(const TimeUpdate& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TimeUpdate* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int64 timestamp = 1;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  ::google::protobuf::int64 timestamp() const;
  void set_timestamp(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:vega.TimeUpdate)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int64 timestamp_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fevents_2eproto;
};
// -------------------------------------------------------------------

class TransferResponses :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vega.TransferResponses) */ {
 public:
  TransferResponses();
  virtual ~TransferResponses();

  TransferResponses(const TransferResponses& from);

  inline TransferResponses& operator=(const TransferResponses& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TransferResponses(TransferResponses&& from) noexcept
    : TransferResponses() {
    *this = ::std::move(from);
  }

  inline TransferResponses& operator=(TransferResponses&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const TransferResponses& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TransferResponses* internal_default_instance() {
    return reinterpret_cast<const TransferResponses*>(
               &_TransferResponses_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(TransferResponses* other);
  friend void swap(TransferResponses& a, TransferResponses& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TransferResponses* New() const final {
    return CreateMaybeMessage<TransferResponses>(nullptr);
  }

  TransferResponses* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TransferResponses>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TransferResponses& from);
  void MergeFrom(const TransferResponses& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransferResponses* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .vega.TransferResponse responses = 1;
  int responses_size() const;
  void clear_responses();
  static const int kResponsesFieldNumber = 1;
  ::vega::TransferResponse* mutable_responses(int index);
  ::google::protobuf::RepeatedPtrField< ::vega::TransferResponse >*
      mutable_responses();
  const ::vega::TransferResponse& responses(int index) const;
  ::vega::TransferResponse* add_responses();
  const ::google::protobuf::RepeatedPtrField< ::vega::TransferResponse >&
      responses() const;

  // @@protoc_insertion_point(class_scope:vega.TransferResponses)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::vega::TransferResponse > responses_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fevents_2eproto;
};
// -------------------------------------------------------------------

class PositionResolution :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vega.PositionResolution) */ {
 public:
  PositionResolution();
  virtual ~PositionResolution();

  PositionResolution(const PositionResolution& from);

  inline PositionResolution& operator=(const PositionResolution& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PositionResolution(PositionResolution&& from) noexcept
    : PositionResolution() {
    *this = ::std::move(from);
  }

  inline PositionResolution& operator=(PositionResolution&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const PositionResolution& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PositionResolution* internal_default_instance() {
    return reinterpret_cast<const PositionResolution*>(
               &_PositionResolution_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(PositionResolution* other);
  friend void swap(PositionResolution& a, PositionResolution& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PositionResolution* New() const final {
    return CreateMaybeMessage<PositionResolution>(nullptr);
  }

  PositionResolution* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PositionResolution>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PositionResolution& from);
  void MergeFrom(const PositionResolution& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PositionResolution* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string marketID = 1;
  void clear_marketid();
  static const int kMarketIDFieldNumber = 1;
  const ::std::string& marketid() const;
  void set_marketid(const ::std::string& value);
  #if LANG_CXX11
  void set_marketid(::std::string&& value);
  #endif
  void set_marketid(const char* value);
  void set_marketid(const char* value, size_t size);
  ::std::string* mutable_marketid();
  ::std::string* release_marketid();
  void set_allocated_marketid(::std::string* marketid);

  // int64 distressed = 2;
  void clear_distressed();
  static const int kDistressedFieldNumber = 2;
  ::google::protobuf::int64 distressed() const;
  void set_distressed(::google::protobuf::int64 value);

  // int64 closed = 3;
  void clear_closed();
  static const int kClosedFieldNumber = 3;
  ::google::protobuf::int64 closed() const;
  void set_closed(::google::protobuf::int64 value);

  // uint64 markPrice = 4;
  void clear_markprice();
  static const int kMarkPriceFieldNumber = 4;
  ::google::protobuf::uint64 markprice() const;
  void set_markprice(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:vega.PositionResolution)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr marketid_;
  ::google::protobuf::int64 distressed_;
  ::google::protobuf::int64 closed_;
  ::google::protobuf::uint64 markprice_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fevents_2eproto;
};
// -------------------------------------------------------------------

class LossSocialization :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vega.LossSocialization) */ {
 public:
  LossSocialization();
  virtual ~LossSocialization();

  LossSocialization(const LossSocialization& from);

  inline LossSocialization& operator=(const LossSocialization& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LossSocialization(LossSocialization&& from) noexcept
    : LossSocialization() {
    *this = ::std::move(from);
  }

  inline LossSocialization& operator=(LossSocialization&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const LossSocialization& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LossSocialization* internal_default_instance() {
    return reinterpret_cast<const LossSocialization*>(
               &_LossSocialization_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(LossSocialization* other);
  friend void swap(LossSocialization& a, LossSocialization& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LossSocialization* New() const final {
    return CreateMaybeMessage<LossSocialization>(nullptr);
  }

  LossSocialization* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LossSocialization>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LossSocialization& from);
  void MergeFrom(const LossSocialization& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LossSocialization* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string marketID = 1;
  void clear_marketid();
  static const int kMarketIDFieldNumber = 1;
  const ::std::string& marketid() const;
  void set_marketid(const ::std::string& value);
  #if LANG_CXX11
  void set_marketid(::std::string&& value);
  #endif
  void set_marketid(const char* value);
  void set_marketid(const char* value, size_t size);
  ::std::string* mutable_marketid();
  ::std::string* release_marketid();
  void set_allocated_marketid(::std::string* marketid);

  // string partyID = 2;
  void clear_partyid();
  static const int kPartyIDFieldNumber = 2;
  const ::std::string& partyid() const;
  void set_partyid(const ::std::string& value);
  #if LANG_CXX11
  void set_partyid(::std::string&& value);
  #endif
  void set_partyid(const char* value);
  void set_partyid(const char* value, size_t size);
  ::std::string* mutable_partyid();
  ::std::string* release_partyid();
  void set_allocated_partyid(::std::string* partyid);

  // int64 amount = 3;
  void clear_amount();
  static const int kAmountFieldNumber = 3;
  ::google::protobuf::int64 amount() const;
  void set_amount(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:vega.LossSocialization)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr marketid_;
  ::google::protobuf::internal::ArenaStringPtr partyid_;
  ::google::protobuf::int64 amount_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fevents_2eproto;
};
// -------------------------------------------------------------------

class TradeSettlement :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vega.TradeSettlement) */ {
 public:
  TradeSettlement();
  virtual ~TradeSettlement();

  TradeSettlement(const TradeSettlement& from);

  inline TradeSettlement& operator=(const TradeSettlement& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TradeSettlement(TradeSettlement&& from) noexcept
    : TradeSettlement() {
    *this = ::std::move(from);
  }

  inline TradeSettlement& operator=(TradeSettlement&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const TradeSettlement& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TradeSettlement* internal_default_instance() {
    return reinterpret_cast<const TradeSettlement*>(
               &_TradeSettlement_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(TradeSettlement* other);
  friend void swap(TradeSettlement& a, TradeSettlement& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TradeSettlement* New() const final {
    return CreateMaybeMessage<TradeSettlement>(nullptr);
  }

  TradeSettlement* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TradeSettlement>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TradeSettlement& from);
  void MergeFrom(const TradeSettlement& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TradeSettlement* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int64 size = 1;
  void clear_size();
  static const int kSizeFieldNumber = 1;
  ::google::protobuf::int64 size() const;
  void set_size(::google::protobuf::int64 value);

  // uint64 price = 2;
  void clear_price();
  static const int kPriceFieldNumber = 2;
  ::google::protobuf::uint64 price() const;
  void set_price(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:vega.TradeSettlement)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int64 size_;
  ::google::protobuf::uint64 price_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fevents_2eproto;
};
// -------------------------------------------------------------------

class SettlePosition :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vega.SettlePosition) */ {
 public:
  SettlePosition();
  virtual ~SettlePosition();

  SettlePosition(const SettlePosition& from);

  inline SettlePosition& operator=(const SettlePosition& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SettlePosition(SettlePosition&& from) noexcept
    : SettlePosition() {
    *this = ::std::move(from);
  }

  inline SettlePosition& operator=(SettlePosition&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const SettlePosition& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SettlePosition* internal_default_instance() {
    return reinterpret_cast<const SettlePosition*>(
               &_SettlePosition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(SettlePosition* other);
  friend void swap(SettlePosition& a, SettlePosition& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SettlePosition* New() const final {
    return CreateMaybeMessage<SettlePosition>(nullptr);
  }

  SettlePosition* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SettlePosition>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SettlePosition& from);
  void MergeFrom(const SettlePosition& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SettlePosition* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .vega.TradeSettlement tradeSettlements = 4;
  int tradesettlements_size() const;
  void clear_tradesettlements();
  static const int kTradeSettlementsFieldNumber = 4;
  ::vega::TradeSettlement* mutable_tradesettlements(int index);
  ::google::protobuf::RepeatedPtrField< ::vega::TradeSettlement >*
      mutable_tradesettlements();
  const ::vega::TradeSettlement& tradesettlements(int index) const;
  ::vega::TradeSettlement* add_tradesettlements();
  const ::google::protobuf::RepeatedPtrField< ::vega::TradeSettlement >&
      tradesettlements() const;

  // string marketID = 1;
  void clear_marketid();
  static const int kMarketIDFieldNumber = 1;
  const ::std::string& marketid() const;
  void set_marketid(const ::std::string& value);
  #if LANG_CXX11
  void set_marketid(::std::string&& value);
  #endif
  void set_marketid(const char* value);
  void set_marketid(const char* value, size_t size);
  ::std::string* mutable_marketid();
  ::std::string* release_marketid();
  void set_allocated_marketid(::std::string* marketid);

  // string partyID = 2;
  void clear_partyid();
  static const int kPartyIDFieldNumber = 2;
  const ::std::string& partyid() const;
  void set_partyid(const ::std::string& value);
  #if LANG_CXX11
  void set_partyid(::std::string&& value);
  #endif
  void set_partyid(const char* value);
  void set_partyid(const char* value, size_t size);
  ::std::string* mutable_partyid();
  ::std::string* release_partyid();
  void set_allocated_partyid(::std::string* partyid);

  // uint64 price = 3;
  void clear_price();
  static const int kPriceFieldNumber = 3;
  ::google::protobuf::uint64 price() const;
  void set_price(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:vega.SettlePosition)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::vega::TradeSettlement > tradesettlements_;
  ::google::protobuf::internal::ArenaStringPtr marketid_;
  ::google::protobuf::internal::ArenaStringPtr partyid_;
  ::google::protobuf::uint64 price_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fevents_2eproto;
};
// -------------------------------------------------------------------

class SettleDistressed :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vega.SettleDistressed) */ {
 public:
  SettleDistressed();
  virtual ~SettleDistressed();

  SettleDistressed(const SettleDistressed& from);

  inline SettleDistressed& operator=(const SettleDistressed& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SettleDistressed(SettleDistressed&& from) noexcept
    : SettleDistressed() {
    *this = ::std::move(from);
  }

  inline SettleDistressed& operator=(SettleDistressed&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const SettleDistressed& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SettleDistressed* internal_default_instance() {
    return reinterpret_cast<const SettleDistressed*>(
               &_SettleDistressed_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(SettleDistressed* other);
  friend void swap(SettleDistressed& a, SettleDistressed& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SettleDistressed* New() const final {
    return CreateMaybeMessage<SettleDistressed>(nullptr);
  }

  SettleDistressed* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SettleDistressed>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SettleDistressed& from);
  void MergeFrom(const SettleDistressed& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SettleDistressed* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string marketID = 1;
  void clear_marketid();
  static const int kMarketIDFieldNumber = 1;
  const ::std::string& marketid() const;
  void set_marketid(const ::std::string& value);
  #if LANG_CXX11
  void set_marketid(::std::string&& value);
  #endif
  void set_marketid(const char* value);
  void set_marketid(const char* value, size_t size);
  ::std::string* mutable_marketid();
  ::std::string* release_marketid();
  void set_allocated_marketid(::std::string* marketid);

  // string partyID = 2;
  void clear_partyid();
  static const int kPartyIDFieldNumber = 2;
  const ::std::string& partyid() const;
  void set_partyid(const ::std::string& value);
  #if LANG_CXX11
  void set_partyid(::std::string&& value);
  #endif
  void set_partyid(const char* value);
  void set_partyid(const char* value, size_t size);
  ::std::string* mutable_partyid();
  ::std::string* release_partyid();
  void set_allocated_partyid(::std::string* partyid);

  // uint64 margin = 3;
  void clear_margin();
  static const int kMarginFieldNumber = 3;
  ::google::protobuf::uint64 margin() const;
  void set_margin(::google::protobuf::uint64 value);

  // uint64 price = 4;
  void clear_price();
  static const int kPriceFieldNumber = 4;
  ::google::protobuf::uint64 price() const;
  void set_price(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:vega.SettleDistressed)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr marketid_;
  ::google::protobuf::internal::ArenaStringPtr partyid_;
  ::google::protobuf::uint64 margin_;
  ::google::protobuf::uint64 price_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fevents_2eproto;
};
// -------------------------------------------------------------------

class MarketTick :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vega.MarketTick) */ {
 public:
  MarketTick();
  virtual ~MarketTick();

  MarketTick(const MarketTick& from);

  inline MarketTick& operator=(const MarketTick& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MarketTick(MarketTick&& from) noexcept
    : MarketTick() {
    *this = ::std::move(from);
  }

  inline MarketTick& operator=(MarketTick&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const MarketTick& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MarketTick* internal_default_instance() {
    return reinterpret_cast<const MarketTick*>(
               &_MarketTick_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(MarketTick* other);
  friend void swap(MarketTick& a, MarketTick& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MarketTick* New() const final {
    return CreateMaybeMessage<MarketTick>(nullptr);
  }

  MarketTick* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MarketTick>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MarketTick& from);
  void MergeFrom(const MarketTick& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MarketTick* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string ID = 1;
  void clear_id();
  static const int kIDFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // int64 time = 2;
  void clear_time();
  static const int kTimeFieldNumber = 2;
  ::google::protobuf::int64 time() const;
  void set_time(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:vega.MarketTick)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::int64 time_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fevents_2eproto;
};
// -------------------------------------------------------------------

class AuctionEvent :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vega.AuctionEvent) */ {
 public:
  AuctionEvent();
  virtual ~AuctionEvent();

  AuctionEvent(const AuctionEvent& from);

  inline AuctionEvent& operator=(const AuctionEvent& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AuctionEvent(AuctionEvent&& from) noexcept
    : AuctionEvent() {
    *this = ::std::move(from);
  }

  inline AuctionEvent& operator=(AuctionEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const AuctionEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AuctionEvent* internal_default_instance() {
    return reinterpret_cast<const AuctionEvent*>(
               &_AuctionEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(AuctionEvent* other);
  friend void swap(AuctionEvent& a, AuctionEvent& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AuctionEvent* New() const final {
    return CreateMaybeMessage<AuctionEvent>(nullptr);
  }

  AuctionEvent* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AuctionEvent>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AuctionEvent& from);
  void MergeFrom(const AuctionEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AuctionEvent* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string marketID = 1;
  void clear_marketid();
  static const int kMarketIDFieldNumber = 1;
  const ::std::string& marketid() const;
  void set_marketid(const ::std::string& value);
  #if LANG_CXX11
  void set_marketid(::std::string&& value);
  #endif
  void set_marketid(const char* value);
  void set_marketid(const char* value, size_t size);
  ::std::string* mutable_marketid();
  ::std::string* release_marketid();
  void set_allocated_marketid(::std::string* marketid);

  // bool openingAuction = 2;
  void clear_openingauction();
  static const int kOpeningAuctionFieldNumber = 2;
  bool openingauction() const;
  void set_openingauction(bool value);

  // bool leave = 3;
  void clear_leave();
  static const int kLeaveFieldNumber = 3;
  bool leave() const;
  void set_leave(bool value);

  // .vega.AuctionTrigger trigger = 6;
  void clear_trigger();
  static const int kTriggerFieldNumber = 6;
  ::vega::AuctionTrigger trigger() const;
  void set_trigger(::vega::AuctionTrigger value);

  // int64 start = 4;
  void clear_start();
  static const int kStartFieldNumber = 4;
  ::google::protobuf::int64 start() const;
  void set_start(::google::protobuf::int64 value);

  // int64 end = 5;
  void clear_end();
  static const int kEndFieldNumber = 5;
  ::google::protobuf::int64 end() const;
  void set_end(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:vega.AuctionEvent)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr marketid_;
  bool openingauction_;
  bool leave_;
  int trigger_;
  ::google::protobuf::int64 start_;
  ::google::protobuf::int64 end_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fevents_2eproto;
};
// -------------------------------------------------------------------

class BusEvent :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vega.BusEvent) */ {
 public:
  BusEvent();
  virtual ~BusEvent();

  BusEvent(const BusEvent& from);

  inline BusEvent& operator=(const BusEvent& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BusEvent(BusEvent&& from) noexcept
    : BusEvent() {
    *this = ::std::move(from);
  }

  inline BusEvent& operator=(BusEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const BusEvent& default_instance();

  enum EventCase {
    kTimeUpdate = 101,
    kTransferResponses = 102,
    kPositionResolution = 103,
    kOrder = 104,
    kAccount = 105,
    kParty = 106,
    kTrade = 107,
    kMarginLevels = 108,
    kProposal = 109,
    kVote = 110,
    kMarketData = 111,
    kNodeSignature = 112,
    kLossSocialization = 113,
    kSettlePosition = 114,
    kSettleDistressed = 115,
    kMarketCreated = 116,
    kAsset = 117,
    kMarketTick = 118,
    kWithdrawal = 119,
    kDeposit = 120,
    kAuction = 121,
    kRiskFactor = 122,
    kNetworkParameter = 123,
    kLiquidityProvision = 124,
    kMarket = 1001,
    EVENT_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BusEvent* internal_default_instance() {
    return reinterpret_cast<const BusEvent*>(
               &_BusEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(BusEvent* other);
  friend void swap(BusEvent& a, BusEvent& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BusEvent* New() const final {
    return CreateMaybeMessage<BusEvent>(nullptr);
  }

  BusEvent* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BusEvent>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BusEvent& from);
  void MergeFrom(const BusEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BusEvent* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string ID = 1;
  void clear_id();
  static const int kIDFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // string block = 2;
  void clear_block();
  static const int kBlockFieldNumber = 2;
  const ::std::string& block() const;
  void set_block(const ::std::string& value);
  #if LANG_CXX11
  void set_block(::std::string&& value);
  #endif
  void set_block(const char* value);
  void set_block(const char* value, size_t size);
  ::std::string* mutable_block();
  ::std::string* release_block();
  void set_allocated_block(::std::string* block);

  // .vega.BusEventType type = 3;
  void clear_type();
  static const int kTypeFieldNumber = 3;
  ::vega::BusEventType type() const;
  void set_type(::vega::BusEventType value);

  // .vega.TimeUpdate timeUpdate = 101;
  bool has_timeupdate() const;
  void clear_timeupdate();
  static const int kTimeUpdateFieldNumber = 101;
  const ::vega::TimeUpdate& timeupdate() const;
  ::vega::TimeUpdate* release_timeupdate();
  ::vega::TimeUpdate* mutable_timeupdate();
  void set_allocated_timeupdate(::vega::TimeUpdate* timeupdate);

  // .vega.TransferResponses transferResponses = 102;
  bool has_transferresponses() const;
  void clear_transferresponses();
  static const int kTransferResponsesFieldNumber = 102;
  const ::vega::TransferResponses& transferresponses() const;
  ::vega::TransferResponses* release_transferresponses();
  ::vega::TransferResponses* mutable_transferresponses();
  void set_allocated_transferresponses(::vega::TransferResponses* transferresponses);

  // .vega.PositionResolution positionResolution = 103;
  bool has_positionresolution() const;
  void clear_positionresolution();
  static const int kPositionResolutionFieldNumber = 103;
  const ::vega::PositionResolution& positionresolution() const;
  ::vega::PositionResolution* release_positionresolution();
  ::vega::PositionResolution* mutable_positionresolution();
  void set_allocated_positionresolution(::vega::PositionResolution* positionresolution);

  // .vega.Order order = 104;
  bool has_order() const;
  void clear_order();
  static const int kOrderFieldNumber = 104;
  const ::vega::Order& order() const;
  ::vega::Order* release_order();
  ::vega::Order* mutable_order();
  void set_allocated_order(::vega::Order* order);

  // .vega.Account account = 105;
  bool has_account() const;
  void clear_account();
  static const int kAccountFieldNumber = 105;
  const ::vega::Account& account() const;
  ::vega::Account* release_account();
  ::vega::Account* mutable_account();
  void set_allocated_account(::vega::Account* account);

  // .vega.Party party = 106;
  bool has_party() const;
  void clear_party();
  static const int kPartyFieldNumber = 106;
  const ::vega::Party& party() const;
  ::vega::Party* release_party();
  ::vega::Party* mutable_party();
  void set_allocated_party(::vega::Party* party);

  // .vega.Trade trade = 107;
  bool has_trade() const;
  void clear_trade();
  static const int kTradeFieldNumber = 107;
  const ::vega::Trade& trade() const;
  ::vega::Trade* release_trade();
  ::vega::Trade* mutable_trade();
  void set_allocated_trade(::vega::Trade* trade);

  // .vega.MarginLevels marginLevels = 108;
  bool has_marginlevels() const;
  void clear_marginlevels();
  static const int kMarginLevelsFieldNumber = 108;
  const ::vega::MarginLevels& marginlevels() const;
  ::vega::MarginLevels* release_marginlevels();
  ::vega::MarginLevels* mutable_marginlevels();
  void set_allocated_marginlevels(::vega::MarginLevels* marginlevels);

  // .vega.Proposal proposal = 109;
  bool has_proposal() const;
  void clear_proposal();
  static const int kProposalFieldNumber = 109;
  const ::vega::Proposal& proposal() const;
  ::vega::Proposal* release_proposal();
  ::vega::Proposal* mutable_proposal();
  void set_allocated_proposal(::vega::Proposal* proposal);

  // .vega.Vote vote = 110;
  bool has_vote() const;
  void clear_vote();
  static const int kVoteFieldNumber = 110;
  const ::vega::Vote& vote() const;
  ::vega::Vote* release_vote();
  ::vega::Vote* mutable_vote();
  void set_allocated_vote(::vega::Vote* vote);

  // .vega.MarketData marketData = 111;
  bool has_marketdata() const;
  void clear_marketdata();
  static const int kMarketDataFieldNumber = 111;
  const ::vega::MarketData& marketdata() const;
  ::vega::MarketData* release_marketdata();
  ::vega::MarketData* mutable_marketdata();
  void set_allocated_marketdata(::vega::MarketData* marketdata);

  // .vega.NodeSignature nodeSignature = 112;
  bool has_nodesignature() const;
  void clear_nodesignature();
  static const int kNodeSignatureFieldNumber = 112;
  const ::vega::NodeSignature& nodesignature() const;
  ::vega::NodeSignature* release_nodesignature();
  ::vega::NodeSignature* mutable_nodesignature();
  void set_allocated_nodesignature(::vega::NodeSignature* nodesignature);

  // .vega.LossSocialization lossSocialization = 113;
  bool has_losssocialization() const;
  void clear_losssocialization();
  static const int kLossSocializationFieldNumber = 113;
  const ::vega::LossSocialization& losssocialization() const;
  ::vega::LossSocialization* release_losssocialization();
  ::vega::LossSocialization* mutable_losssocialization();
  void set_allocated_losssocialization(::vega::LossSocialization* losssocialization);

  // .vega.SettlePosition settlePosition = 114;
  bool has_settleposition() const;
  void clear_settleposition();
  static const int kSettlePositionFieldNumber = 114;
  const ::vega::SettlePosition& settleposition() const;
  ::vega::SettlePosition* release_settleposition();
  ::vega::SettlePosition* mutable_settleposition();
  void set_allocated_settleposition(::vega::SettlePosition* settleposition);

  // .vega.SettleDistressed settleDistressed = 115;
  bool has_settledistressed() const;
  void clear_settledistressed();
  static const int kSettleDistressedFieldNumber = 115;
  const ::vega::SettleDistressed& settledistressed() const;
  ::vega::SettleDistressed* release_settledistressed();
  ::vega::SettleDistressed* mutable_settledistressed();
  void set_allocated_settledistressed(::vega::SettleDistressed* settledistressed);

  // .vega.Market marketCreated = 116;
  bool has_marketcreated() const;
  void clear_marketcreated();
  static const int kMarketCreatedFieldNumber = 116;
  const ::vega::Market& marketcreated() const;
  ::vega::Market* release_marketcreated();
  ::vega::Market* mutable_marketcreated();
  void set_allocated_marketcreated(::vega::Market* marketcreated);

  // .vega.Asset asset = 117;
  bool has_asset() const;
  void clear_asset();
  static const int kAssetFieldNumber = 117;
  const ::vega::Asset& asset() const;
  ::vega::Asset* release_asset();
  ::vega::Asset* mutable_asset();
  void set_allocated_asset(::vega::Asset* asset);

  // .vega.MarketTick marketTick = 118;
  bool has_markettick() const;
  void clear_markettick();
  static const int kMarketTickFieldNumber = 118;
  const ::vega::MarketTick& markettick() const;
  ::vega::MarketTick* release_markettick();
  ::vega::MarketTick* mutable_markettick();
  void set_allocated_markettick(::vega::MarketTick* markettick);

  // .vega.Withdrawal withdrawal = 119;
  bool has_withdrawal() const;
  void clear_withdrawal();
  static const int kWithdrawalFieldNumber = 119;
  const ::vega::Withdrawal& withdrawal() const;
  ::vega::Withdrawal* release_withdrawal();
  ::vega::Withdrawal* mutable_withdrawal();
  void set_allocated_withdrawal(::vega::Withdrawal* withdrawal);

  // .vega.Deposit deposit = 120;
  bool has_deposit() const;
  void clear_deposit();
  static const int kDepositFieldNumber = 120;
  const ::vega::Deposit& deposit() const;
  ::vega::Deposit* release_deposit();
  ::vega::Deposit* mutable_deposit();
  void set_allocated_deposit(::vega::Deposit* deposit);

  // .vega.AuctionEvent auction = 121;
  bool has_auction() const;
  void clear_auction();
  static const int kAuctionFieldNumber = 121;
  const ::vega::AuctionEvent& auction() const;
  ::vega::AuctionEvent* release_auction();
  ::vega::AuctionEvent* mutable_auction();
  void set_allocated_auction(::vega::AuctionEvent* auction);

  // .vega.RiskFactor riskFactor = 122;
  bool has_riskfactor() const;
  void clear_riskfactor();
  static const int kRiskFactorFieldNumber = 122;
  const ::vega::RiskFactor& riskfactor() const;
  ::vega::RiskFactor* release_riskfactor();
  ::vega::RiskFactor* mutable_riskfactor();
  void set_allocated_riskfactor(::vega::RiskFactor* riskfactor);

  // .vega.NetworkParameter networkParameter = 123;
  bool has_networkparameter() const;
  void clear_networkparameter();
  static const int kNetworkParameterFieldNumber = 123;
  const ::vega::NetworkParameter& networkparameter() const;
  ::vega::NetworkParameter* release_networkparameter();
  ::vega::NetworkParameter* mutable_networkparameter();
  void set_allocated_networkparameter(::vega::NetworkParameter* networkparameter);

  // .vega.LiquidityProvision liquidityProvision = 124;
  bool has_liquidityprovision() const;
  void clear_liquidityprovision();
  static const int kLiquidityProvisionFieldNumber = 124;
  const ::vega::LiquidityProvision& liquidityprovision() const;
  ::vega::LiquidityProvision* release_liquidityprovision();
  ::vega::LiquidityProvision* mutable_liquidityprovision();
  void set_allocated_liquidityprovision(::vega::LiquidityProvision* liquidityprovision);

  // .vega.MarketEvent market = 1001;
  bool has_market() const;
  void clear_market();
  static const int kMarketFieldNumber = 1001;
  const ::vega::MarketEvent& market() const;
  ::vega::MarketEvent* release_market();
  ::vega::MarketEvent* mutable_market();
  void set_allocated_market(::vega::MarketEvent* market);

  void clear_event();
  EventCase event_case() const;
  // @@protoc_insertion_point(class_scope:vega.BusEvent)
 private:
  class HasBitSetters;
  void set_has_timeupdate();
  void set_has_transferresponses();
  void set_has_positionresolution();
  void set_has_order();
  void set_has_account();
  void set_has_party();
  void set_has_trade();
  void set_has_marginlevels();
  void set_has_proposal();
  void set_has_vote();
  void set_has_marketdata();
  void set_has_nodesignature();
  void set_has_losssocialization();
  void set_has_settleposition();
  void set_has_settledistressed();
  void set_has_marketcreated();
  void set_has_asset();
  void set_has_markettick();
  void set_has_withdrawal();
  void set_has_deposit();
  void set_has_auction();
  void set_has_riskfactor();
  void set_has_networkparameter();
  void set_has_liquidityprovision();
  void set_has_market();

  inline bool has_event() const;
  inline void clear_has_event();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::internal::ArenaStringPtr block_;
  int type_;
  union EventUnion {
    EventUnion() {}
    ::vega::TimeUpdate* timeupdate_;
    ::vega::TransferResponses* transferresponses_;
    ::vega::PositionResolution* positionresolution_;
    ::vega::Order* order_;
    ::vega::Account* account_;
    ::vega::Party* party_;
    ::vega::Trade* trade_;
    ::vega::MarginLevels* marginlevels_;
    ::vega::Proposal* proposal_;
    ::vega::Vote* vote_;
    ::vega::MarketData* marketdata_;
    ::vega::NodeSignature* nodesignature_;
    ::vega::LossSocialization* losssocialization_;
    ::vega::SettlePosition* settleposition_;
    ::vega::SettleDistressed* settledistressed_;
    ::vega::Market* marketcreated_;
    ::vega::Asset* asset_;
    ::vega::MarketTick* markettick_;
    ::vega::Withdrawal* withdrawal_;
    ::vega::Deposit* deposit_;
    ::vega::AuctionEvent* auction_;
    ::vega::RiskFactor* riskfactor_;
    ::vega::NetworkParameter* networkparameter_;
    ::vega::LiquidityProvision* liquidityprovision_;
    ::vega::MarketEvent* market_;
  } event_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::TableStruct_proto_2fevents_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// MarketEvent

// string marketID = 1;
inline void MarketEvent::clear_marketid() {
  marketid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MarketEvent::marketid() const {
  // @@protoc_insertion_point(field_get:vega.MarketEvent.marketID)
  return marketid_.GetNoArena();
}
inline void MarketEvent::set_marketid(const ::std::string& value) {

  marketid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vega.MarketEvent.marketID)
}
#if LANG_CXX11
inline void MarketEvent::set_marketid(::std::string&& value) {

  marketid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vega.MarketEvent.marketID)
}
#endif
inline void MarketEvent::set_marketid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  marketid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vega.MarketEvent.marketID)
}
inline void MarketEvent::set_marketid(const char* value, size_t size) {

  marketid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vega.MarketEvent.marketID)
}
inline ::std::string* MarketEvent::mutable_marketid() {

  // @@protoc_insertion_point(field_mutable:vega.MarketEvent.marketID)
  return marketid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MarketEvent::release_marketid() {
  // @@protoc_insertion_point(field_release:vega.MarketEvent.marketID)

  return marketid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MarketEvent::set_allocated_marketid(::std::string* marketid) {
  if (marketid != nullptr) {

  } else {

  }
  marketid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), marketid);
  // @@protoc_insertion_point(field_set_allocated:vega.MarketEvent.marketID)
}

// string payload = 2;
inline void MarketEvent::clear_payload() {
  payload_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MarketEvent::payload() const {
  // @@protoc_insertion_point(field_get:vega.MarketEvent.payload)
  return payload_.GetNoArena();
}
inline void MarketEvent::set_payload(const ::std::string& value) {

  payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vega.MarketEvent.payload)
}
#if LANG_CXX11
inline void MarketEvent::set_payload(::std::string&& value) {

  payload_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vega.MarketEvent.payload)
}
#endif
inline void MarketEvent::set_payload(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vega.MarketEvent.payload)
}
inline void MarketEvent::set_payload(const char* value, size_t size) {

  payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vega.MarketEvent.payload)
}
inline ::std::string* MarketEvent::mutable_payload() {

  // @@protoc_insertion_point(field_mutable:vega.MarketEvent.payload)
  return payload_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MarketEvent::release_payload() {
  // @@protoc_insertion_point(field_release:vega.MarketEvent.payload)

  return payload_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MarketEvent::set_allocated_payload(::std::string* payload) {
  if (payload != nullptr) {

  } else {

  }
  payload_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), payload);
  // @@protoc_insertion_point(field_set_allocated:vega.MarketEvent.payload)
}

// -------------------------------------------------------------------

// TimeUpdate

// int64 timestamp = 1;
inline void TimeUpdate::clear_timestamp() {
  timestamp_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 TimeUpdate::timestamp() const {
  // @@protoc_insertion_point(field_get:vega.TimeUpdate.timestamp)
  return timestamp_;
}
inline void TimeUpdate::set_timestamp(::google::protobuf::int64 value) {

  timestamp_ = value;
  // @@protoc_insertion_point(field_set:vega.TimeUpdate.timestamp)
}

// -------------------------------------------------------------------

// TransferResponses

// repeated .vega.TransferResponse responses = 1;
inline int TransferResponses::responses_size() const {
  return responses_.size();
}
inline ::vega::TransferResponse* TransferResponses::mutable_responses(int index) {
  // @@protoc_insertion_point(field_mutable:vega.TransferResponses.responses)
  return responses_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::vega::TransferResponse >*
TransferResponses::mutable_responses() {
  // @@protoc_insertion_point(field_mutable_list:vega.TransferResponses.responses)
  return &responses_;
}
inline const ::vega::TransferResponse& TransferResponses::responses(int index) const {
  // @@protoc_insertion_point(field_get:vega.TransferResponses.responses)
  return responses_.Get(index);
}
inline ::vega::TransferResponse* TransferResponses::add_responses() {
  // @@protoc_insertion_point(field_add:vega.TransferResponses.responses)
  return responses_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vega::TransferResponse >&
TransferResponses::responses() const {
  // @@protoc_insertion_point(field_list:vega.TransferResponses.responses)
  return responses_;
}

// -------------------------------------------------------------------

// PositionResolution

// string marketID = 1;
inline void PositionResolution::clear_marketid() {
  marketid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PositionResolution::marketid() const {
  // @@protoc_insertion_point(field_get:vega.PositionResolution.marketID)
  return marketid_.GetNoArena();
}
inline void PositionResolution::set_marketid(const ::std::string& value) {

  marketid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vega.PositionResolution.marketID)
}
#if LANG_CXX11
inline void PositionResolution::set_marketid(::std::string&& value) {

  marketid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vega.PositionResolution.marketID)
}
#endif
inline void PositionResolution::set_marketid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  marketid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vega.PositionResolution.marketID)
}
inline void PositionResolution::set_marketid(const char* value, size_t size) {

  marketid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vega.PositionResolution.marketID)
}
inline ::std::string* PositionResolution::mutable_marketid() {

  // @@protoc_insertion_point(field_mutable:vega.PositionResolution.marketID)
  return marketid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PositionResolution::release_marketid() {
  // @@protoc_insertion_point(field_release:vega.PositionResolution.marketID)

  return marketid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PositionResolution::set_allocated_marketid(::std::string* marketid) {
  if (marketid != nullptr) {

  } else {

  }
  marketid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), marketid);
  // @@protoc_insertion_point(field_set_allocated:vega.PositionResolution.marketID)
}

// int64 distressed = 2;
inline void PositionResolution::clear_distressed() {
  distressed_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 PositionResolution::distressed() const {
  // @@protoc_insertion_point(field_get:vega.PositionResolution.distressed)
  return distressed_;
}
inline void PositionResolution::set_distressed(::google::protobuf::int64 value) {

  distressed_ = value;
  // @@protoc_insertion_point(field_set:vega.PositionResolution.distressed)
}

// int64 closed = 3;
inline void PositionResolution::clear_closed() {
  closed_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 PositionResolution::closed() const {
  // @@protoc_insertion_point(field_get:vega.PositionResolution.closed)
  return closed_;
}
inline void PositionResolution::set_closed(::google::protobuf::int64 value) {

  closed_ = value;
  // @@protoc_insertion_point(field_set:vega.PositionResolution.closed)
}

// uint64 markPrice = 4;
inline void PositionResolution::clear_markprice() {
  markprice_ = PROTOBUF_ULONGLONG(0);
}
inline ::google::protobuf::uint64 PositionResolution::markprice() const {
  // @@protoc_insertion_point(field_get:vega.PositionResolution.markPrice)
  return markprice_;
}
inline void PositionResolution::set_markprice(::google::protobuf::uint64 value) {

  markprice_ = value;
  // @@protoc_insertion_point(field_set:vega.PositionResolution.markPrice)
}

// -------------------------------------------------------------------

// LossSocialization

// string marketID = 1;
inline void LossSocialization::clear_marketid() {
  marketid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LossSocialization::marketid() const {
  // @@protoc_insertion_point(field_get:vega.LossSocialization.marketID)
  return marketid_.GetNoArena();
}
inline void LossSocialization::set_marketid(const ::std::string& value) {

  marketid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vega.LossSocialization.marketID)
}
#if LANG_CXX11
inline void LossSocialization::set_marketid(::std::string&& value) {

  marketid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vega.LossSocialization.marketID)
}
#endif
inline void LossSocialization::set_marketid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  marketid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vega.LossSocialization.marketID)
}
inline void LossSocialization::set_marketid(const char* value, size_t size) {

  marketid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vega.LossSocialization.marketID)
}
inline ::std::string* LossSocialization::mutable_marketid() {

  // @@protoc_insertion_point(field_mutable:vega.LossSocialization.marketID)
  return marketid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LossSocialization::release_marketid() {
  // @@protoc_insertion_point(field_release:vega.LossSocialization.marketID)

  return marketid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LossSocialization::set_allocated_marketid(::std::string* marketid) {
  if (marketid != nullptr) {

  } else {

  }
  marketid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), marketid);
  // @@protoc_insertion_point(field_set_allocated:vega.LossSocialization.marketID)
}

// string partyID = 2;
inline void LossSocialization::clear_partyid() {
  partyid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LossSocialization::partyid() const {
  // @@protoc_insertion_point(field_get:vega.LossSocialization.partyID)
  return partyid_.GetNoArena();
}
inline void LossSocialization::set_partyid(const ::std::string& value) {

  partyid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vega.LossSocialization.partyID)
}
#if LANG_CXX11
inline void LossSocialization::set_partyid(::std::string&& value) {

  partyid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vega.LossSocialization.partyID)
}
#endif
inline void LossSocialization::set_partyid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  partyid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vega.LossSocialization.partyID)
}
inline void LossSocialization::set_partyid(const char* value, size_t size) {

  partyid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vega.LossSocialization.partyID)
}
inline ::std::string* LossSocialization::mutable_partyid() {

  // @@protoc_insertion_point(field_mutable:vega.LossSocialization.partyID)
  return partyid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LossSocialization::release_partyid() {
  // @@protoc_insertion_point(field_release:vega.LossSocialization.partyID)

  return partyid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LossSocialization::set_allocated_partyid(::std::string* partyid) {
  if (partyid != nullptr) {

  } else {

  }
  partyid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), partyid);
  // @@protoc_insertion_point(field_set_allocated:vega.LossSocialization.partyID)
}

// int64 amount = 3;
inline void LossSocialization::clear_amount() {
  amount_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 LossSocialization::amount() const {
  // @@protoc_insertion_point(field_get:vega.LossSocialization.amount)
  return amount_;
}
inline void LossSocialization::set_amount(::google::protobuf::int64 value) {

  amount_ = value;
  // @@protoc_insertion_point(field_set:vega.LossSocialization.amount)
}

// -------------------------------------------------------------------

// TradeSettlement

// int64 size = 1;
inline void TradeSettlement::clear_size() {
  size_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 TradeSettlement::size() const {
  // @@protoc_insertion_point(field_get:vega.TradeSettlement.size)
  return size_;
}
inline void TradeSettlement::set_size(::google::protobuf::int64 value) {

  size_ = value;
  // @@protoc_insertion_point(field_set:vega.TradeSettlement.size)
}

// uint64 price = 2;
inline void TradeSettlement::clear_price() {
  price_ = PROTOBUF_ULONGLONG(0);
}
inline ::google::protobuf::uint64 TradeSettlement::price() const {
  // @@protoc_insertion_point(field_get:vega.TradeSettlement.price)
  return price_;
}
inline void TradeSettlement::set_price(::google::protobuf::uint64 value) {

  price_ = value;
  // @@protoc_insertion_point(field_set:vega.TradeSettlement.price)
}

// -------------------------------------------------------------------

// SettlePosition

// string marketID = 1;
inline void SettlePosition::clear_marketid() {
  marketid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SettlePosition::marketid() const {
  // @@protoc_insertion_point(field_get:vega.SettlePosition.marketID)
  return marketid_.GetNoArena();
}
inline void SettlePosition::set_marketid(const ::std::string& value) {

  marketid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vega.SettlePosition.marketID)
}
#if LANG_CXX11
inline void SettlePosition::set_marketid(::std::string&& value) {

  marketid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vega.SettlePosition.marketID)
}
#endif
inline void SettlePosition::set_marketid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  marketid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vega.SettlePosition.marketID)
}
inline void SettlePosition::set_marketid(const char* value, size_t size) {

  marketid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vega.SettlePosition.marketID)
}
inline ::std::string* SettlePosition::mutable_marketid() {

  // @@protoc_insertion_point(field_mutable:vega.SettlePosition.marketID)
  return marketid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SettlePosition::release_marketid() {
  // @@protoc_insertion_point(field_release:vega.SettlePosition.marketID)

  return marketid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SettlePosition::set_allocated_marketid(::std::string* marketid) {
  if (marketid != nullptr) {

  } else {

  }
  marketid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), marketid);
  // @@protoc_insertion_point(field_set_allocated:vega.SettlePosition.marketID)
}

// string partyID = 2;
inline void SettlePosition::clear_partyid() {
  partyid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SettlePosition::partyid() const {
  // @@protoc_insertion_point(field_get:vega.SettlePosition.partyID)
  return partyid_.GetNoArena();
}
inline void SettlePosition::set_partyid(const ::std::string& value) {

  partyid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vega.SettlePosition.partyID)
}
#if LANG_CXX11
inline void SettlePosition::set_partyid(::std::string&& value) {

  partyid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vega.SettlePosition.partyID)
}
#endif
inline void SettlePosition::set_partyid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  partyid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vega.SettlePosition.partyID)
}
inline void SettlePosition::set_partyid(const char* value, size_t size) {

  partyid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vega.SettlePosition.partyID)
}
inline ::std::string* SettlePosition::mutable_partyid() {

  // @@protoc_insertion_point(field_mutable:vega.SettlePosition.partyID)
  return partyid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SettlePosition::release_partyid() {
  // @@protoc_insertion_point(field_release:vega.SettlePosition.partyID)

  return partyid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SettlePosition::set_allocated_partyid(::std::string* partyid) {
  if (partyid != nullptr) {

  } else {

  }
  partyid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), partyid);
  // @@protoc_insertion_point(field_set_allocated:vega.SettlePosition.partyID)
}

// uint64 price = 3;
inline void SettlePosition::clear_price() {
  price_ = PROTOBUF_ULONGLONG(0);
}
inline ::google::protobuf::uint64 SettlePosition::price() const {
  // @@protoc_insertion_point(field_get:vega.SettlePosition.price)
  return price_;
}
inline void SettlePosition::set_price(::google::protobuf::uint64 value) {

  price_ = value;
  // @@protoc_insertion_point(field_set:vega.SettlePosition.price)
}

// repeated .vega.TradeSettlement tradeSettlements = 4;
inline int SettlePosition::tradesettlements_size() const {
  return tradesettlements_.size();
}
inline void SettlePosition::clear_tradesettlements() {
  tradesettlements_.Clear();
}
inline ::vega::TradeSettlement* SettlePosition::mutable_tradesettlements(int index) {
  // @@protoc_insertion_point(field_mutable:vega.SettlePosition.tradeSettlements)
  return tradesettlements_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::vega::TradeSettlement >*
SettlePosition::mutable_tradesettlements() {
  // @@protoc_insertion_point(field_mutable_list:vega.SettlePosition.tradeSettlements)
  return &tradesettlements_;
}
inline const ::vega::TradeSettlement& SettlePosition::tradesettlements(int index) const {
  // @@protoc_insertion_point(field_get:vega.SettlePosition.tradeSettlements)
  return tradesettlements_.Get(index);
}
inline ::vega::TradeSettlement* SettlePosition::add_tradesettlements() {
  // @@protoc_insertion_point(field_add:vega.SettlePosition.tradeSettlements)
  return tradesettlements_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vega::TradeSettlement >&
SettlePosition::tradesettlements() const {
  // @@protoc_insertion_point(field_list:vega.SettlePosition.tradeSettlements)
  return tradesettlements_;
}

// -------------------------------------------------------------------

// SettleDistressed

// string marketID = 1;
inline void SettleDistressed::clear_marketid() {
  marketid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SettleDistressed::marketid() const {
  // @@protoc_insertion_point(field_get:vega.SettleDistressed.marketID)
  return marketid_.GetNoArena();
}
inline void SettleDistressed::set_marketid(const ::std::string& value) {

  marketid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vega.SettleDistressed.marketID)
}
#if LANG_CXX11
inline void SettleDistressed::set_marketid(::std::string&& value) {

  marketid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vega.SettleDistressed.marketID)
}
#endif
inline void SettleDistressed::set_marketid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  marketid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vega.SettleDistressed.marketID)
}
inline void SettleDistressed::set_marketid(const char* value, size_t size) {

  marketid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vega.SettleDistressed.marketID)
}
inline ::std::string* SettleDistressed::mutable_marketid() {

  // @@protoc_insertion_point(field_mutable:vega.SettleDistressed.marketID)
  return marketid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SettleDistressed::release_marketid() {
  // @@protoc_insertion_point(field_release:vega.SettleDistressed.marketID)

  return marketid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SettleDistressed::set_allocated_marketid(::std::string* marketid) {
  if (marketid != nullptr) {

  } else {

  }
  marketid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), marketid);
  // @@protoc_insertion_point(field_set_allocated:vega.SettleDistressed.marketID)
}

// string partyID = 2;
inline void SettleDistressed::clear_partyid() {
  partyid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SettleDistressed::partyid() const {
  // @@protoc_insertion_point(field_get:vega.SettleDistressed.partyID)
  return partyid_.GetNoArena();
}
inline void SettleDistressed::set_partyid(const ::std::string& value) {

  partyid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vega.SettleDistressed.partyID)
}
#if LANG_CXX11
inline void SettleDistressed::set_partyid(::std::string&& value) {

  partyid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vega.SettleDistressed.partyID)
}
#endif
inline void SettleDistressed::set_partyid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  partyid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vega.SettleDistressed.partyID)
}
inline void SettleDistressed::set_partyid(const char* value, size_t size) {

  partyid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vega.SettleDistressed.partyID)
}
inline ::std::string* SettleDistressed::mutable_partyid() {

  // @@protoc_insertion_point(field_mutable:vega.SettleDistressed.partyID)
  return partyid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SettleDistressed::release_partyid() {
  // @@protoc_insertion_point(field_release:vega.SettleDistressed.partyID)

  return partyid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SettleDistressed::set_allocated_partyid(::std::string* partyid) {
  if (partyid != nullptr) {

  } else {

  }
  partyid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), partyid);
  // @@protoc_insertion_point(field_set_allocated:vega.SettleDistressed.partyID)
}

// uint64 margin = 3;
inline void SettleDistressed::clear_margin() {
  margin_ = PROTOBUF_ULONGLONG(0);
}
inline ::google::protobuf::uint64 SettleDistressed::margin() const {
  // @@protoc_insertion_point(field_get:vega.SettleDistressed.margin)
  return margin_;
}
inline void SettleDistressed::set_margin(::google::protobuf::uint64 value) {

  margin_ = value;
  // @@protoc_insertion_point(field_set:vega.SettleDistressed.margin)
}

// uint64 price = 4;
inline void SettleDistressed::clear_price() {
  price_ = PROTOBUF_ULONGLONG(0);
}
inline ::google::protobuf::uint64 SettleDistressed::price() const {
  // @@protoc_insertion_point(field_get:vega.SettleDistressed.price)
  return price_;
}
inline void SettleDistressed::set_price(::google::protobuf::uint64 value) {

  price_ = value;
  // @@protoc_insertion_point(field_set:vega.SettleDistressed.price)
}

// -------------------------------------------------------------------

// MarketTick

// string ID = 1;
inline void MarketTick::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MarketTick::id() const {
  // @@protoc_insertion_point(field_get:vega.MarketTick.ID)
  return id_.GetNoArena();
}
inline void MarketTick::set_id(const ::std::string& value) {

  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vega.MarketTick.ID)
}
#if LANG_CXX11
inline void MarketTick::set_id(::std::string&& value) {

  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vega.MarketTick.ID)
}
#endif
inline void MarketTick::set_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vega.MarketTick.ID)
}
inline void MarketTick::set_id(const char* value, size_t size) {

  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vega.MarketTick.ID)
}
inline ::std::string* MarketTick::mutable_id() {

  // @@protoc_insertion_point(field_mutable:vega.MarketTick.ID)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MarketTick::release_id() {
  // @@protoc_insertion_point(field_release:vega.MarketTick.ID)

  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MarketTick::set_allocated_id(::std::string* id) {
  if (id != nullptr) {

  } else {

  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:vega.MarketTick.ID)
}

// int64 time = 2;
inline void MarketTick::clear_time() {
  time_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 MarketTick::time() const {
  // @@protoc_insertion_point(field_get:vega.MarketTick.time)
  return time_;
}
inline void MarketTick::set_time(::google::protobuf::int64 value) {

  time_ = value;
  // @@protoc_insertion_point(field_set:vega.MarketTick.time)
}

// -------------------------------------------------------------------

// AuctionEvent

// string marketID = 1;
inline void AuctionEvent::clear_marketid() {
  marketid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AuctionEvent::marketid() const {
  // @@protoc_insertion_point(field_get:vega.AuctionEvent.marketID)
  return marketid_.GetNoArena();
}
inline void AuctionEvent::set_marketid(const ::std::string& value) {

  marketid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vega.AuctionEvent.marketID)
}
#if LANG_CXX11
inline void AuctionEvent::set_marketid(::std::string&& value) {

  marketid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vega.AuctionEvent.marketID)
}
#endif
inline void AuctionEvent::set_marketid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  marketid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vega.AuctionEvent.marketID)
}
inline void AuctionEvent::set_marketid(const char* value, size_t size) {

  marketid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vega.AuctionEvent.marketID)
}
inline ::std::string* AuctionEvent::mutable_marketid() {

  // @@protoc_insertion_point(field_mutable:vega.AuctionEvent.marketID)
  return marketid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AuctionEvent::release_marketid() {
  // @@protoc_insertion_point(field_release:vega.AuctionEvent.marketID)

  return marketid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AuctionEvent::set_allocated_marketid(::std::string* marketid) {
  if (marketid != nullptr) {

  } else {

  }
  marketid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), marketid);
  // @@protoc_insertion_point(field_set_allocated:vega.AuctionEvent.marketID)
}

// bool openingAuction = 2;
inline void AuctionEvent::clear_openingauction() {
  openingauction_ = false;
}
inline bool AuctionEvent::openingauction() const {
  // @@protoc_insertion_point(field_get:vega.AuctionEvent.openingAuction)
  return openingauction_;
}
inline void AuctionEvent::set_openingauction(bool value) {

  openingauction_ = value;
  // @@protoc_insertion_point(field_set:vega.AuctionEvent.openingAuction)
}

// bool leave = 3;
inline void AuctionEvent::clear_leave() {
  leave_ = false;
}
inline bool AuctionEvent::leave() const {
  // @@protoc_insertion_point(field_get:vega.AuctionEvent.leave)
  return leave_;
}
inline void AuctionEvent::set_leave(bool value) {

  leave_ = value;
  // @@protoc_insertion_point(field_set:vega.AuctionEvent.leave)
}

// int64 start = 4;
inline void AuctionEvent::clear_start() {
  start_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 AuctionEvent::start() const {
  // @@protoc_insertion_point(field_get:vega.AuctionEvent.start)
  return start_;
}
inline void AuctionEvent::set_start(::google::protobuf::int64 value) {

  start_ = value;
  // @@protoc_insertion_point(field_set:vega.AuctionEvent.start)
}

// int64 end = 5;
inline void AuctionEvent::clear_end() {
  end_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 AuctionEvent::end() const {
  // @@protoc_insertion_point(field_get:vega.AuctionEvent.end)
  return end_;
}
inline void AuctionEvent::set_end(::google::protobuf::int64 value) {

  end_ = value;
  // @@protoc_insertion_point(field_set:vega.AuctionEvent.end)
}

// .vega.AuctionTrigger trigger = 6;
inline void AuctionEvent::clear_trigger() {
  trigger_ = 0;
}
inline ::vega::AuctionTrigger AuctionEvent::trigger() const {
  // @@protoc_insertion_point(field_get:vega.AuctionEvent.trigger)
  return static_cast< ::vega::AuctionTrigger >(trigger_);
}
inline void AuctionEvent::set_trigger(::vega::AuctionTrigger value) {

  trigger_ = value;
  // @@protoc_insertion_point(field_set:vega.AuctionEvent.trigger)
}

// -------------------------------------------------------------------

// BusEvent

// string ID = 1;
inline void BusEvent::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BusEvent::id() const {
  // @@protoc_insertion_point(field_get:vega.BusEvent.ID)
  return id_.GetNoArena();
}
inline void BusEvent::set_id(const ::std::string& value) {

  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vega.BusEvent.ID)
}
#if LANG_CXX11
inline void BusEvent::set_id(::std::string&& value) {

  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vega.BusEvent.ID)
}
#endif
inline void BusEvent::set_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vega.BusEvent.ID)
}
inline void BusEvent::set_id(const char* value, size_t size) {

  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vega.BusEvent.ID)
}
inline ::std::string* BusEvent::mutable_id() {

  // @@protoc_insertion_point(field_mutable:vega.BusEvent.ID)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BusEvent::release_id() {
  // @@protoc_insertion_point(field_release:vega.BusEvent.ID)

  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BusEvent::set_allocated_id(::std::string* id) {
  if (id != nullptr) {

  } else {

  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:vega.BusEvent.ID)
}

// string block = 2;
inline void BusEvent::clear_block() {
  block_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BusEvent::block() const {
  // @@protoc_insertion_point(field_get:vega.BusEvent.block)
  return block_.GetNoArena();
}
inline void BusEvent::set_block(const ::std::string& value) {

  block_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vega.BusEvent.block)
}
#if LANG_CXX11
inline void BusEvent::set_block(::std::string&& value) {

  block_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vega.BusEvent.block)
}
#endif
inline void BusEvent::set_block(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  block_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vega.BusEvent.block)
}
inline void BusEvent::set_block(const char* value, size_t size) {

  block_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vega.BusEvent.block)
}
inline ::std::string* BusEvent::mutable_block() {

  // @@protoc_insertion_point(field_mutable:vega.BusEvent.block)
  return block_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BusEvent::release_block() {
  // @@protoc_insertion_point(field_release:vega.BusEvent.block)

  return block_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BusEvent::set_allocated_block(::std::string* block) {
  if (block != nullptr) {

  } else {

  }
  block_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), block);
  // @@protoc_insertion_point(field_set_allocated:vega.BusEvent.block)
}

// .vega.BusEventType type = 3;
inline void BusEvent::clear_type() {
  type_ = 0;
}
inline ::vega::BusEventType BusEvent::type() const {
  // @@protoc_insertion_point(field_get:vega.BusEvent.type)
  return static_cast< ::vega::BusEventType >(type_);
}
inline void BusEvent::set_type(::vega::BusEventType value) {

  type_ = value;
  // @@protoc_insertion_point(field_set:vega.BusEvent.type)
}

// .vega.TimeUpdate timeUpdate = 101;
inline bool BusEvent::has_timeupdate() const {
  return event_case() == kTimeUpdate;
}
inline void BusEvent::set_has_timeupdate() {
  _oneof_case_[0] = kTimeUpdate;
}
inline void BusEvent::clear_timeupdate() {
  if (has_timeupdate()) {
    delete event_.timeupdate_;
    clear_has_event();
  }
}
inline ::vega::TimeUpdate* BusEvent::release_timeupdate() {
  // @@protoc_insertion_point(field_release:vega.BusEvent.timeUpdate)
  if (has_timeupdate()) {
    clear_has_event();
      ::vega::TimeUpdate* temp = event_.timeupdate_;
    event_.timeupdate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vega::TimeUpdate& BusEvent::timeupdate() const {
  // @@protoc_insertion_point(field_get:vega.BusEvent.timeUpdate)
  return has_timeupdate()
      ? *event_.timeupdate_
      : *reinterpret_cast< ::vega::TimeUpdate*>(&::vega::_TimeUpdate_default_instance_);
}
inline ::vega::TimeUpdate* BusEvent::mutable_timeupdate() {
  if (!has_timeupdate()) {
    clear_event();
    set_has_timeupdate();
    event_.timeupdate_ = CreateMaybeMessage< ::vega::TimeUpdate >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:vega.BusEvent.timeUpdate)
  return event_.timeupdate_;
}

// .vega.TransferResponses transferResponses = 102;
inline bool BusEvent::has_transferresponses() const {
  return event_case() == kTransferResponses;
}
inline void BusEvent::set_has_transferresponses() {
  _oneof_case_[0] = kTransferResponses;
}
inline void BusEvent::clear_transferresponses() {
  if (has_transferresponses()) {
    delete event_.transferresponses_;
    clear_has_event();
  }
}
inline ::vega::TransferResponses* BusEvent::release_transferresponses() {
  // @@protoc_insertion_point(field_release:vega.BusEvent.transferResponses)
  if (has_transferresponses()) {
    clear_has_event();
      ::vega::TransferResponses* temp = event_.transferresponses_;
    event_.transferresponses_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vega::TransferResponses& BusEvent::transferresponses() const {
  // @@protoc_insertion_point(field_get:vega.BusEvent.transferResponses)
  return has_transferresponses()
      ? *event_.transferresponses_
      : *reinterpret_cast< ::vega::TransferResponses*>(&::vega::_TransferResponses_default_instance_);
}
inline ::vega::TransferResponses* BusEvent::mutable_transferresponses() {
  if (!has_transferresponses()) {
    clear_event();
    set_has_transferresponses();
    event_.transferresponses_ = CreateMaybeMessage< ::vega::TransferResponses >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:vega.BusEvent.transferResponses)
  return event_.transferresponses_;
}

// .vega.PositionResolution positionResolution = 103;
inline bool BusEvent::has_positionresolution() const {
  return event_case() == kPositionResolution;
}
inline void BusEvent::set_has_positionresolution() {
  _oneof_case_[0] = kPositionResolution;
}
inline void BusEvent::clear_positionresolution() {
  if (has_positionresolution()) {
    delete event_.positionresolution_;
    clear_has_event();
  }
}
inline ::vega::PositionResolution* BusEvent::release_positionresolution() {
  // @@protoc_insertion_point(field_release:vega.BusEvent.positionResolution)
  if (has_positionresolution()) {
    clear_has_event();
      ::vega::PositionResolution* temp = event_.positionresolution_;
    event_.positionresolution_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vega::PositionResolution& BusEvent::positionresolution() const {
  // @@protoc_insertion_point(field_get:vega.BusEvent.positionResolution)
  return has_positionresolution()
      ? *event_.positionresolution_
      : *reinterpret_cast< ::vega::PositionResolution*>(&::vega::_PositionResolution_default_instance_);
}
inline ::vega::PositionResolution* BusEvent::mutable_positionresolution() {
  if (!has_positionresolution()) {
    clear_event();
    set_has_positionresolution();
    event_.positionresolution_ = CreateMaybeMessage< ::vega::PositionResolution >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:vega.BusEvent.positionResolution)
  return event_.positionresolution_;
}

// .vega.Order order = 104;
inline bool BusEvent::has_order() const {
  return event_case() == kOrder;
}
inline void BusEvent::set_has_order() {
  _oneof_case_[0] = kOrder;
}
inline ::vega::Order* BusEvent::release_order() {
  // @@protoc_insertion_point(field_release:vega.BusEvent.order)
  if (has_order()) {
    clear_has_event();
      ::vega::Order* temp = event_.order_;
    event_.order_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vega::Order& BusEvent::order() const {
  // @@protoc_insertion_point(field_get:vega.BusEvent.order)
  return has_order()
      ? *event_.order_
      : *reinterpret_cast< ::vega::Order*>(&::vega::_Order_default_instance_);
}
inline ::vega::Order* BusEvent::mutable_order() {
  if (!has_order()) {
    clear_event();
    set_has_order();
    event_.order_ = CreateMaybeMessage< ::vega::Order >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:vega.BusEvent.order)
  return event_.order_;
}

// .vega.Account account = 105;
inline bool BusEvent::has_account() const {
  return event_case() == kAccount;
}
inline void BusEvent::set_has_account() {
  _oneof_case_[0] = kAccount;
}
inline ::vega::Account* BusEvent::release_account() {
  // @@protoc_insertion_point(field_release:vega.BusEvent.account)
  if (has_account()) {
    clear_has_event();
      ::vega::Account* temp = event_.account_;
    event_.account_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vega::Account& BusEvent::account() const {
  // @@protoc_insertion_point(field_get:vega.BusEvent.account)
  return has_account()
      ? *event_.account_
      : *reinterpret_cast< ::vega::Account*>(&::vega::_Account_default_instance_);
}
inline ::vega::Account* BusEvent::mutable_account() {
  if (!has_account()) {
    clear_event();
    set_has_account();
    event_.account_ = CreateMaybeMessage< ::vega::Account >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:vega.BusEvent.account)
  return event_.account_;
}

// .vega.Party party = 106;
inline bool BusEvent::has_party() const {
  return event_case() == kParty;
}
inline void BusEvent::set_has_party() {
  _oneof_case_[0] = kParty;
}
inline ::vega::Party* BusEvent::release_party() {
  // @@protoc_insertion_point(field_release:vega.BusEvent.party)
  if (has_party()) {
    clear_has_event();
      ::vega::Party* temp = event_.party_;
    event_.party_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vega::Party& BusEvent::party() const {
  // @@protoc_insertion_point(field_get:vega.BusEvent.party)
  return has_party()
      ? *event_.party_
      : *reinterpret_cast< ::vega::Party*>(&::vega::_Party_default_instance_);
}
inline ::vega::Party* BusEvent::mutable_party() {
  if (!has_party()) {
    clear_event();
    set_has_party();
    event_.party_ = CreateMaybeMessage< ::vega::Party >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:vega.BusEvent.party)
  return event_.party_;
}

// .vega.Trade trade = 107;
inline bool BusEvent::has_trade() const {
  return event_case() == kTrade;
}
inline void BusEvent::set_has_trade() {
  _oneof_case_[0] = kTrade;
}
inline ::vega::Trade* BusEvent::release_trade() {
  // @@protoc_insertion_point(field_release:vega.BusEvent.trade)
  if (has_trade()) {
    clear_has_event();
      ::vega::Trade* temp = event_.trade_;
    event_.trade_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vega::Trade& BusEvent::trade() const {
  // @@protoc_insertion_point(field_get:vega.BusEvent.trade)
  return has_trade()
      ? *event_.trade_
      : *reinterpret_cast< ::vega::Trade*>(&::vega::_Trade_default_instance_);
}
inline ::vega::Trade* BusEvent::mutable_trade() {
  if (!has_trade()) {
    clear_event();
    set_has_trade();
    event_.trade_ = CreateMaybeMessage< ::vega::Trade >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:vega.BusEvent.trade)
  return event_.trade_;
}

// .vega.MarginLevels marginLevels = 108;
inline bool BusEvent::has_marginlevels() const {
  return event_case() == kMarginLevels;
}
inline void BusEvent::set_has_marginlevels() {
  _oneof_case_[0] = kMarginLevels;
}
inline ::vega::MarginLevels* BusEvent::release_marginlevels() {
  // @@protoc_insertion_point(field_release:vega.BusEvent.marginLevels)
  if (has_marginlevels()) {
    clear_has_event();
      ::vega::MarginLevels* temp = event_.marginlevels_;
    event_.marginlevels_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vega::MarginLevels& BusEvent::marginlevels() const {
  // @@protoc_insertion_point(field_get:vega.BusEvent.marginLevels)
  return has_marginlevels()
      ? *event_.marginlevels_
      : *reinterpret_cast< ::vega::MarginLevels*>(&::vega::_MarginLevels_default_instance_);
}
inline ::vega::MarginLevels* BusEvent::mutable_marginlevels() {
  if (!has_marginlevels()) {
    clear_event();
    set_has_marginlevels();
    event_.marginlevels_ = CreateMaybeMessage< ::vega::MarginLevels >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:vega.BusEvent.marginLevels)
  return event_.marginlevels_;
}

// .vega.Proposal proposal = 109;
inline bool BusEvent::has_proposal() const {
  return event_case() == kProposal;
}
inline void BusEvent::set_has_proposal() {
  _oneof_case_[0] = kProposal;
}
inline ::vega::Proposal* BusEvent::release_proposal() {
  // @@protoc_insertion_point(field_release:vega.BusEvent.proposal)
  if (has_proposal()) {
    clear_has_event();
      ::vega::Proposal* temp = event_.proposal_;
    event_.proposal_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vega::Proposal& BusEvent::proposal() const {
  // @@protoc_insertion_point(field_get:vega.BusEvent.proposal)
  return has_proposal()
      ? *event_.proposal_
      : *reinterpret_cast< ::vega::Proposal*>(&::vega::_Proposal_default_instance_);
}
inline ::vega::Proposal* BusEvent::mutable_proposal() {
  if (!has_proposal()) {
    clear_event();
    set_has_proposal();
    event_.proposal_ = CreateMaybeMessage< ::vega::Proposal >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:vega.BusEvent.proposal)
  return event_.proposal_;
}

// .vega.Vote vote = 110;
inline bool BusEvent::has_vote() const {
  return event_case() == kVote;
}
inline void BusEvent::set_has_vote() {
  _oneof_case_[0] = kVote;
}
inline ::vega::Vote* BusEvent::release_vote() {
  // @@protoc_insertion_point(field_release:vega.BusEvent.vote)
  if (has_vote()) {
    clear_has_event();
      ::vega::Vote* temp = event_.vote_;
    event_.vote_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vega::Vote& BusEvent::vote() const {
  // @@protoc_insertion_point(field_get:vega.BusEvent.vote)
  return has_vote()
      ? *event_.vote_
      : *reinterpret_cast< ::vega::Vote*>(&::vega::_Vote_default_instance_);
}
inline ::vega::Vote* BusEvent::mutable_vote() {
  if (!has_vote()) {
    clear_event();
    set_has_vote();
    event_.vote_ = CreateMaybeMessage< ::vega::Vote >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:vega.BusEvent.vote)
  return event_.vote_;
}

// .vega.MarketData marketData = 111;
inline bool BusEvent::has_marketdata() const {
  return event_case() == kMarketData;
}
inline void BusEvent::set_has_marketdata() {
  _oneof_case_[0] = kMarketData;
}
inline ::vega::MarketData* BusEvent::release_marketdata() {
  // @@protoc_insertion_point(field_release:vega.BusEvent.marketData)
  if (has_marketdata()) {
    clear_has_event();
      ::vega::MarketData* temp = event_.marketdata_;
    event_.marketdata_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vega::MarketData& BusEvent::marketdata() const {
  // @@protoc_insertion_point(field_get:vega.BusEvent.marketData)
  return has_marketdata()
      ? *event_.marketdata_
      : *reinterpret_cast< ::vega::MarketData*>(&::vega::_MarketData_default_instance_);
}
inline ::vega::MarketData* BusEvent::mutable_marketdata() {
  if (!has_marketdata()) {
    clear_event();
    set_has_marketdata();
    event_.marketdata_ = CreateMaybeMessage< ::vega::MarketData >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:vega.BusEvent.marketData)
  return event_.marketdata_;
}

// .vega.NodeSignature nodeSignature = 112;
inline bool BusEvent::has_nodesignature() const {
  return event_case() == kNodeSignature;
}
inline void BusEvent::set_has_nodesignature() {
  _oneof_case_[0] = kNodeSignature;
}
inline ::vega::NodeSignature* BusEvent::release_nodesignature() {
  // @@protoc_insertion_point(field_release:vega.BusEvent.nodeSignature)
  if (has_nodesignature()) {
    clear_has_event();
      ::vega::NodeSignature* temp = event_.nodesignature_;
    event_.nodesignature_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vega::NodeSignature& BusEvent::nodesignature() const {
  // @@protoc_insertion_point(field_get:vega.BusEvent.nodeSignature)
  return has_nodesignature()
      ? *event_.nodesignature_
      : *reinterpret_cast< ::vega::NodeSignature*>(&::vega::_NodeSignature_default_instance_);
}
inline ::vega::NodeSignature* BusEvent::mutable_nodesignature() {
  if (!has_nodesignature()) {
    clear_event();
    set_has_nodesignature();
    event_.nodesignature_ = CreateMaybeMessage< ::vega::NodeSignature >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:vega.BusEvent.nodeSignature)
  return event_.nodesignature_;
}

// .vega.LossSocialization lossSocialization = 113;
inline bool BusEvent::has_losssocialization() const {
  return event_case() == kLossSocialization;
}
inline void BusEvent::set_has_losssocialization() {
  _oneof_case_[0] = kLossSocialization;
}
inline void BusEvent::clear_losssocialization() {
  if (has_losssocialization()) {
    delete event_.losssocialization_;
    clear_has_event();
  }
}
inline ::vega::LossSocialization* BusEvent::release_losssocialization() {
  // @@protoc_insertion_point(field_release:vega.BusEvent.lossSocialization)
  if (has_losssocialization()) {
    clear_has_event();
      ::vega::LossSocialization* temp = event_.losssocialization_;
    event_.losssocialization_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vega::LossSocialization& BusEvent::losssocialization() const {
  // @@protoc_insertion_point(field_get:vega.BusEvent.lossSocialization)
  return has_losssocialization()
      ? *event_.losssocialization_
      : *reinterpret_cast< ::vega::LossSocialization*>(&::vega::_LossSocialization_default_instance_);
}
inline ::vega::LossSocialization* BusEvent::mutable_losssocialization() {
  if (!has_losssocialization()) {
    clear_event();
    set_has_losssocialization();
    event_.losssocialization_ = CreateMaybeMessage< ::vega::LossSocialization >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:vega.BusEvent.lossSocialization)
  return event_.losssocialization_;
}

// .vega.SettlePosition settlePosition = 114;
inline bool BusEvent::has_settleposition() const {
  return event_case() == kSettlePosition;
}
inline void BusEvent::set_has_settleposition() {
  _oneof_case_[0] = kSettlePosition;
}
inline void BusEvent::clear_settleposition() {
  if (has_settleposition()) {
    delete event_.settleposition_;
    clear_has_event();
  }
}
inline ::vega::SettlePosition* BusEvent::release_settleposition() {
  // @@protoc_insertion_point(field_release:vega.BusEvent.settlePosition)
  if (has_settleposition()) {
    clear_has_event();
      ::vega::SettlePosition* temp = event_.settleposition_;
    event_.settleposition_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vega::SettlePosition& BusEvent::settleposition() const {
  // @@protoc_insertion_point(field_get:vega.BusEvent.settlePosition)
  return has_settleposition()
      ? *event_.settleposition_
      : *reinterpret_cast< ::vega::SettlePosition*>(&::vega::_SettlePosition_default_instance_);
}
inline ::vega::SettlePosition* BusEvent::mutable_settleposition() {
  if (!has_settleposition()) {
    clear_event();
    set_has_settleposition();
    event_.settleposition_ = CreateMaybeMessage< ::vega::SettlePosition >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:vega.BusEvent.settlePosition)
  return event_.settleposition_;
}

// .vega.SettleDistressed settleDistressed = 115;
inline bool BusEvent::has_settledistressed() const {
  return event_case() == kSettleDistressed;
}
inline void BusEvent::set_has_settledistressed() {
  _oneof_case_[0] = kSettleDistressed;
}
inline void BusEvent::clear_settledistressed() {
  if (has_settledistressed()) {
    delete event_.settledistressed_;
    clear_has_event();
  }
}
inline ::vega::SettleDistressed* BusEvent::release_settledistressed() {
  // @@protoc_insertion_point(field_release:vega.BusEvent.settleDistressed)
  if (has_settledistressed()) {
    clear_has_event();
      ::vega::SettleDistressed* temp = event_.settledistressed_;
    event_.settledistressed_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vega::SettleDistressed& BusEvent::settledistressed() const {
  // @@protoc_insertion_point(field_get:vega.BusEvent.settleDistressed)
  return has_settledistressed()
      ? *event_.settledistressed_
      : *reinterpret_cast< ::vega::SettleDistressed*>(&::vega::_SettleDistressed_default_instance_);
}
inline ::vega::SettleDistressed* BusEvent::mutable_settledistressed() {
  if (!has_settledistressed()) {
    clear_event();
    set_has_settledistressed();
    event_.settledistressed_ = CreateMaybeMessage< ::vega::SettleDistressed >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:vega.BusEvent.settleDistressed)
  return event_.settledistressed_;
}

// .vega.Market marketCreated = 116;
inline bool BusEvent::has_marketcreated() const {
  return event_case() == kMarketCreated;
}
inline void BusEvent::set_has_marketcreated() {
  _oneof_case_[0] = kMarketCreated;
}
inline ::vega::Market* BusEvent::release_marketcreated() {
  // @@protoc_insertion_point(field_release:vega.BusEvent.marketCreated)
  if (has_marketcreated()) {
    clear_has_event();
      ::vega::Market* temp = event_.marketcreated_;
    event_.marketcreated_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vega::Market& BusEvent::marketcreated() const {
  // @@protoc_insertion_point(field_get:vega.BusEvent.marketCreated)
  return has_marketcreated()
      ? *event_.marketcreated_
      : *reinterpret_cast< ::vega::Market*>(&::vega::_Market_default_instance_);
}
inline ::vega::Market* BusEvent::mutable_marketcreated() {
  if (!has_marketcreated()) {
    clear_event();
    set_has_marketcreated();
    event_.marketcreated_ = CreateMaybeMessage< ::vega::Market >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:vega.BusEvent.marketCreated)
  return event_.marketcreated_;
}

// .vega.Asset asset = 117;
inline bool BusEvent::has_asset() const {
  return event_case() == kAsset;
}
inline void BusEvent::set_has_asset() {
  _oneof_case_[0] = kAsset;
}
inline ::vega::Asset* BusEvent::release_asset() {
  // @@protoc_insertion_point(field_release:vega.BusEvent.asset)
  if (has_asset()) {
    clear_has_event();
      ::vega::Asset* temp = event_.asset_;
    event_.asset_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vega::Asset& BusEvent::asset() const {
  // @@protoc_insertion_point(field_get:vega.BusEvent.asset)
  return has_asset()
      ? *event_.asset_
      : *reinterpret_cast< ::vega::Asset*>(&::vega::_Asset_default_instance_);
}
inline ::vega::Asset* BusEvent::mutable_asset() {
  if (!has_asset()) {
    clear_event();
    set_has_asset();
    event_.asset_ = CreateMaybeMessage< ::vega::Asset >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:vega.BusEvent.asset)
  return event_.asset_;
}

// .vega.MarketTick marketTick = 118;
inline bool BusEvent::has_markettick() const {
  return event_case() == kMarketTick;
}
inline void BusEvent::set_has_markettick() {
  _oneof_case_[0] = kMarketTick;
}
inline void BusEvent::clear_markettick() {
  if (has_markettick()) {
    delete event_.markettick_;
    clear_has_event();
  }
}
inline ::vega::MarketTick* BusEvent::release_markettick() {
  // @@protoc_insertion_point(field_release:vega.BusEvent.marketTick)
  if (has_markettick()) {
    clear_has_event();
      ::vega::MarketTick* temp = event_.markettick_;
    event_.markettick_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vega::MarketTick& BusEvent::markettick() const {
  // @@protoc_insertion_point(field_get:vega.BusEvent.marketTick)
  return has_markettick()
      ? *event_.markettick_
      : *reinterpret_cast< ::vega::MarketTick*>(&::vega::_MarketTick_default_instance_);
}
inline ::vega::MarketTick* BusEvent::mutable_markettick() {
  if (!has_markettick()) {
    clear_event();
    set_has_markettick();
    event_.markettick_ = CreateMaybeMessage< ::vega::MarketTick >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:vega.BusEvent.marketTick)
  return event_.markettick_;
}

// .vega.Withdrawal withdrawal = 119;
inline bool BusEvent::has_withdrawal() const {
  return event_case() == kWithdrawal;
}
inline void BusEvent::set_has_withdrawal() {
  _oneof_case_[0] = kWithdrawal;
}
inline ::vega::Withdrawal* BusEvent::release_withdrawal() {
  // @@protoc_insertion_point(field_release:vega.BusEvent.withdrawal)
  if (has_withdrawal()) {
    clear_has_event();
      ::vega::Withdrawal* temp = event_.withdrawal_;
    event_.withdrawal_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vega::Withdrawal& BusEvent::withdrawal() const {
  // @@protoc_insertion_point(field_get:vega.BusEvent.withdrawal)
  return has_withdrawal()
      ? *event_.withdrawal_
      : *reinterpret_cast< ::vega::Withdrawal*>(&::vega::_Withdrawal_default_instance_);
}
inline ::vega::Withdrawal* BusEvent::mutable_withdrawal() {
  if (!has_withdrawal()) {
    clear_event();
    set_has_withdrawal();
    event_.withdrawal_ = CreateMaybeMessage< ::vega::Withdrawal >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:vega.BusEvent.withdrawal)
  return event_.withdrawal_;
}

// .vega.Deposit deposit = 120;
inline bool BusEvent::has_deposit() const {
  return event_case() == kDeposit;
}
inline void BusEvent::set_has_deposit() {
  _oneof_case_[0] = kDeposit;
}
inline ::vega::Deposit* BusEvent::release_deposit() {
  // @@protoc_insertion_point(field_release:vega.BusEvent.deposit)
  if (has_deposit()) {
    clear_has_event();
      ::vega::Deposit* temp = event_.deposit_;
    event_.deposit_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vega::Deposit& BusEvent::deposit() const {
  // @@protoc_insertion_point(field_get:vega.BusEvent.deposit)
  return has_deposit()
      ? *event_.deposit_
      : *reinterpret_cast< ::vega::Deposit*>(&::vega::_Deposit_default_instance_);
}
inline ::vega::Deposit* BusEvent::mutable_deposit() {
  if (!has_deposit()) {
    clear_event();
    set_has_deposit();
    event_.deposit_ = CreateMaybeMessage< ::vega::Deposit >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:vega.BusEvent.deposit)
  return event_.deposit_;
}

// .vega.AuctionEvent auction = 121;
inline bool BusEvent::has_auction() const {
  return event_case() == kAuction;
}
inline void BusEvent::set_has_auction() {
  _oneof_case_[0] = kAuction;
}
inline void BusEvent::clear_auction() {
  if (has_auction()) {
    delete event_.auction_;
    clear_has_event();
  }
}
inline ::vega::AuctionEvent* BusEvent::release_auction() {
  // @@protoc_insertion_point(field_release:vega.BusEvent.auction)
  if (has_auction()) {
    clear_has_event();
      ::vega::AuctionEvent* temp = event_.auction_;
    event_.auction_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vega::AuctionEvent& BusEvent::auction() const {
  // @@protoc_insertion_point(field_get:vega.BusEvent.auction)
  return has_auction()
      ? *event_.auction_
      : *reinterpret_cast< ::vega::AuctionEvent*>(&::vega::_AuctionEvent_default_instance_);
}
inline ::vega::AuctionEvent* BusEvent::mutable_auction() {
  if (!has_auction()) {
    clear_event();
    set_has_auction();
    event_.auction_ = CreateMaybeMessage< ::vega::AuctionEvent >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:vega.BusEvent.auction)
  return event_.auction_;
}

// .vega.RiskFactor riskFactor = 122;
inline bool BusEvent::has_riskfactor() const {
  return event_case() == kRiskFactor;
}
inline void BusEvent::set_has_riskfactor() {
  _oneof_case_[0] = kRiskFactor;
}
inline ::vega::RiskFactor* BusEvent::release_riskfactor() {
  // @@protoc_insertion_point(field_release:vega.BusEvent.riskFactor)
  if (has_riskfactor()) {
    clear_has_event();
      ::vega::RiskFactor* temp = event_.riskfactor_;
    event_.riskfactor_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vega::RiskFactor& BusEvent::riskfactor() const {
  // @@protoc_insertion_point(field_get:vega.BusEvent.riskFactor)
  return has_riskfactor()
      ? *event_.riskfactor_
      : *reinterpret_cast< ::vega::RiskFactor*>(&::vega::_RiskFactor_default_instance_);
}
inline ::vega::RiskFactor* BusEvent::mutable_riskfactor() {
  if (!has_riskfactor()) {
    clear_event();
    set_has_riskfactor();
    event_.riskfactor_ = CreateMaybeMessage< ::vega::RiskFactor >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:vega.BusEvent.riskFactor)
  return event_.riskfactor_;
}

// .vega.NetworkParameter networkParameter = 123;
inline bool BusEvent::has_networkparameter() const {
  return event_case() == kNetworkParameter;
}
inline void BusEvent::set_has_networkparameter() {
  _oneof_case_[0] = kNetworkParameter;
}
inline ::vega::NetworkParameter* BusEvent::release_networkparameter() {
  // @@protoc_insertion_point(field_release:vega.BusEvent.networkParameter)
  if (has_networkparameter()) {
    clear_has_event();
      ::vega::NetworkParameter* temp = event_.networkparameter_;
    event_.networkparameter_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vega::NetworkParameter& BusEvent::networkparameter() const {
  // @@protoc_insertion_point(field_get:vega.BusEvent.networkParameter)
  return has_networkparameter()
      ? *event_.networkparameter_
      : *reinterpret_cast< ::vega::NetworkParameter*>(&::vega::_NetworkParameter_default_instance_);
}
inline ::vega::NetworkParameter* BusEvent::mutable_networkparameter() {
  if (!has_networkparameter()) {
    clear_event();
    set_has_networkparameter();
    event_.networkparameter_ = CreateMaybeMessage< ::vega::NetworkParameter >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:vega.BusEvent.networkParameter)
  return event_.networkparameter_;
}

// .vega.LiquidityProvision liquidityProvision = 124;
inline bool BusEvent::has_liquidityprovision() const {
  return event_case() == kLiquidityProvision;
}
inline void BusEvent::set_has_liquidityprovision() {
  _oneof_case_[0] = kLiquidityProvision;
}
inline ::vega::LiquidityProvision* BusEvent::release_liquidityprovision() {
  // @@protoc_insertion_point(field_release:vega.BusEvent.liquidityProvision)
  if (has_liquidityprovision()) {
    clear_has_event();
      ::vega::LiquidityProvision* temp = event_.liquidityprovision_;
    event_.liquidityprovision_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vega::LiquidityProvision& BusEvent::liquidityprovision() const {
  // @@protoc_insertion_point(field_get:vega.BusEvent.liquidityProvision)
  return has_liquidityprovision()
      ? *event_.liquidityprovision_
      : *reinterpret_cast< ::vega::LiquidityProvision*>(&::vega::_LiquidityProvision_default_instance_);
}
inline ::vega::LiquidityProvision* BusEvent::mutable_liquidityprovision() {
  if (!has_liquidityprovision()) {
    clear_event();
    set_has_liquidityprovision();
    event_.liquidityprovision_ = CreateMaybeMessage< ::vega::LiquidityProvision >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:vega.BusEvent.liquidityProvision)
  return event_.liquidityprovision_;
}

// .vega.MarketEvent market = 1001;
inline bool BusEvent::has_market() const {
  return event_case() == kMarket;
}
inline void BusEvent::set_has_market() {
  _oneof_case_[0] = kMarket;
}
inline void BusEvent::clear_market() {
  if (has_market()) {
    delete event_.market_;
    clear_has_event();
  }
}
inline ::vega::MarketEvent* BusEvent::release_market() {
  // @@protoc_insertion_point(field_release:vega.BusEvent.market)
  if (has_market()) {
    clear_has_event();
      ::vega::MarketEvent* temp = event_.market_;
    event_.market_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vega::MarketEvent& BusEvent::market() const {
  // @@protoc_insertion_point(field_get:vega.BusEvent.market)
  return has_market()
      ? *event_.market_
      : *reinterpret_cast< ::vega::MarketEvent*>(&::vega::_MarketEvent_default_instance_);
}
inline ::vega::MarketEvent* BusEvent::mutable_market() {
  if (!has_market()) {
    clear_event();
    set_has_market();
    event_.market_ = CreateMaybeMessage< ::vega::MarketEvent >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:vega.BusEvent.market)
  return event_.market_;
}

inline bool BusEvent::has_event() const {
  return event_case() != EVENT_NOT_SET;
}
inline void BusEvent::clear_has_event() {
  _oneof_case_[0] = EVENT_NOT_SET;
}
inline BusEvent::EventCase BusEvent::event_case() const {
  return BusEvent::EventCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace vega

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::vega::BusEventType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::vega::BusEventType>() {
  return ::vega::BusEventType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // PROTOBUF_INCLUDED_proto_2fevents_2eproto

// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: proto/chain_events.proto

#ifndef PROTOBUF_INCLUDED_proto_2fchain_5fevents_2eproto
#define PROTOBUF_INCLUDED_proto_2fchain_5fevents_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3007000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3007001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_proto_2fchain_5fevents_2eproto

// Internal implementation detail -- do not use these members.
struct TableStruct_proto_2fchain_5fevents_2eproto {
  static const ::google::protobuf::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::ParseTable schema[18]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors_proto_2fchain_5fevents_2eproto();
namespace vega {
class AddValidator;
class AddValidatorDefaultTypeInternal;
extern AddValidatorDefaultTypeInternal _AddValidator_default_instance_;
class BTCDeposit;
class BTCDepositDefaultTypeInternal;
extern BTCDepositDefaultTypeInternal _BTCDeposit_default_instance_;
class BTCEvent;
class BTCEventDefaultTypeInternal;
extern BTCEventDefaultTypeInternal _BTCEvent_default_instance_;
class BTCWithdrawal;
class BTCWithdrawalDefaultTypeInternal;
extern BTCWithdrawalDefaultTypeInternal _BTCWithdrawal_default_instance_;
class BitcoinAddress;
class BitcoinAddressDefaultTypeInternal;
extern BitcoinAddressDefaultTypeInternal _BitcoinAddress_default_instance_;
class BuiltinAssetDeposit;
class BuiltinAssetDepositDefaultTypeInternal;
extern BuiltinAssetDepositDefaultTypeInternal _BuiltinAssetDeposit_default_instance_;
class BuiltinAssetEvent;
class BuiltinAssetEventDefaultTypeInternal;
extern BuiltinAssetEventDefaultTypeInternal _BuiltinAssetEvent_default_instance_;
class BuiltinAssetWithdrawal;
class BuiltinAssetWithdrawalDefaultTypeInternal;
extern BuiltinAssetWithdrawalDefaultTypeInternal _BuiltinAssetWithdrawal_default_instance_;
class ChainEvent;
class ChainEventDefaultTypeInternal;
extern ChainEventDefaultTypeInternal _ChainEvent_default_instance_;
class ERC20AssetDelist;
class ERC20AssetDelistDefaultTypeInternal;
extern ERC20AssetDelistDefaultTypeInternal _ERC20AssetDelist_default_instance_;
class ERC20AssetList;
class ERC20AssetListDefaultTypeInternal;
extern ERC20AssetListDefaultTypeInternal _ERC20AssetList_default_instance_;
class ERC20Deposit;
class ERC20DepositDefaultTypeInternal;
extern ERC20DepositDefaultTypeInternal _ERC20Deposit_default_instance_;
class ERC20Event;
class ERC20EventDefaultTypeInternal;
extern ERC20EventDefaultTypeInternal _ERC20Event_default_instance_;
class ERC20Withdrawal;
class ERC20WithdrawalDefaultTypeInternal;
extern ERC20WithdrawalDefaultTypeInternal _ERC20Withdrawal_default_instance_;
class EthereumAddress;
class EthereumAddressDefaultTypeInternal;
extern EthereumAddressDefaultTypeInternal _EthereumAddress_default_instance_;
class Identifier;
class IdentifierDefaultTypeInternal;
extern IdentifierDefaultTypeInternal _Identifier_default_instance_;
class RemoveValidator;
class RemoveValidatorDefaultTypeInternal;
extern RemoveValidatorDefaultTypeInternal _RemoveValidator_default_instance_;
class ValidatorEvent;
class ValidatorEventDefaultTypeInternal;
extern ValidatorEventDefaultTypeInternal _ValidatorEvent_default_instance_;
}  // namespace vega
namespace google {
namespace protobuf {
template<> ::vega::AddValidator* Arena::CreateMaybeMessage<::vega::AddValidator>(Arena*);
template<> ::vega::BTCDeposit* Arena::CreateMaybeMessage<::vega::BTCDeposit>(Arena*);
template<> ::vega::BTCEvent* Arena::CreateMaybeMessage<::vega::BTCEvent>(Arena*);
template<> ::vega::BTCWithdrawal* Arena::CreateMaybeMessage<::vega::BTCWithdrawal>(Arena*);
template<> ::vega::BitcoinAddress* Arena::CreateMaybeMessage<::vega::BitcoinAddress>(Arena*);
template<> ::vega::BuiltinAssetDeposit* Arena::CreateMaybeMessage<::vega::BuiltinAssetDeposit>(Arena*);
template<> ::vega::BuiltinAssetEvent* Arena::CreateMaybeMessage<::vega::BuiltinAssetEvent>(Arena*);
template<> ::vega::BuiltinAssetWithdrawal* Arena::CreateMaybeMessage<::vega::BuiltinAssetWithdrawal>(Arena*);
template<> ::vega::ChainEvent* Arena::CreateMaybeMessage<::vega::ChainEvent>(Arena*);
template<> ::vega::ERC20AssetDelist* Arena::CreateMaybeMessage<::vega::ERC20AssetDelist>(Arena*);
template<> ::vega::ERC20AssetList* Arena::CreateMaybeMessage<::vega::ERC20AssetList>(Arena*);
template<> ::vega::ERC20Deposit* Arena::CreateMaybeMessage<::vega::ERC20Deposit>(Arena*);
template<> ::vega::ERC20Event* Arena::CreateMaybeMessage<::vega::ERC20Event>(Arena*);
template<> ::vega::ERC20Withdrawal* Arena::CreateMaybeMessage<::vega::ERC20Withdrawal>(Arena*);
template<> ::vega::EthereumAddress* Arena::CreateMaybeMessage<::vega::EthereumAddress>(Arena*);
template<> ::vega::Identifier* Arena::CreateMaybeMessage<::vega::Identifier>(Arena*);
template<> ::vega::RemoveValidator* Arena::CreateMaybeMessage<::vega::RemoveValidator>(Arena*);
template<> ::vega::ValidatorEvent* Arena::CreateMaybeMessage<::vega::ValidatorEvent>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace vega {

// ===================================================================

class BuiltinAssetDeposit :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vega.BuiltinAssetDeposit) */ {
 public:
  BuiltinAssetDeposit();
  virtual ~BuiltinAssetDeposit();

  BuiltinAssetDeposit(const BuiltinAssetDeposit& from);

  inline BuiltinAssetDeposit& operator=(const BuiltinAssetDeposit& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BuiltinAssetDeposit(BuiltinAssetDeposit&& from) noexcept
    : BuiltinAssetDeposit() {
    *this = ::std::move(from);
  }

  inline BuiltinAssetDeposit& operator=(BuiltinAssetDeposit&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const BuiltinAssetDeposit& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BuiltinAssetDeposit* internal_default_instance() {
    return reinterpret_cast<const BuiltinAssetDeposit*>(
               &_BuiltinAssetDeposit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(BuiltinAssetDeposit* other);
  friend void swap(BuiltinAssetDeposit& a, BuiltinAssetDeposit& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BuiltinAssetDeposit* New() const final {
    return CreateMaybeMessage<BuiltinAssetDeposit>(nullptr);
  }

  BuiltinAssetDeposit* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BuiltinAssetDeposit>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BuiltinAssetDeposit& from);
  void MergeFrom(const BuiltinAssetDeposit& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BuiltinAssetDeposit* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string vegaAssetID = 1;
  void clear_vegaassetid();
  static const int kVegaAssetIDFieldNumber = 1;
  const ::std::string& vegaassetid() const;
  void set_vegaassetid(const ::std::string& value);
  #if LANG_CXX11
  void set_vegaassetid(::std::string&& value);
  #endif
  void set_vegaassetid(const char* value);
  void set_vegaassetid(const char* value, size_t size);
  ::std::string* mutable_vegaassetid();
  ::std::string* release_vegaassetid();
  void set_allocated_vegaassetid(::std::string* vegaassetid);

  // string partyID = 2;
  void clear_partyid();
  static const int kPartyIDFieldNumber = 2;
  const ::std::string& partyid() const;
  void set_partyid(const ::std::string& value);
  #if LANG_CXX11
  void set_partyid(::std::string&& value);
  #endif
  void set_partyid(const char* value);
  void set_partyid(const char* value, size_t size);
  ::std::string* mutable_partyid();
  ::std::string* release_partyid();
  void set_allocated_partyid(::std::string* partyid);

  // uint64 amount = 3;
  void clear_amount();
  static const int kAmountFieldNumber = 3;
  ::google::protobuf::uint64 amount() const;
  void set_amount(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:vega.BuiltinAssetDeposit)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr vegaassetid_;
  ::google::protobuf::internal::ArenaStringPtr partyid_;
  ::google::protobuf::uint64 amount_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fchain_5fevents_2eproto;
};
// -------------------------------------------------------------------

class BuiltinAssetWithdrawal :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vega.BuiltinAssetWithdrawal) */ {
 public:
  BuiltinAssetWithdrawal();
  virtual ~BuiltinAssetWithdrawal();

  BuiltinAssetWithdrawal(const BuiltinAssetWithdrawal& from);

  inline BuiltinAssetWithdrawal& operator=(const BuiltinAssetWithdrawal& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BuiltinAssetWithdrawal(BuiltinAssetWithdrawal&& from) noexcept
    : BuiltinAssetWithdrawal() {
    *this = ::std::move(from);
  }

  inline BuiltinAssetWithdrawal& operator=(BuiltinAssetWithdrawal&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const BuiltinAssetWithdrawal& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BuiltinAssetWithdrawal* internal_default_instance() {
    return reinterpret_cast<const BuiltinAssetWithdrawal*>(
               &_BuiltinAssetWithdrawal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(BuiltinAssetWithdrawal* other);
  friend void swap(BuiltinAssetWithdrawal& a, BuiltinAssetWithdrawal& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BuiltinAssetWithdrawal* New() const final {
    return CreateMaybeMessage<BuiltinAssetWithdrawal>(nullptr);
  }

  BuiltinAssetWithdrawal* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BuiltinAssetWithdrawal>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BuiltinAssetWithdrawal& from);
  void MergeFrom(const BuiltinAssetWithdrawal& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BuiltinAssetWithdrawal* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string vegaAssetID = 1;
  void clear_vegaassetid();
  static const int kVegaAssetIDFieldNumber = 1;
  const ::std::string& vegaassetid() const;
  void set_vegaassetid(const ::std::string& value);
  #if LANG_CXX11
  void set_vegaassetid(::std::string&& value);
  #endif
  void set_vegaassetid(const char* value);
  void set_vegaassetid(const char* value, size_t size);
  ::std::string* mutable_vegaassetid();
  ::std::string* release_vegaassetid();
  void set_allocated_vegaassetid(::std::string* vegaassetid);

  // string partyID = 2;
  void clear_partyid();
  static const int kPartyIDFieldNumber = 2;
  const ::std::string& partyid() const;
  void set_partyid(const ::std::string& value);
  #if LANG_CXX11
  void set_partyid(::std::string&& value);
  #endif
  void set_partyid(const char* value);
  void set_partyid(const char* value, size_t size);
  ::std::string* mutable_partyid();
  ::std::string* release_partyid();
  void set_allocated_partyid(::std::string* partyid);

  // uint64 amount = 3;
  void clear_amount();
  static const int kAmountFieldNumber = 3;
  ::google::protobuf::uint64 amount() const;
  void set_amount(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:vega.BuiltinAssetWithdrawal)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr vegaassetid_;
  ::google::protobuf::internal::ArenaStringPtr partyid_;
  ::google::protobuf::uint64 amount_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fchain_5fevents_2eproto;
};
// -------------------------------------------------------------------

class BuiltinAssetEvent :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vega.BuiltinAssetEvent) */ {
 public:
  BuiltinAssetEvent();
  virtual ~BuiltinAssetEvent();

  BuiltinAssetEvent(const BuiltinAssetEvent& from);

  inline BuiltinAssetEvent& operator=(const BuiltinAssetEvent& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BuiltinAssetEvent(BuiltinAssetEvent&& from) noexcept
    : BuiltinAssetEvent() {
    *this = ::std::move(from);
  }

  inline BuiltinAssetEvent& operator=(BuiltinAssetEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const BuiltinAssetEvent& default_instance();

  enum ActionCase {
    kDeposit = 1001,
    kWithdrawal = 1002,
    ACTION_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BuiltinAssetEvent* internal_default_instance() {
    return reinterpret_cast<const BuiltinAssetEvent*>(
               &_BuiltinAssetEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(BuiltinAssetEvent* other);
  friend void swap(BuiltinAssetEvent& a, BuiltinAssetEvent& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BuiltinAssetEvent* New() const final {
    return CreateMaybeMessage<BuiltinAssetEvent>(nullptr);
  }

  BuiltinAssetEvent* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BuiltinAssetEvent>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BuiltinAssetEvent& from);
  void MergeFrom(const BuiltinAssetEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BuiltinAssetEvent* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .vega.BuiltinAssetDeposit deposit = 1001;
  bool has_deposit() const;
  void clear_deposit();
  static const int kDepositFieldNumber = 1001;
  const ::vega::BuiltinAssetDeposit& deposit() const;
  ::vega::BuiltinAssetDeposit* release_deposit();
  ::vega::BuiltinAssetDeposit* mutable_deposit();
  void set_allocated_deposit(::vega::BuiltinAssetDeposit* deposit);

  // .vega.BuiltinAssetWithdrawal withdrawal = 1002;
  bool has_withdrawal() const;
  void clear_withdrawal();
  static const int kWithdrawalFieldNumber = 1002;
  const ::vega::BuiltinAssetWithdrawal& withdrawal() const;
  ::vega::BuiltinAssetWithdrawal* release_withdrawal();
  ::vega::BuiltinAssetWithdrawal* mutable_withdrawal();
  void set_allocated_withdrawal(::vega::BuiltinAssetWithdrawal* withdrawal);

  void clear_action();
  ActionCase action_case() const;
  // @@protoc_insertion_point(class_scope:vega.BuiltinAssetEvent)
 private:
  class HasBitSetters;
  void set_has_deposit();
  void set_has_withdrawal();

  inline bool has_action() const;
  inline void clear_has_action();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union ActionUnion {
    ActionUnion() {}
    ::vega::BuiltinAssetDeposit* deposit_;
    ::vega::BuiltinAssetWithdrawal* withdrawal_;
  } action_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::TableStruct_proto_2fchain_5fevents_2eproto;
};
// -------------------------------------------------------------------

class ERC20AssetList :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vega.ERC20AssetList) */ {
 public:
  ERC20AssetList();
  virtual ~ERC20AssetList();

  ERC20AssetList(const ERC20AssetList& from);

  inline ERC20AssetList& operator=(const ERC20AssetList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ERC20AssetList(ERC20AssetList&& from) noexcept
    : ERC20AssetList() {
    *this = ::std::move(from);
  }

  inline ERC20AssetList& operator=(ERC20AssetList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ERC20AssetList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ERC20AssetList* internal_default_instance() {
    return reinterpret_cast<const ERC20AssetList*>(
               &_ERC20AssetList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(ERC20AssetList* other);
  friend void swap(ERC20AssetList& a, ERC20AssetList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ERC20AssetList* New() const final {
    return CreateMaybeMessage<ERC20AssetList>(nullptr);
  }

  ERC20AssetList* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ERC20AssetList>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ERC20AssetList& from);
  void MergeFrom(const ERC20AssetList& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ERC20AssetList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string vegaAssetID = 1;
  void clear_vegaassetid();
  static const int kVegaAssetIDFieldNumber = 1;
  const ::std::string& vegaassetid() const;
  void set_vegaassetid(const ::std::string& value);
  #if LANG_CXX11
  void set_vegaassetid(::std::string&& value);
  #endif
  void set_vegaassetid(const char* value);
  void set_vegaassetid(const char* value, size_t size);
  ::std::string* mutable_vegaassetid();
  ::std::string* release_vegaassetid();
  void set_allocated_vegaassetid(::std::string* vegaassetid);

  // @@protoc_insertion_point(class_scope:vega.ERC20AssetList)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr vegaassetid_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fchain_5fevents_2eproto;
};
// -------------------------------------------------------------------

class ERC20AssetDelist :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vega.ERC20AssetDelist) */ {
 public:
  ERC20AssetDelist();
  virtual ~ERC20AssetDelist();

  ERC20AssetDelist(const ERC20AssetDelist& from);

  inline ERC20AssetDelist& operator=(const ERC20AssetDelist& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ERC20AssetDelist(ERC20AssetDelist&& from) noexcept
    : ERC20AssetDelist() {
    *this = ::std::move(from);
  }

  inline ERC20AssetDelist& operator=(ERC20AssetDelist&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ERC20AssetDelist& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ERC20AssetDelist* internal_default_instance() {
    return reinterpret_cast<const ERC20AssetDelist*>(
               &_ERC20AssetDelist_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(ERC20AssetDelist* other);
  friend void swap(ERC20AssetDelist& a, ERC20AssetDelist& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ERC20AssetDelist* New() const final {
    return CreateMaybeMessage<ERC20AssetDelist>(nullptr);
  }

  ERC20AssetDelist* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ERC20AssetDelist>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ERC20AssetDelist& from);
  void MergeFrom(const ERC20AssetDelist& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ERC20AssetDelist* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string vegaAssetID = 1;
  void clear_vegaassetid();
  static const int kVegaAssetIDFieldNumber = 1;
  const ::std::string& vegaassetid() const;
  void set_vegaassetid(const ::std::string& value);
  #if LANG_CXX11
  void set_vegaassetid(::std::string&& value);
  #endif
  void set_vegaassetid(const char* value);
  void set_vegaassetid(const char* value, size_t size);
  ::std::string* mutable_vegaassetid();
  ::std::string* release_vegaassetid();
  void set_allocated_vegaassetid(::std::string* vegaassetid);

  // @@protoc_insertion_point(class_scope:vega.ERC20AssetDelist)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr vegaassetid_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fchain_5fevents_2eproto;
};
// -------------------------------------------------------------------

class ERC20Deposit :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vega.ERC20Deposit) */ {
 public:
  ERC20Deposit();
  virtual ~ERC20Deposit();

  ERC20Deposit(const ERC20Deposit& from);

  inline ERC20Deposit& operator=(const ERC20Deposit& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ERC20Deposit(ERC20Deposit&& from) noexcept
    : ERC20Deposit() {
    *this = ::std::move(from);
  }

  inline ERC20Deposit& operator=(ERC20Deposit&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ERC20Deposit& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ERC20Deposit* internal_default_instance() {
    return reinterpret_cast<const ERC20Deposit*>(
               &_ERC20Deposit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(ERC20Deposit* other);
  friend void swap(ERC20Deposit& a, ERC20Deposit& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ERC20Deposit* New() const final {
    return CreateMaybeMessage<ERC20Deposit>(nullptr);
  }

  ERC20Deposit* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ERC20Deposit>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ERC20Deposit& from);
  void MergeFrom(const ERC20Deposit& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ERC20Deposit* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string vegaAssetID = 1;
  void clear_vegaassetid();
  static const int kVegaAssetIDFieldNumber = 1;
  const ::std::string& vegaassetid() const;
  void set_vegaassetid(const ::std::string& value);
  #if LANG_CXX11
  void set_vegaassetid(::std::string&& value);
  #endif
  void set_vegaassetid(const char* value);
  void set_vegaassetid(const char* value, size_t size);
  ::std::string* mutable_vegaassetid();
  ::std::string* release_vegaassetid();
  void set_allocated_vegaassetid(::std::string* vegaassetid);

  // string sourceEthereumAddress = 2;
  void clear_sourceethereumaddress();
  static const int kSourceEthereumAddressFieldNumber = 2;
  const ::std::string& sourceethereumaddress() const;
  void set_sourceethereumaddress(const ::std::string& value);
  #if LANG_CXX11
  void set_sourceethereumaddress(::std::string&& value);
  #endif
  void set_sourceethereumaddress(const char* value);
  void set_sourceethereumaddress(const char* value, size_t size);
  ::std::string* mutable_sourceethereumaddress();
  ::std::string* release_sourceethereumaddress();
  void set_allocated_sourceethereumaddress(::std::string* sourceethereumaddress);

  // string targetPartyID = 3;
  void clear_targetpartyid();
  static const int kTargetPartyIDFieldNumber = 3;
  const ::std::string& targetpartyid() const;
  void set_targetpartyid(const ::std::string& value);
  #if LANG_CXX11
  void set_targetpartyid(::std::string&& value);
  #endif
  void set_targetpartyid(const char* value);
  void set_targetpartyid(const char* value, size_t size);
  ::std::string* mutable_targetpartyid();
  ::std::string* release_targetpartyid();
  void set_allocated_targetpartyid(::std::string* targetpartyid);

  // @@protoc_insertion_point(class_scope:vega.ERC20Deposit)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr vegaassetid_;
  ::google::protobuf::internal::ArenaStringPtr sourceethereumaddress_;
  ::google::protobuf::internal::ArenaStringPtr targetpartyid_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fchain_5fevents_2eproto;
};
// -------------------------------------------------------------------

class ERC20Withdrawal :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vega.ERC20Withdrawal) */ {
 public:
  ERC20Withdrawal();
  virtual ~ERC20Withdrawal();

  ERC20Withdrawal(const ERC20Withdrawal& from);

  inline ERC20Withdrawal& operator=(const ERC20Withdrawal& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ERC20Withdrawal(ERC20Withdrawal&& from) noexcept
    : ERC20Withdrawal() {
    *this = ::std::move(from);
  }

  inline ERC20Withdrawal& operator=(ERC20Withdrawal&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ERC20Withdrawal& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ERC20Withdrawal* internal_default_instance() {
    return reinterpret_cast<const ERC20Withdrawal*>(
               &_ERC20Withdrawal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(ERC20Withdrawal* other);
  friend void swap(ERC20Withdrawal& a, ERC20Withdrawal& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ERC20Withdrawal* New() const final {
    return CreateMaybeMessage<ERC20Withdrawal>(nullptr);
  }

  ERC20Withdrawal* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ERC20Withdrawal>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ERC20Withdrawal& from);
  void MergeFrom(const ERC20Withdrawal& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ERC20Withdrawal* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string vegaAssetID = 1;
  void clear_vegaassetid();
  static const int kVegaAssetIDFieldNumber = 1;
  const ::std::string& vegaassetid() const;
  void set_vegaassetid(const ::std::string& value);
  #if LANG_CXX11
  void set_vegaassetid(::std::string&& value);
  #endif
  void set_vegaassetid(const char* value);
  void set_vegaassetid(const char* value, size_t size);
  ::std::string* mutable_vegaassetid();
  ::std::string* release_vegaassetid();
  void set_allocated_vegaassetid(::std::string* vegaassetid);

  // string targetEthereumAddress = 2;
  void clear_targetethereumaddress();
  static const int kTargetEthereumAddressFieldNumber = 2;
  const ::std::string& targetethereumaddress() const;
  void set_targetethereumaddress(const ::std::string& value);
  #if LANG_CXX11
  void set_targetethereumaddress(::std::string&& value);
  #endif
  void set_targetethereumaddress(const char* value);
  void set_targetethereumaddress(const char* value, size_t size);
  ::std::string* mutable_targetethereumaddress();
  ::std::string* release_targetethereumaddress();
  void set_allocated_targetethereumaddress(::std::string* targetethereumaddress);

  // string referenceNonce = 3;
  void clear_referencenonce();
  static const int kReferenceNonceFieldNumber = 3;
  const ::std::string& referencenonce() const;
  void set_referencenonce(const ::std::string& value);
  #if LANG_CXX11
  void set_referencenonce(::std::string&& value);
  #endif
  void set_referencenonce(const char* value);
  void set_referencenonce(const char* value, size_t size);
  ::std::string* mutable_referencenonce();
  ::std::string* release_referencenonce();
  void set_allocated_referencenonce(::std::string* referencenonce);

  // @@protoc_insertion_point(class_scope:vega.ERC20Withdrawal)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr vegaassetid_;
  ::google::protobuf::internal::ArenaStringPtr targetethereumaddress_;
  ::google::protobuf::internal::ArenaStringPtr referencenonce_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fchain_5fevents_2eproto;
};
// -------------------------------------------------------------------

class ERC20Event :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vega.ERC20Event) */ {
 public:
  ERC20Event();
  virtual ~ERC20Event();

  ERC20Event(const ERC20Event& from);

  inline ERC20Event& operator=(const ERC20Event& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ERC20Event(ERC20Event&& from) noexcept
    : ERC20Event() {
    *this = ::std::move(from);
  }

  inline ERC20Event& operator=(ERC20Event&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ERC20Event& default_instance();

  enum ActionCase {
    kAssetList = 1001,
    kAssetDelist = 1002,
    kDeposit = 1003,
    kWithdrawal = 1004,
    ACTION_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ERC20Event* internal_default_instance() {
    return reinterpret_cast<const ERC20Event*>(
               &_ERC20Event_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(ERC20Event* other);
  friend void swap(ERC20Event& a, ERC20Event& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ERC20Event* New() const final {
    return CreateMaybeMessage<ERC20Event>(nullptr);
  }

  ERC20Event* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ERC20Event>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ERC20Event& from);
  void MergeFrom(const ERC20Event& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ERC20Event* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint64 index = 1;
  void clear_index();
  static const int kIndexFieldNumber = 1;
  ::google::protobuf::uint64 index() const;
  void set_index(::google::protobuf::uint64 value);

  // uint64 block = 2;
  void clear_block();
  static const int kBlockFieldNumber = 2;
  ::google::protobuf::uint64 block() const;
  void set_block(::google::protobuf::uint64 value);

  // .vega.ERC20AssetList assetList = 1001;
  bool has_assetlist() const;
  void clear_assetlist();
  static const int kAssetListFieldNumber = 1001;
  const ::vega::ERC20AssetList& assetlist() const;
  ::vega::ERC20AssetList* release_assetlist();
  ::vega::ERC20AssetList* mutable_assetlist();
  void set_allocated_assetlist(::vega::ERC20AssetList* assetlist);

  // .vega.ERC20AssetDelist assetDelist = 1002;
  bool has_assetdelist() const;
  void clear_assetdelist();
  static const int kAssetDelistFieldNumber = 1002;
  const ::vega::ERC20AssetDelist& assetdelist() const;
  ::vega::ERC20AssetDelist* release_assetdelist();
  ::vega::ERC20AssetDelist* mutable_assetdelist();
  void set_allocated_assetdelist(::vega::ERC20AssetDelist* assetdelist);

  // .vega.ERC20Deposit deposit = 1003;
  bool has_deposit() const;
  void clear_deposit();
  static const int kDepositFieldNumber = 1003;
  const ::vega::ERC20Deposit& deposit() const;
  ::vega::ERC20Deposit* release_deposit();
  ::vega::ERC20Deposit* mutable_deposit();
  void set_allocated_deposit(::vega::ERC20Deposit* deposit);

  // .vega.ERC20Withdrawal withdrawal = 1004;
  bool has_withdrawal() const;
  void clear_withdrawal();
  static const int kWithdrawalFieldNumber = 1004;
  const ::vega::ERC20Withdrawal& withdrawal() const;
  ::vega::ERC20Withdrawal* release_withdrawal();
  ::vega::ERC20Withdrawal* mutable_withdrawal();
  void set_allocated_withdrawal(::vega::ERC20Withdrawal* withdrawal);

  void clear_action();
  ActionCase action_case() const;
  // @@protoc_insertion_point(class_scope:vega.ERC20Event)
 private:
  class HasBitSetters;
  void set_has_assetlist();
  void set_has_assetdelist();
  void set_has_deposit();
  void set_has_withdrawal();

  inline bool has_action() const;
  inline void clear_has_action();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint64 index_;
  ::google::protobuf::uint64 block_;
  union ActionUnion {
    ActionUnion() {}
    ::vega::ERC20AssetList* assetlist_;
    ::vega::ERC20AssetDelist* assetdelist_;
    ::vega::ERC20Deposit* deposit_;
    ::vega::ERC20Withdrawal* withdrawal_;
  } action_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::TableStruct_proto_2fchain_5fevents_2eproto;
};
// -------------------------------------------------------------------

class BTCDeposit :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vega.BTCDeposit) */ {
 public:
  BTCDeposit();
  virtual ~BTCDeposit();

  BTCDeposit(const BTCDeposit& from);

  inline BTCDeposit& operator=(const BTCDeposit& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BTCDeposit(BTCDeposit&& from) noexcept
    : BTCDeposit() {
    *this = ::std::move(from);
  }

  inline BTCDeposit& operator=(BTCDeposit&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const BTCDeposit& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BTCDeposit* internal_default_instance() {
    return reinterpret_cast<const BTCDeposit*>(
               &_BTCDeposit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(BTCDeposit* other);
  friend void swap(BTCDeposit& a, BTCDeposit& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BTCDeposit* New() const final {
    return CreateMaybeMessage<BTCDeposit>(nullptr);
  }

  BTCDeposit* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BTCDeposit>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BTCDeposit& from);
  void MergeFrom(const BTCDeposit& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BTCDeposit* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string vegaAssetID = 1;
  void clear_vegaassetid();
  static const int kVegaAssetIDFieldNumber = 1;
  const ::std::string& vegaassetid() const;
  void set_vegaassetid(const ::std::string& value);
  #if LANG_CXX11
  void set_vegaassetid(::std::string&& value);
  #endif
  void set_vegaassetid(const char* value);
  void set_vegaassetid(const char* value, size_t size);
  ::std::string* mutable_vegaassetid();
  ::std::string* release_vegaassetid();
  void set_allocated_vegaassetid(::std::string* vegaassetid);

  // string sourceBTCAddress = 2;
  void clear_sourcebtcaddress();
  static const int kSourceBTCAddressFieldNumber = 2;
  const ::std::string& sourcebtcaddress() const;
  void set_sourcebtcaddress(const ::std::string& value);
  #if LANG_CXX11
  void set_sourcebtcaddress(::std::string&& value);
  #endif
  void set_sourcebtcaddress(const char* value);
  void set_sourcebtcaddress(const char* value, size_t size);
  ::std::string* mutable_sourcebtcaddress();
  ::std::string* release_sourcebtcaddress();
  void set_allocated_sourcebtcaddress(::std::string* sourcebtcaddress);

  // string targetPartyId = 3;
  void clear_targetpartyid();
  static const int kTargetPartyIdFieldNumber = 3;
  const ::std::string& targetpartyid() const;
  void set_targetpartyid(const ::std::string& value);
  #if LANG_CXX11
  void set_targetpartyid(::std::string&& value);
  #endif
  void set_targetpartyid(const char* value);
  void set_targetpartyid(const char* value, size_t size);
  ::std::string* mutable_targetpartyid();
  ::std::string* release_targetpartyid();
  void set_allocated_targetpartyid(::std::string* targetpartyid);

  // @@protoc_insertion_point(class_scope:vega.BTCDeposit)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr vegaassetid_;
  ::google::protobuf::internal::ArenaStringPtr sourcebtcaddress_;
  ::google::protobuf::internal::ArenaStringPtr targetpartyid_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fchain_5fevents_2eproto;
};
// -------------------------------------------------------------------

class BTCWithdrawal :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vega.BTCWithdrawal) */ {
 public:
  BTCWithdrawal();
  virtual ~BTCWithdrawal();

  BTCWithdrawal(const BTCWithdrawal& from);

  inline BTCWithdrawal& operator=(const BTCWithdrawal& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BTCWithdrawal(BTCWithdrawal&& from) noexcept
    : BTCWithdrawal() {
    *this = ::std::move(from);
  }

  inline BTCWithdrawal& operator=(BTCWithdrawal&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const BTCWithdrawal& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BTCWithdrawal* internal_default_instance() {
    return reinterpret_cast<const BTCWithdrawal*>(
               &_BTCWithdrawal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(BTCWithdrawal* other);
  friend void swap(BTCWithdrawal& a, BTCWithdrawal& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BTCWithdrawal* New() const final {
    return CreateMaybeMessage<BTCWithdrawal>(nullptr);
  }

  BTCWithdrawal* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BTCWithdrawal>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BTCWithdrawal& from);
  void MergeFrom(const BTCWithdrawal& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BTCWithdrawal* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string vegaAssetID = 1;
  void clear_vegaassetid();
  static const int kVegaAssetIDFieldNumber = 1;
  const ::std::string& vegaassetid() const;
  void set_vegaassetid(const ::std::string& value);
  #if LANG_CXX11
  void set_vegaassetid(::std::string&& value);
  #endif
  void set_vegaassetid(const char* value);
  void set_vegaassetid(const char* value, size_t size);
  ::std::string* mutable_vegaassetid();
  ::std::string* release_vegaassetid();
  void set_allocated_vegaassetid(::std::string* vegaassetid);

  // string sourcePartyId = 2;
  void clear_sourcepartyid();
  static const int kSourcePartyIdFieldNumber = 2;
  const ::std::string& sourcepartyid() const;
  void set_sourcepartyid(const ::std::string& value);
  #if LANG_CXX11
  void set_sourcepartyid(::std::string&& value);
  #endif
  void set_sourcepartyid(const char* value);
  void set_sourcepartyid(const char* value, size_t size);
  ::std::string* mutable_sourcepartyid();
  ::std::string* release_sourcepartyid();
  void set_allocated_sourcepartyid(::std::string* sourcepartyid);

  // string targetBTCAddress = 3;
  void clear_targetbtcaddress();
  static const int kTargetBTCAddressFieldNumber = 3;
  const ::std::string& targetbtcaddress() const;
  void set_targetbtcaddress(const ::std::string& value);
  #if LANG_CXX11
  void set_targetbtcaddress(::std::string&& value);
  #endif
  void set_targetbtcaddress(const char* value);
  void set_targetbtcaddress(const char* value, size_t size);
  ::std::string* mutable_targetbtcaddress();
  ::std::string* release_targetbtcaddress();
  void set_allocated_targetbtcaddress(::std::string* targetbtcaddress);

  // string referenceNonce = 4;
  void clear_referencenonce();
  static const int kReferenceNonceFieldNumber = 4;
  const ::std::string& referencenonce() const;
  void set_referencenonce(const ::std::string& value);
  #if LANG_CXX11
  void set_referencenonce(::std::string&& value);
  #endif
  void set_referencenonce(const char* value);
  void set_referencenonce(const char* value, size_t size);
  ::std::string* mutable_referencenonce();
  ::std::string* release_referencenonce();
  void set_allocated_referencenonce(::std::string* referencenonce);

  // @@protoc_insertion_point(class_scope:vega.BTCWithdrawal)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr vegaassetid_;
  ::google::protobuf::internal::ArenaStringPtr sourcepartyid_;
  ::google::protobuf::internal::ArenaStringPtr targetbtcaddress_;
  ::google::protobuf::internal::ArenaStringPtr referencenonce_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fchain_5fevents_2eproto;
};
// -------------------------------------------------------------------

class BTCEvent :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vega.BTCEvent) */ {
 public:
  BTCEvent();
  virtual ~BTCEvent();

  BTCEvent(const BTCEvent& from);

  inline BTCEvent& operator=(const BTCEvent& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BTCEvent(BTCEvent&& from) noexcept
    : BTCEvent() {
    *this = ::std::move(from);
  }

  inline BTCEvent& operator=(BTCEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const BTCEvent& default_instance();

  enum ActionCase {
    kDeposit = 1001,
    kWithdrawal = 1002,
    ACTION_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BTCEvent* internal_default_instance() {
    return reinterpret_cast<const BTCEvent*>(
               &_BTCEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(BTCEvent* other);
  friend void swap(BTCEvent& a, BTCEvent& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BTCEvent* New() const final {
    return CreateMaybeMessage<BTCEvent>(nullptr);
  }

  BTCEvent* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BTCEvent>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BTCEvent& from);
  void MergeFrom(const BTCEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BTCEvent* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint64 index = 1;
  void clear_index();
  static const int kIndexFieldNumber = 1;
  ::google::protobuf::uint64 index() const;
  void set_index(::google::protobuf::uint64 value);

  // uint64 block = 2;
  void clear_block();
  static const int kBlockFieldNumber = 2;
  ::google::protobuf::uint64 block() const;
  void set_block(::google::protobuf::uint64 value);

  // .vega.BTCDeposit deposit = 1001;
  bool has_deposit() const;
  void clear_deposit();
  static const int kDepositFieldNumber = 1001;
  const ::vega::BTCDeposit& deposit() const;
  ::vega::BTCDeposit* release_deposit();
  ::vega::BTCDeposit* mutable_deposit();
  void set_allocated_deposit(::vega::BTCDeposit* deposit);

  // .vega.BTCWithdrawal withdrawal = 1002;
  bool has_withdrawal() const;
  void clear_withdrawal();
  static const int kWithdrawalFieldNumber = 1002;
  const ::vega::BTCWithdrawal& withdrawal() const;
  ::vega::BTCWithdrawal* release_withdrawal();
  ::vega::BTCWithdrawal* mutable_withdrawal();
  void set_allocated_withdrawal(::vega::BTCWithdrawal* withdrawal);

  void clear_action();
  ActionCase action_case() const;
  // @@protoc_insertion_point(class_scope:vega.BTCEvent)
 private:
  class HasBitSetters;
  void set_has_deposit();
  void set_has_withdrawal();

  inline bool has_action() const;
  inline void clear_has_action();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint64 index_;
  ::google::protobuf::uint64 block_;
  union ActionUnion {
    ActionUnion() {}
    ::vega::BTCDeposit* deposit_;
    ::vega::BTCWithdrawal* withdrawal_;
  } action_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::TableStruct_proto_2fchain_5fevents_2eproto;
};
// -------------------------------------------------------------------

class EthereumAddress :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vega.EthereumAddress) */ {
 public:
  EthereumAddress();
  virtual ~EthereumAddress();

  EthereumAddress(const EthereumAddress& from);

  inline EthereumAddress& operator=(const EthereumAddress& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EthereumAddress(EthereumAddress&& from) noexcept
    : EthereumAddress() {
    *this = ::std::move(from);
  }

  inline EthereumAddress& operator=(EthereumAddress&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const EthereumAddress& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EthereumAddress* internal_default_instance() {
    return reinterpret_cast<const EthereumAddress*>(
               &_EthereumAddress_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(EthereumAddress* other);
  friend void swap(EthereumAddress& a, EthereumAddress& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EthereumAddress* New() const final {
    return CreateMaybeMessage<EthereumAddress>(nullptr);
  }

  EthereumAddress* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EthereumAddress>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const EthereumAddress& from);
  void MergeFrom(const EthereumAddress& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EthereumAddress* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string address = 1;
  void clear_address();
  static const int kAddressFieldNumber = 1;
  const ::std::string& address() const;
  void set_address(const ::std::string& value);
  #if LANG_CXX11
  void set_address(::std::string&& value);
  #endif
  void set_address(const char* value);
  void set_address(const char* value, size_t size);
  ::std::string* mutable_address();
  ::std::string* release_address();
  void set_allocated_address(::std::string* address);

  // @@protoc_insertion_point(class_scope:vega.EthereumAddress)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr address_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fchain_5fevents_2eproto;
};
// -------------------------------------------------------------------

class BitcoinAddress :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vega.BitcoinAddress) */ {
 public:
  BitcoinAddress();
  virtual ~BitcoinAddress();

  BitcoinAddress(const BitcoinAddress& from);

  inline BitcoinAddress& operator=(const BitcoinAddress& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BitcoinAddress(BitcoinAddress&& from) noexcept
    : BitcoinAddress() {
    *this = ::std::move(from);
  }

  inline BitcoinAddress& operator=(BitcoinAddress&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const BitcoinAddress& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BitcoinAddress* internal_default_instance() {
    return reinterpret_cast<const BitcoinAddress*>(
               &_BitcoinAddress_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(BitcoinAddress* other);
  friend void swap(BitcoinAddress& a, BitcoinAddress& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BitcoinAddress* New() const final {
    return CreateMaybeMessage<BitcoinAddress>(nullptr);
  }

  BitcoinAddress* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BitcoinAddress>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BitcoinAddress& from);
  void MergeFrom(const BitcoinAddress& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BitcoinAddress* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string address = 1;
  void clear_address();
  static const int kAddressFieldNumber = 1;
  const ::std::string& address() const;
  void set_address(const ::std::string& value);
  #if LANG_CXX11
  void set_address(::std::string&& value);
  #endif
  void set_address(const char* value);
  void set_address(const char* value, size_t size);
  ::std::string* mutable_address();
  ::std::string* release_address();
  void set_allocated_address(::std::string* address);

  // @@protoc_insertion_point(class_scope:vega.BitcoinAddress)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr address_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fchain_5fevents_2eproto;
};
// -------------------------------------------------------------------

class Identifier :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vega.Identifier) */ {
 public:
  Identifier();
  virtual ~Identifier();

  Identifier(const Identifier& from);

  inline Identifier& operator=(const Identifier& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Identifier(Identifier&& from) noexcept
    : Identifier() {
    *this = ::std::move(from);
  }

  inline Identifier& operator=(Identifier&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Identifier& default_instance();

  enum IdentifierCase {
    kEthereumAddress = 1,
    kBitcoinAddress = 2,
    IDENTIFIER_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Identifier* internal_default_instance() {
    return reinterpret_cast<const Identifier*>(
               &_Identifier_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(Identifier* other);
  friend void swap(Identifier& a, Identifier& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Identifier* New() const final {
    return CreateMaybeMessage<Identifier>(nullptr);
  }

  Identifier* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Identifier>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Identifier& from);
  void MergeFrom(const Identifier& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Identifier* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .vega.EthereumAddress ethereumAddress = 1;
  bool has_ethereumaddress() const;
  void clear_ethereumaddress();
  static const int kEthereumAddressFieldNumber = 1;
  const ::vega::EthereumAddress& ethereumaddress() const;
  ::vega::EthereumAddress* release_ethereumaddress();
  ::vega::EthereumAddress* mutable_ethereumaddress();
  void set_allocated_ethereumaddress(::vega::EthereumAddress* ethereumaddress);

  // .vega.BitcoinAddress bitcoinAddress = 2;
  bool has_bitcoinaddress() const;
  void clear_bitcoinaddress();
  static const int kBitcoinAddressFieldNumber = 2;
  const ::vega::BitcoinAddress& bitcoinaddress() const;
  ::vega::BitcoinAddress* release_bitcoinaddress();
  ::vega::BitcoinAddress* mutable_bitcoinaddress();
  void set_allocated_bitcoinaddress(::vega::BitcoinAddress* bitcoinaddress);

  void clear_identifier();
  IdentifierCase identifier_case() const;
  // @@protoc_insertion_point(class_scope:vega.Identifier)
 private:
  class HasBitSetters;
  void set_has_ethereumaddress();
  void set_has_bitcoinaddress();

  inline bool has_identifier() const;
  inline void clear_has_identifier();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union IdentifierUnion {
    IdentifierUnion() {}
    ::vega::EthereumAddress* ethereumaddress_;
    ::vega::BitcoinAddress* bitcoinaddress_;
  } identifier_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::TableStruct_proto_2fchain_5fevents_2eproto;
};
// -------------------------------------------------------------------

class AddValidator :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vega.AddValidator) */ {
 public:
  AddValidator();
  virtual ~AddValidator();

  AddValidator(const AddValidator& from);

  inline AddValidator& operator=(const AddValidator& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AddValidator(AddValidator&& from) noexcept
    : AddValidator() {
    *this = ::std::move(from);
  }

  inline AddValidator& operator=(AddValidator&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const AddValidator& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AddValidator* internal_default_instance() {
    return reinterpret_cast<const AddValidator*>(
               &_AddValidator_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(AddValidator* other);
  friend void swap(AddValidator& a, AddValidator& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AddValidator* New() const final {
    return CreateMaybeMessage<AddValidator>(nullptr);
  }

  AddValidator* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AddValidator>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AddValidator& from);
  void MergeFrom(const AddValidator& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddValidator* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .vega.Identifier id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::vega::Identifier& id() const;
  ::vega::Identifier* release_id();
  ::vega::Identifier* mutable_id();
  void set_allocated_id(::vega::Identifier* id);

  // @@protoc_insertion_point(class_scope:vega.AddValidator)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::vega::Identifier* id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fchain_5fevents_2eproto;
};
// -------------------------------------------------------------------

class RemoveValidator :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vega.RemoveValidator) */ {
 public:
  RemoveValidator();
  virtual ~RemoveValidator();

  RemoveValidator(const RemoveValidator& from);

  inline RemoveValidator& operator=(const RemoveValidator& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RemoveValidator(RemoveValidator&& from) noexcept
    : RemoveValidator() {
    *this = ::std::move(from);
  }

  inline RemoveValidator& operator=(RemoveValidator&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const RemoveValidator& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RemoveValidator* internal_default_instance() {
    return reinterpret_cast<const RemoveValidator*>(
               &_RemoveValidator_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(RemoveValidator* other);
  friend void swap(RemoveValidator& a, RemoveValidator& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RemoveValidator* New() const final {
    return CreateMaybeMessage<RemoveValidator>(nullptr);
  }

  RemoveValidator* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RemoveValidator>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RemoveValidator& from);
  void MergeFrom(const RemoveValidator& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RemoveValidator* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .vega.Identifier id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::vega::Identifier& id() const;
  ::vega::Identifier* release_id();
  ::vega::Identifier* mutable_id();
  void set_allocated_id(::vega::Identifier* id);

  // @@protoc_insertion_point(class_scope:vega.RemoveValidator)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::vega::Identifier* id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fchain_5fevents_2eproto;
};
// -------------------------------------------------------------------

class ValidatorEvent :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vega.ValidatorEvent) */ {
 public:
  ValidatorEvent();
  virtual ~ValidatorEvent();

  ValidatorEvent(const ValidatorEvent& from);

  inline ValidatorEvent& operator=(const ValidatorEvent& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ValidatorEvent(ValidatorEvent&& from) noexcept
    : ValidatorEvent() {
    *this = ::std::move(from);
  }

  inline ValidatorEvent& operator=(ValidatorEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ValidatorEvent& default_instance();

  enum ActionCase {
    kAdd = 1001,
    kRm = 1002,
    ACTION_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ValidatorEvent* internal_default_instance() {
    return reinterpret_cast<const ValidatorEvent*>(
               &_ValidatorEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(ValidatorEvent* other);
  friend void swap(ValidatorEvent& a, ValidatorEvent& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ValidatorEvent* New() const final {
    return CreateMaybeMessage<ValidatorEvent>(nullptr);
  }

  ValidatorEvent* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ValidatorEvent>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ValidatorEvent& from);
  void MergeFrom(const ValidatorEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ValidatorEvent* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string sourceID = 1;
  void clear_sourceid();
  static const int kSourceIDFieldNumber = 1;
  const ::std::string& sourceid() const;
  void set_sourceid(const ::std::string& value);
  #if LANG_CXX11
  void set_sourceid(::std::string&& value);
  #endif
  void set_sourceid(const char* value);
  void set_sourceid(const char* value, size_t size);
  ::std::string* mutable_sourceid();
  ::std::string* release_sourceid();
  void set_allocated_sourceid(::std::string* sourceid);

  // .vega.AddValidator add = 1001;
  bool has_add() const;
  void clear_add();
  static const int kAddFieldNumber = 1001;
  const ::vega::AddValidator& add() const;
  ::vega::AddValidator* release_add();
  ::vega::AddValidator* mutable_add();
  void set_allocated_add(::vega::AddValidator* add);

  // .vega.RemoveValidator rm = 1002;
  bool has_rm() const;
  void clear_rm();
  static const int kRmFieldNumber = 1002;
  const ::vega::RemoveValidator& rm() const;
  ::vega::RemoveValidator* release_rm();
  ::vega::RemoveValidator* mutable_rm();
  void set_allocated_rm(::vega::RemoveValidator* rm);

  void clear_action();
  ActionCase action_case() const;
  // @@protoc_insertion_point(class_scope:vega.ValidatorEvent)
 private:
  class HasBitSetters;
  void set_has_add();
  void set_has_rm();

  inline bool has_action() const;
  inline void clear_has_action();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr sourceid_;
  union ActionUnion {
    ActionUnion() {}
    ::vega::AddValidator* add_;
    ::vega::RemoveValidator* rm_;
  } action_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::TableStruct_proto_2fchain_5fevents_2eproto;
};
// -------------------------------------------------------------------

class ChainEvent :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vega.ChainEvent) */ {
 public:
  ChainEvent();
  virtual ~ChainEvent();

  ChainEvent(const ChainEvent& from);

  inline ChainEvent& operator=(const ChainEvent& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ChainEvent(ChainEvent&& from) noexcept
    : ChainEvent() {
    *this = ::std::move(from);
  }

  inline ChainEvent& operator=(ChainEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ChainEvent& default_instance();

  enum EventCase {
    kBuiltin = 1001,
    kErc20 = 1002,
    kBtc = 1003,
    kValidator = 1004,
    EVENT_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ChainEvent* internal_default_instance() {
    return reinterpret_cast<const ChainEvent*>(
               &_ChainEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(ChainEvent* other);
  friend void swap(ChainEvent& a, ChainEvent& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ChainEvent* New() const final {
    return CreateMaybeMessage<ChainEvent>(nullptr);
  }

  ChainEvent* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ChainEvent>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ChainEvent& from);
  void MergeFrom(const ChainEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChainEvent* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string txID = 1;
  void clear_txid();
  static const int kTxIDFieldNumber = 1;
  const ::std::string& txid() const;
  void set_txid(const ::std::string& value);
  #if LANG_CXX11
  void set_txid(::std::string&& value);
  #endif
  void set_txid(const char* value);
  void set_txid(const char* value, size_t size);
  ::std::string* mutable_txid();
  ::std::string* release_txid();
  void set_allocated_txid(::std::string* txid);

  // uint64 nonce = 2;
  void clear_nonce();
  static const int kNonceFieldNumber = 2;
  ::google::protobuf::uint64 nonce() const;
  void set_nonce(::google::protobuf::uint64 value);

  // .vega.BuiltinAssetEvent builtin = 1001;
  bool has_builtin() const;
  void clear_builtin();
  static const int kBuiltinFieldNumber = 1001;
  const ::vega::BuiltinAssetEvent& builtin() const;
  ::vega::BuiltinAssetEvent* release_builtin();
  ::vega::BuiltinAssetEvent* mutable_builtin();
  void set_allocated_builtin(::vega::BuiltinAssetEvent* builtin);

  // .vega.ERC20Event erc20 = 1002;
  bool has_erc20() const;
  void clear_erc20();
  static const int kErc20FieldNumber = 1002;
  const ::vega::ERC20Event& erc20() const;
  ::vega::ERC20Event* release_erc20();
  ::vega::ERC20Event* mutable_erc20();
  void set_allocated_erc20(::vega::ERC20Event* erc20);

  // .vega.BTCEvent btc = 1003;
  bool has_btc() const;
  void clear_btc();
  static const int kBtcFieldNumber = 1003;
  const ::vega::BTCEvent& btc() const;
  ::vega::BTCEvent* release_btc();
  ::vega::BTCEvent* mutable_btc();
  void set_allocated_btc(::vega::BTCEvent* btc);

  // .vega.ValidatorEvent validator = 1004;
  bool has_validator() const;
  void clear_validator();
  static const int kValidatorFieldNumber = 1004;
  const ::vega::ValidatorEvent& validator() const;
  ::vega::ValidatorEvent* release_validator();
  ::vega::ValidatorEvent* mutable_validator();
  void set_allocated_validator(::vega::ValidatorEvent* validator);

  void clear_event();
  EventCase event_case() const;
  // @@protoc_insertion_point(class_scope:vega.ChainEvent)
 private:
  class HasBitSetters;
  void set_has_builtin();
  void set_has_erc20();
  void set_has_btc();
  void set_has_validator();

  inline bool has_event() const;
  inline void clear_has_event();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr txid_;
  ::google::protobuf::uint64 nonce_;
  union EventUnion {
    EventUnion() {}
    ::vega::BuiltinAssetEvent* builtin_;
    ::vega::ERC20Event* erc20_;
    ::vega::BTCEvent* btc_;
    ::vega::ValidatorEvent* validator_;
  } event_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::TableStruct_proto_2fchain_5fevents_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// BuiltinAssetDeposit

// string vegaAssetID = 1;
inline void BuiltinAssetDeposit::clear_vegaassetid() {
  vegaassetid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BuiltinAssetDeposit::vegaassetid() const {
  // @@protoc_insertion_point(field_get:vega.BuiltinAssetDeposit.vegaAssetID)
  return vegaassetid_.GetNoArena();
}
inline void BuiltinAssetDeposit::set_vegaassetid(const ::std::string& value) {

  vegaassetid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vega.BuiltinAssetDeposit.vegaAssetID)
}
#if LANG_CXX11
inline void BuiltinAssetDeposit::set_vegaassetid(::std::string&& value) {

  vegaassetid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vega.BuiltinAssetDeposit.vegaAssetID)
}
#endif
inline void BuiltinAssetDeposit::set_vegaassetid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  vegaassetid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vega.BuiltinAssetDeposit.vegaAssetID)
}
inline void BuiltinAssetDeposit::set_vegaassetid(const char* value, size_t size) {

  vegaassetid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vega.BuiltinAssetDeposit.vegaAssetID)
}
inline ::std::string* BuiltinAssetDeposit::mutable_vegaassetid() {

  // @@protoc_insertion_point(field_mutable:vega.BuiltinAssetDeposit.vegaAssetID)
  return vegaassetid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BuiltinAssetDeposit::release_vegaassetid() {
  // @@protoc_insertion_point(field_release:vega.BuiltinAssetDeposit.vegaAssetID)

  return vegaassetid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BuiltinAssetDeposit::set_allocated_vegaassetid(::std::string* vegaassetid) {
  if (vegaassetid != nullptr) {

  } else {

  }
  vegaassetid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), vegaassetid);
  // @@protoc_insertion_point(field_set_allocated:vega.BuiltinAssetDeposit.vegaAssetID)
}

// string partyID = 2;
inline void BuiltinAssetDeposit::clear_partyid() {
  partyid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BuiltinAssetDeposit::partyid() const {
  // @@protoc_insertion_point(field_get:vega.BuiltinAssetDeposit.partyID)
  return partyid_.GetNoArena();
}
inline void BuiltinAssetDeposit::set_partyid(const ::std::string& value) {

  partyid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vega.BuiltinAssetDeposit.partyID)
}
#if LANG_CXX11
inline void BuiltinAssetDeposit::set_partyid(::std::string&& value) {

  partyid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vega.BuiltinAssetDeposit.partyID)
}
#endif
inline void BuiltinAssetDeposit::set_partyid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  partyid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vega.BuiltinAssetDeposit.partyID)
}
inline void BuiltinAssetDeposit::set_partyid(const char* value, size_t size) {

  partyid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vega.BuiltinAssetDeposit.partyID)
}
inline ::std::string* BuiltinAssetDeposit::mutable_partyid() {

  // @@protoc_insertion_point(field_mutable:vega.BuiltinAssetDeposit.partyID)
  return partyid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BuiltinAssetDeposit::release_partyid() {
  // @@protoc_insertion_point(field_release:vega.BuiltinAssetDeposit.partyID)

  return partyid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BuiltinAssetDeposit::set_allocated_partyid(::std::string* partyid) {
  if (partyid != nullptr) {

  } else {

  }
  partyid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), partyid);
  // @@protoc_insertion_point(field_set_allocated:vega.BuiltinAssetDeposit.partyID)
}

// uint64 amount = 3;
inline void BuiltinAssetDeposit::clear_amount() {
  amount_ = PROTOBUF_ULONGLONG(0);
}
inline ::google::protobuf::uint64 BuiltinAssetDeposit::amount() const {
  // @@protoc_insertion_point(field_get:vega.BuiltinAssetDeposit.amount)
  return amount_;
}
inline void BuiltinAssetDeposit::set_amount(::google::protobuf::uint64 value) {

  amount_ = value;
  // @@protoc_insertion_point(field_set:vega.BuiltinAssetDeposit.amount)
}

// -------------------------------------------------------------------

// BuiltinAssetWithdrawal

// string vegaAssetID = 1;
inline void BuiltinAssetWithdrawal::clear_vegaassetid() {
  vegaassetid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BuiltinAssetWithdrawal::vegaassetid() const {
  // @@protoc_insertion_point(field_get:vega.BuiltinAssetWithdrawal.vegaAssetID)
  return vegaassetid_.GetNoArena();
}
inline void BuiltinAssetWithdrawal::set_vegaassetid(const ::std::string& value) {

  vegaassetid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vega.BuiltinAssetWithdrawal.vegaAssetID)
}
#if LANG_CXX11
inline void BuiltinAssetWithdrawal::set_vegaassetid(::std::string&& value) {

  vegaassetid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vega.BuiltinAssetWithdrawal.vegaAssetID)
}
#endif
inline void BuiltinAssetWithdrawal::set_vegaassetid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  vegaassetid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vega.BuiltinAssetWithdrawal.vegaAssetID)
}
inline void BuiltinAssetWithdrawal::set_vegaassetid(const char* value, size_t size) {

  vegaassetid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vega.BuiltinAssetWithdrawal.vegaAssetID)
}
inline ::std::string* BuiltinAssetWithdrawal::mutable_vegaassetid() {

  // @@protoc_insertion_point(field_mutable:vega.BuiltinAssetWithdrawal.vegaAssetID)
  return vegaassetid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BuiltinAssetWithdrawal::release_vegaassetid() {
  // @@protoc_insertion_point(field_release:vega.BuiltinAssetWithdrawal.vegaAssetID)

  return vegaassetid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BuiltinAssetWithdrawal::set_allocated_vegaassetid(::std::string* vegaassetid) {
  if (vegaassetid != nullptr) {

  } else {

  }
  vegaassetid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), vegaassetid);
  // @@protoc_insertion_point(field_set_allocated:vega.BuiltinAssetWithdrawal.vegaAssetID)
}

// string partyID = 2;
inline void BuiltinAssetWithdrawal::clear_partyid() {
  partyid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BuiltinAssetWithdrawal::partyid() const {
  // @@protoc_insertion_point(field_get:vega.BuiltinAssetWithdrawal.partyID)
  return partyid_.GetNoArena();
}
inline void BuiltinAssetWithdrawal::set_partyid(const ::std::string& value) {

  partyid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vega.BuiltinAssetWithdrawal.partyID)
}
#if LANG_CXX11
inline void BuiltinAssetWithdrawal::set_partyid(::std::string&& value) {

  partyid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vega.BuiltinAssetWithdrawal.partyID)
}
#endif
inline void BuiltinAssetWithdrawal::set_partyid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  partyid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vega.BuiltinAssetWithdrawal.partyID)
}
inline void BuiltinAssetWithdrawal::set_partyid(const char* value, size_t size) {

  partyid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vega.BuiltinAssetWithdrawal.partyID)
}
inline ::std::string* BuiltinAssetWithdrawal::mutable_partyid() {

  // @@protoc_insertion_point(field_mutable:vega.BuiltinAssetWithdrawal.partyID)
  return partyid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BuiltinAssetWithdrawal::release_partyid() {
  // @@protoc_insertion_point(field_release:vega.BuiltinAssetWithdrawal.partyID)

  return partyid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BuiltinAssetWithdrawal::set_allocated_partyid(::std::string* partyid) {
  if (partyid != nullptr) {

  } else {

  }
  partyid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), partyid);
  // @@protoc_insertion_point(field_set_allocated:vega.BuiltinAssetWithdrawal.partyID)
}

// uint64 amount = 3;
inline void BuiltinAssetWithdrawal::clear_amount() {
  amount_ = PROTOBUF_ULONGLONG(0);
}
inline ::google::protobuf::uint64 BuiltinAssetWithdrawal::amount() const {
  // @@protoc_insertion_point(field_get:vega.BuiltinAssetWithdrawal.amount)
  return amount_;
}
inline void BuiltinAssetWithdrawal::set_amount(::google::protobuf::uint64 value) {

  amount_ = value;
  // @@protoc_insertion_point(field_set:vega.BuiltinAssetWithdrawal.amount)
}

// -------------------------------------------------------------------

// BuiltinAssetEvent

// .vega.BuiltinAssetDeposit deposit = 1001;
inline bool BuiltinAssetEvent::has_deposit() const {
  return action_case() == kDeposit;
}
inline void BuiltinAssetEvent::set_has_deposit() {
  _oneof_case_[0] = kDeposit;
}
inline void BuiltinAssetEvent::clear_deposit() {
  if (has_deposit()) {
    delete action_.deposit_;
    clear_has_action();
  }
}
inline ::vega::BuiltinAssetDeposit* BuiltinAssetEvent::release_deposit() {
  // @@protoc_insertion_point(field_release:vega.BuiltinAssetEvent.deposit)
  if (has_deposit()) {
    clear_has_action();
      ::vega::BuiltinAssetDeposit* temp = action_.deposit_;
    action_.deposit_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vega::BuiltinAssetDeposit& BuiltinAssetEvent::deposit() const {
  // @@protoc_insertion_point(field_get:vega.BuiltinAssetEvent.deposit)
  return has_deposit()
      ? *action_.deposit_
      : *reinterpret_cast< ::vega::BuiltinAssetDeposit*>(&::vega::_BuiltinAssetDeposit_default_instance_);
}
inline ::vega::BuiltinAssetDeposit* BuiltinAssetEvent::mutable_deposit() {
  if (!has_deposit()) {
    clear_action();
    set_has_deposit();
    action_.deposit_ = CreateMaybeMessage< ::vega::BuiltinAssetDeposit >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:vega.BuiltinAssetEvent.deposit)
  return action_.deposit_;
}

// .vega.BuiltinAssetWithdrawal withdrawal = 1002;
inline bool BuiltinAssetEvent::has_withdrawal() const {
  return action_case() == kWithdrawal;
}
inline void BuiltinAssetEvent::set_has_withdrawal() {
  _oneof_case_[0] = kWithdrawal;
}
inline void BuiltinAssetEvent::clear_withdrawal() {
  if (has_withdrawal()) {
    delete action_.withdrawal_;
    clear_has_action();
  }
}
inline ::vega::BuiltinAssetWithdrawal* BuiltinAssetEvent::release_withdrawal() {
  // @@protoc_insertion_point(field_release:vega.BuiltinAssetEvent.withdrawal)
  if (has_withdrawal()) {
    clear_has_action();
      ::vega::BuiltinAssetWithdrawal* temp = action_.withdrawal_;
    action_.withdrawal_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vega::BuiltinAssetWithdrawal& BuiltinAssetEvent::withdrawal() const {
  // @@protoc_insertion_point(field_get:vega.BuiltinAssetEvent.withdrawal)
  return has_withdrawal()
      ? *action_.withdrawal_
      : *reinterpret_cast< ::vega::BuiltinAssetWithdrawal*>(&::vega::_BuiltinAssetWithdrawal_default_instance_);
}
inline ::vega::BuiltinAssetWithdrawal* BuiltinAssetEvent::mutable_withdrawal() {
  if (!has_withdrawal()) {
    clear_action();
    set_has_withdrawal();
    action_.withdrawal_ = CreateMaybeMessage< ::vega::BuiltinAssetWithdrawal >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:vega.BuiltinAssetEvent.withdrawal)
  return action_.withdrawal_;
}

inline bool BuiltinAssetEvent::has_action() const {
  return action_case() != ACTION_NOT_SET;
}
inline void BuiltinAssetEvent::clear_has_action() {
  _oneof_case_[0] = ACTION_NOT_SET;
}
inline BuiltinAssetEvent::ActionCase BuiltinAssetEvent::action_case() const {
  return BuiltinAssetEvent::ActionCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ERC20AssetList

// string vegaAssetID = 1;
inline void ERC20AssetList::clear_vegaassetid() {
  vegaassetid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ERC20AssetList::vegaassetid() const {
  // @@protoc_insertion_point(field_get:vega.ERC20AssetList.vegaAssetID)
  return vegaassetid_.GetNoArena();
}
inline void ERC20AssetList::set_vegaassetid(const ::std::string& value) {

  vegaassetid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vega.ERC20AssetList.vegaAssetID)
}
#if LANG_CXX11
inline void ERC20AssetList::set_vegaassetid(::std::string&& value) {

  vegaassetid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vega.ERC20AssetList.vegaAssetID)
}
#endif
inline void ERC20AssetList::set_vegaassetid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  vegaassetid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vega.ERC20AssetList.vegaAssetID)
}
inline void ERC20AssetList::set_vegaassetid(const char* value, size_t size) {

  vegaassetid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vega.ERC20AssetList.vegaAssetID)
}
inline ::std::string* ERC20AssetList::mutable_vegaassetid() {

  // @@protoc_insertion_point(field_mutable:vega.ERC20AssetList.vegaAssetID)
  return vegaassetid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ERC20AssetList::release_vegaassetid() {
  // @@protoc_insertion_point(field_release:vega.ERC20AssetList.vegaAssetID)

  return vegaassetid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ERC20AssetList::set_allocated_vegaassetid(::std::string* vegaassetid) {
  if (vegaassetid != nullptr) {

  } else {

  }
  vegaassetid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), vegaassetid);
  // @@protoc_insertion_point(field_set_allocated:vega.ERC20AssetList.vegaAssetID)
}

// -------------------------------------------------------------------

// ERC20AssetDelist

// string vegaAssetID = 1;
inline void ERC20AssetDelist::clear_vegaassetid() {
  vegaassetid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ERC20AssetDelist::vegaassetid() const {
  // @@protoc_insertion_point(field_get:vega.ERC20AssetDelist.vegaAssetID)
  return vegaassetid_.GetNoArena();
}
inline void ERC20AssetDelist::set_vegaassetid(const ::std::string& value) {

  vegaassetid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vega.ERC20AssetDelist.vegaAssetID)
}
#if LANG_CXX11
inline void ERC20AssetDelist::set_vegaassetid(::std::string&& value) {

  vegaassetid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vega.ERC20AssetDelist.vegaAssetID)
}
#endif
inline void ERC20AssetDelist::set_vegaassetid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  vegaassetid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vega.ERC20AssetDelist.vegaAssetID)
}
inline void ERC20AssetDelist::set_vegaassetid(const char* value, size_t size) {

  vegaassetid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vega.ERC20AssetDelist.vegaAssetID)
}
inline ::std::string* ERC20AssetDelist::mutable_vegaassetid() {

  // @@protoc_insertion_point(field_mutable:vega.ERC20AssetDelist.vegaAssetID)
  return vegaassetid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ERC20AssetDelist::release_vegaassetid() {
  // @@protoc_insertion_point(field_release:vega.ERC20AssetDelist.vegaAssetID)

  return vegaassetid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ERC20AssetDelist::set_allocated_vegaassetid(::std::string* vegaassetid) {
  if (vegaassetid != nullptr) {

  } else {

  }
  vegaassetid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), vegaassetid);
  // @@protoc_insertion_point(field_set_allocated:vega.ERC20AssetDelist.vegaAssetID)
}

// -------------------------------------------------------------------

// ERC20Deposit

// string vegaAssetID = 1;
inline void ERC20Deposit::clear_vegaassetid() {
  vegaassetid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ERC20Deposit::vegaassetid() const {
  // @@protoc_insertion_point(field_get:vega.ERC20Deposit.vegaAssetID)
  return vegaassetid_.GetNoArena();
}
inline void ERC20Deposit::set_vegaassetid(const ::std::string& value) {

  vegaassetid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vega.ERC20Deposit.vegaAssetID)
}
#if LANG_CXX11
inline void ERC20Deposit::set_vegaassetid(::std::string&& value) {

  vegaassetid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vega.ERC20Deposit.vegaAssetID)
}
#endif
inline void ERC20Deposit::set_vegaassetid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  vegaassetid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vega.ERC20Deposit.vegaAssetID)
}
inline void ERC20Deposit::set_vegaassetid(const char* value, size_t size) {

  vegaassetid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vega.ERC20Deposit.vegaAssetID)
}
inline ::std::string* ERC20Deposit::mutable_vegaassetid() {

  // @@protoc_insertion_point(field_mutable:vega.ERC20Deposit.vegaAssetID)
  return vegaassetid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ERC20Deposit::release_vegaassetid() {
  // @@protoc_insertion_point(field_release:vega.ERC20Deposit.vegaAssetID)

  return vegaassetid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ERC20Deposit::set_allocated_vegaassetid(::std::string* vegaassetid) {
  if (vegaassetid != nullptr) {

  } else {

  }
  vegaassetid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), vegaassetid);
  // @@protoc_insertion_point(field_set_allocated:vega.ERC20Deposit.vegaAssetID)
}

// string sourceEthereumAddress = 2;
inline void ERC20Deposit::clear_sourceethereumaddress() {
  sourceethereumaddress_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ERC20Deposit::sourceethereumaddress() const {
  // @@protoc_insertion_point(field_get:vega.ERC20Deposit.sourceEthereumAddress)
  return sourceethereumaddress_.GetNoArena();
}
inline void ERC20Deposit::set_sourceethereumaddress(const ::std::string& value) {

  sourceethereumaddress_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vega.ERC20Deposit.sourceEthereumAddress)
}
#if LANG_CXX11
inline void ERC20Deposit::set_sourceethereumaddress(::std::string&& value) {

  sourceethereumaddress_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vega.ERC20Deposit.sourceEthereumAddress)
}
#endif
inline void ERC20Deposit::set_sourceethereumaddress(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  sourceethereumaddress_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vega.ERC20Deposit.sourceEthereumAddress)
}
inline void ERC20Deposit::set_sourceethereumaddress(const char* value, size_t size) {

  sourceethereumaddress_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vega.ERC20Deposit.sourceEthereumAddress)
}
inline ::std::string* ERC20Deposit::mutable_sourceethereumaddress() {

  // @@protoc_insertion_point(field_mutable:vega.ERC20Deposit.sourceEthereumAddress)
  return sourceethereumaddress_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ERC20Deposit::release_sourceethereumaddress() {
  // @@protoc_insertion_point(field_release:vega.ERC20Deposit.sourceEthereumAddress)

  return sourceethereumaddress_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ERC20Deposit::set_allocated_sourceethereumaddress(::std::string* sourceethereumaddress) {
  if (sourceethereumaddress != nullptr) {

  } else {

  }
  sourceethereumaddress_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sourceethereumaddress);
  // @@protoc_insertion_point(field_set_allocated:vega.ERC20Deposit.sourceEthereumAddress)
}

// string targetPartyID = 3;
inline void ERC20Deposit::clear_targetpartyid() {
  targetpartyid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ERC20Deposit::targetpartyid() const {
  // @@protoc_insertion_point(field_get:vega.ERC20Deposit.targetPartyID)
  return targetpartyid_.GetNoArena();
}
inline void ERC20Deposit::set_targetpartyid(const ::std::string& value) {

  targetpartyid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vega.ERC20Deposit.targetPartyID)
}
#if LANG_CXX11
inline void ERC20Deposit::set_targetpartyid(::std::string&& value) {

  targetpartyid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vega.ERC20Deposit.targetPartyID)
}
#endif
inline void ERC20Deposit::set_targetpartyid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  targetpartyid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vega.ERC20Deposit.targetPartyID)
}
inline void ERC20Deposit::set_targetpartyid(const char* value, size_t size) {

  targetpartyid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vega.ERC20Deposit.targetPartyID)
}
inline ::std::string* ERC20Deposit::mutable_targetpartyid() {

  // @@protoc_insertion_point(field_mutable:vega.ERC20Deposit.targetPartyID)
  return targetpartyid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ERC20Deposit::release_targetpartyid() {
  // @@protoc_insertion_point(field_release:vega.ERC20Deposit.targetPartyID)

  return targetpartyid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ERC20Deposit::set_allocated_targetpartyid(::std::string* targetpartyid) {
  if (targetpartyid != nullptr) {

  } else {

  }
  targetpartyid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), targetpartyid);
  // @@protoc_insertion_point(field_set_allocated:vega.ERC20Deposit.targetPartyID)
}

// -------------------------------------------------------------------

// ERC20Withdrawal

// string vegaAssetID = 1;
inline void ERC20Withdrawal::clear_vegaassetid() {
  vegaassetid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ERC20Withdrawal::vegaassetid() const {
  // @@protoc_insertion_point(field_get:vega.ERC20Withdrawal.vegaAssetID)
  return vegaassetid_.GetNoArena();
}
inline void ERC20Withdrawal::set_vegaassetid(const ::std::string& value) {

  vegaassetid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vega.ERC20Withdrawal.vegaAssetID)
}
#if LANG_CXX11
inline void ERC20Withdrawal::set_vegaassetid(::std::string&& value) {

  vegaassetid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vega.ERC20Withdrawal.vegaAssetID)
}
#endif
inline void ERC20Withdrawal::set_vegaassetid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  vegaassetid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vega.ERC20Withdrawal.vegaAssetID)
}
inline void ERC20Withdrawal::set_vegaassetid(const char* value, size_t size) {

  vegaassetid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vega.ERC20Withdrawal.vegaAssetID)
}
inline ::std::string* ERC20Withdrawal::mutable_vegaassetid() {

  // @@protoc_insertion_point(field_mutable:vega.ERC20Withdrawal.vegaAssetID)
  return vegaassetid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ERC20Withdrawal::release_vegaassetid() {
  // @@protoc_insertion_point(field_release:vega.ERC20Withdrawal.vegaAssetID)

  return vegaassetid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ERC20Withdrawal::set_allocated_vegaassetid(::std::string* vegaassetid) {
  if (vegaassetid != nullptr) {

  } else {

  }
  vegaassetid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), vegaassetid);
  // @@protoc_insertion_point(field_set_allocated:vega.ERC20Withdrawal.vegaAssetID)
}

// string targetEthereumAddress = 2;
inline void ERC20Withdrawal::clear_targetethereumaddress() {
  targetethereumaddress_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ERC20Withdrawal::targetethereumaddress() const {
  // @@protoc_insertion_point(field_get:vega.ERC20Withdrawal.targetEthereumAddress)
  return targetethereumaddress_.GetNoArena();
}
inline void ERC20Withdrawal::set_targetethereumaddress(const ::std::string& value) {

  targetethereumaddress_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vega.ERC20Withdrawal.targetEthereumAddress)
}
#if LANG_CXX11
inline void ERC20Withdrawal::set_targetethereumaddress(::std::string&& value) {

  targetethereumaddress_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vega.ERC20Withdrawal.targetEthereumAddress)
}
#endif
inline void ERC20Withdrawal::set_targetethereumaddress(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  targetethereumaddress_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vega.ERC20Withdrawal.targetEthereumAddress)
}
inline void ERC20Withdrawal::set_targetethereumaddress(const char* value, size_t size) {

  targetethereumaddress_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vega.ERC20Withdrawal.targetEthereumAddress)
}
inline ::std::string* ERC20Withdrawal::mutable_targetethereumaddress() {

  // @@protoc_insertion_point(field_mutable:vega.ERC20Withdrawal.targetEthereumAddress)
  return targetethereumaddress_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ERC20Withdrawal::release_targetethereumaddress() {
  // @@protoc_insertion_point(field_release:vega.ERC20Withdrawal.targetEthereumAddress)

  return targetethereumaddress_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ERC20Withdrawal::set_allocated_targetethereumaddress(::std::string* targetethereumaddress) {
  if (targetethereumaddress != nullptr) {

  } else {

  }
  targetethereumaddress_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), targetethereumaddress);
  // @@protoc_insertion_point(field_set_allocated:vega.ERC20Withdrawal.targetEthereumAddress)
}

// string referenceNonce = 3;
inline void ERC20Withdrawal::clear_referencenonce() {
  referencenonce_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ERC20Withdrawal::referencenonce() const {
  // @@protoc_insertion_point(field_get:vega.ERC20Withdrawal.referenceNonce)
  return referencenonce_.GetNoArena();
}
inline void ERC20Withdrawal::set_referencenonce(const ::std::string& value) {

  referencenonce_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vega.ERC20Withdrawal.referenceNonce)
}
#if LANG_CXX11
inline void ERC20Withdrawal::set_referencenonce(::std::string&& value) {

  referencenonce_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vega.ERC20Withdrawal.referenceNonce)
}
#endif
inline void ERC20Withdrawal::set_referencenonce(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  referencenonce_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vega.ERC20Withdrawal.referenceNonce)
}
inline void ERC20Withdrawal::set_referencenonce(const char* value, size_t size) {

  referencenonce_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vega.ERC20Withdrawal.referenceNonce)
}
inline ::std::string* ERC20Withdrawal::mutable_referencenonce() {

  // @@protoc_insertion_point(field_mutable:vega.ERC20Withdrawal.referenceNonce)
  return referencenonce_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ERC20Withdrawal::release_referencenonce() {
  // @@protoc_insertion_point(field_release:vega.ERC20Withdrawal.referenceNonce)

  return referencenonce_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ERC20Withdrawal::set_allocated_referencenonce(::std::string* referencenonce) {
  if (referencenonce != nullptr) {

  } else {

  }
  referencenonce_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), referencenonce);
  // @@protoc_insertion_point(field_set_allocated:vega.ERC20Withdrawal.referenceNonce)
}

// -------------------------------------------------------------------

// ERC20Event

// uint64 index = 1;
inline void ERC20Event::clear_index() {
  index_ = PROTOBUF_ULONGLONG(0);
}
inline ::google::protobuf::uint64 ERC20Event::index() const {
  // @@protoc_insertion_point(field_get:vega.ERC20Event.index)
  return index_;
}
inline void ERC20Event::set_index(::google::protobuf::uint64 value) {

  index_ = value;
  // @@protoc_insertion_point(field_set:vega.ERC20Event.index)
}

// uint64 block = 2;
inline void ERC20Event::clear_block() {
  block_ = PROTOBUF_ULONGLONG(0);
}
inline ::google::protobuf::uint64 ERC20Event::block() const {
  // @@protoc_insertion_point(field_get:vega.ERC20Event.block)
  return block_;
}
inline void ERC20Event::set_block(::google::protobuf::uint64 value) {

  block_ = value;
  // @@protoc_insertion_point(field_set:vega.ERC20Event.block)
}

// .vega.ERC20AssetList assetList = 1001;
inline bool ERC20Event::has_assetlist() const {
  return action_case() == kAssetList;
}
inline void ERC20Event::set_has_assetlist() {
  _oneof_case_[0] = kAssetList;
}
inline void ERC20Event::clear_assetlist() {
  if (has_assetlist()) {
    delete action_.assetlist_;
    clear_has_action();
  }
}
inline ::vega::ERC20AssetList* ERC20Event::release_assetlist() {
  // @@protoc_insertion_point(field_release:vega.ERC20Event.assetList)
  if (has_assetlist()) {
    clear_has_action();
      ::vega::ERC20AssetList* temp = action_.assetlist_;
    action_.assetlist_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vega::ERC20AssetList& ERC20Event::assetlist() const {
  // @@protoc_insertion_point(field_get:vega.ERC20Event.assetList)
  return has_assetlist()
      ? *action_.assetlist_
      : *reinterpret_cast< ::vega::ERC20AssetList*>(&::vega::_ERC20AssetList_default_instance_);
}
inline ::vega::ERC20AssetList* ERC20Event::mutable_assetlist() {
  if (!has_assetlist()) {
    clear_action();
    set_has_assetlist();
    action_.assetlist_ = CreateMaybeMessage< ::vega::ERC20AssetList >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:vega.ERC20Event.assetList)
  return action_.assetlist_;
}

// .vega.ERC20AssetDelist assetDelist = 1002;
inline bool ERC20Event::has_assetdelist() const {
  return action_case() == kAssetDelist;
}
inline void ERC20Event::set_has_assetdelist() {
  _oneof_case_[0] = kAssetDelist;
}
inline void ERC20Event::clear_assetdelist() {
  if (has_assetdelist()) {
    delete action_.assetdelist_;
    clear_has_action();
  }
}
inline ::vega::ERC20AssetDelist* ERC20Event::release_assetdelist() {
  // @@protoc_insertion_point(field_release:vega.ERC20Event.assetDelist)
  if (has_assetdelist()) {
    clear_has_action();
      ::vega::ERC20AssetDelist* temp = action_.assetdelist_;
    action_.assetdelist_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vega::ERC20AssetDelist& ERC20Event::assetdelist() const {
  // @@protoc_insertion_point(field_get:vega.ERC20Event.assetDelist)
  return has_assetdelist()
      ? *action_.assetdelist_
      : *reinterpret_cast< ::vega::ERC20AssetDelist*>(&::vega::_ERC20AssetDelist_default_instance_);
}
inline ::vega::ERC20AssetDelist* ERC20Event::mutable_assetdelist() {
  if (!has_assetdelist()) {
    clear_action();
    set_has_assetdelist();
    action_.assetdelist_ = CreateMaybeMessage< ::vega::ERC20AssetDelist >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:vega.ERC20Event.assetDelist)
  return action_.assetdelist_;
}

// .vega.ERC20Deposit deposit = 1003;
inline bool ERC20Event::has_deposit() const {
  return action_case() == kDeposit;
}
inline void ERC20Event::set_has_deposit() {
  _oneof_case_[0] = kDeposit;
}
inline void ERC20Event::clear_deposit() {
  if (has_deposit()) {
    delete action_.deposit_;
    clear_has_action();
  }
}
inline ::vega::ERC20Deposit* ERC20Event::release_deposit() {
  // @@protoc_insertion_point(field_release:vega.ERC20Event.deposit)
  if (has_deposit()) {
    clear_has_action();
      ::vega::ERC20Deposit* temp = action_.deposit_;
    action_.deposit_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vega::ERC20Deposit& ERC20Event::deposit() const {
  // @@protoc_insertion_point(field_get:vega.ERC20Event.deposit)
  return has_deposit()
      ? *action_.deposit_
      : *reinterpret_cast< ::vega::ERC20Deposit*>(&::vega::_ERC20Deposit_default_instance_);
}
inline ::vega::ERC20Deposit* ERC20Event::mutable_deposit() {
  if (!has_deposit()) {
    clear_action();
    set_has_deposit();
    action_.deposit_ = CreateMaybeMessage< ::vega::ERC20Deposit >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:vega.ERC20Event.deposit)
  return action_.deposit_;
}

// .vega.ERC20Withdrawal withdrawal = 1004;
inline bool ERC20Event::has_withdrawal() const {
  return action_case() == kWithdrawal;
}
inline void ERC20Event::set_has_withdrawal() {
  _oneof_case_[0] = kWithdrawal;
}
inline void ERC20Event::clear_withdrawal() {
  if (has_withdrawal()) {
    delete action_.withdrawal_;
    clear_has_action();
  }
}
inline ::vega::ERC20Withdrawal* ERC20Event::release_withdrawal() {
  // @@protoc_insertion_point(field_release:vega.ERC20Event.withdrawal)
  if (has_withdrawal()) {
    clear_has_action();
      ::vega::ERC20Withdrawal* temp = action_.withdrawal_;
    action_.withdrawal_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vega::ERC20Withdrawal& ERC20Event::withdrawal() const {
  // @@protoc_insertion_point(field_get:vega.ERC20Event.withdrawal)
  return has_withdrawal()
      ? *action_.withdrawal_
      : *reinterpret_cast< ::vega::ERC20Withdrawal*>(&::vega::_ERC20Withdrawal_default_instance_);
}
inline ::vega::ERC20Withdrawal* ERC20Event::mutable_withdrawal() {
  if (!has_withdrawal()) {
    clear_action();
    set_has_withdrawal();
    action_.withdrawal_ = CreateMaybeMessage< ::vega::ERC20Withdrawal >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:vega.ERC20Event.withdrawal)
  return action_.withdrawal_;
}

inline bool ERC20Event::has_action() const {
  return action_case() != ACTION_NOT_SET;
}
inline void ERC20Event::clear_has_action() {
  _oneof_case_[0] = ACTION_NOT_SET;
}
inline ERC20Event::ActionCase ERC20Event::action_case() const {
  return ERC20Event::ActionCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// BTCDeposit

// string vegaAssetID = 1;
inline void BTCDeposit::clear_vegaassetid() {
  vegaassetid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BTCDeposit::vegaassetid() const {
  // @@protoc_insertion_point(field_get:vega.BTCDeposit.vegaAssetID)
  return vegaassetid_.GetNoArena();
}
inline void BTCDeposit::set_vegaassetid(const ::std::string& value) {

  vegaassetid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vega.BTCDeposit.vegaAssetID)
}
#if LANG_CXX11
inline void BTCDeposit::set_vegaassetid(::std::string&& value) {

  vegaassetid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vega.BTCDeposit.vegaAssetID)
}
#endif
inline void BTCDeposit::set_vegaassetid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  vegaassetid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vega.BTCDeposit.vegaAssetID)
}
inline void BTCDeposit::set_vegaassetid(const char* value, size_t size) {

  vegaassetid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vega.BTCDeposit.vegaAssetID)
}
inline ::std::string* BTCDeposit::mutable_vegaassetid() {

  // @@protoc_insertion_point(field_mutable:vega.BTCDeposit.vegaAssetID)
  return vegaassetid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BTCDeposit::release_vegaassetid() {
  // @@protoc_insertion_point(field_release:vega.BTCDeposit.vegaAssetID)

  return vegaassetid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BTCDeposit::set_allocated_vegaassetid(::std::string* vegaassetid) {
  if (vegaassetid != nullptr) {

  } else {

  }
  vegaassetid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), vegaassetid);
  // @@protoc_insertion_point(field_set_allocated:vega.BTCDeposit.vegaAssetID)
}

// string sourceBTCAddress = 2;
inline void BTCDeposit::clear_sourcebtcaddress() {
  sourcebtcaddress_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BTCDeposit::sourcebtcaddress() const {
  // @@protoc_insertion_point(field_get:vega.BTCDeposit.sourceBTCAddress)
  return sourcebtcaddress_.GetNoArena();
}
inline void BTCDeposit::set_sourcebtcaddress(const ::std::string& value) {

  sourcebtcaddress_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vega.BTCDeposit.sourceBTCAddress)
}
#if LANG_CXX11
inline void BTCDeposit::set_sourcebtcaddress(::std::string&& value) {

  sourcebtcaddress_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vega.BTCDeposit.sourceBTCAddress)
}
#endif
inline void BTCDeposit::set_sourcebtcaddress(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  sourcebtcaddress_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vega.BTCDeposit.sourceBTCAddress)
}
inline void BTCDeposit::set_sourcebtcaddress(const char* value, size_t size) {

  sourcebtcaddress_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vega.BTCDeposit.sourceBTCAddress)
}
inline ::std::string* BTCDeposit::mutable_sourcebtcaddress() {

  // @@protoc_insertion_point(field_mutable:vega.BTCDeposit.sourceBTCAddress)
  return sourcebtcaddress_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BTCDeposit::release_sourcebtcaddress() {
  // @@protoc_insertion_point(field_release:vega.BTCDeposit.sourceBTCAddress)

  return sourcebtcaddress_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BTCDeposit::set_allocated_sourcebtcaddress(::std::string* sourcebtcaddress) {
  if (sourcebtcaddress != nullptr) {

  } else {

  }
  sourcebtcaddress_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sourcebtcaddress);
  // @@protoc_insertion_point(field_set_allocated:vega.BTCDeposit.sourceBTCAddress)
}

// string targetPartyId = 3;
inline void BTCDeposit::clear_targetpartyid() {
  targetpartyid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BTCDeposit::targetpartyid() const {
  // @@protoc_insertion_point(field_get:vega.BTCDeposit.targetPartyId)
  return targetpartyid_.GetNoArena();
}
inline void BTCDeposit::set_targetpartyid(const ::std::string& value) {

  targetpartyid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vega.BTCDeposit.targetPartyId)
}
#if LANG_CXX11
inline void BTCDeposit::set_targetpartyid(::std::string&& value) {

  targetpartyid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vega.BTCDeposit.targetPartyId)
}
#endif
inline void BTCDeposit::set_targetpartyid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  targetpartyid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vega.BTCDeposit.targetPartyId)
}
inline void BTCDeposit::set_targetpartyid(const char* value, size_t size) {

  targetpartyid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vega.BTCDeposit.targetPartyId)
}
inline ::std::string* BTCDeposit::mutable_targetpartyid() {

  // @@protoc_insertion_point(field_mutable:vega.BTCDeposit.targetPartyId)
  return targetpartyid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BTCDeposit::release_targetpartyid() {
  // @@protoc_insertion_point(field_release:vega.BTCDeposit.targetPartyId)

  return targetpartyid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BTCDeposit::set_allocated_targetpartyid(::std::string* targetpartyid) {
  if (targetpartyid != nullptr) {

  } else {

  }
  targetpartyid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), targetpartyid);
  // @@protoc_insertion_point(field_set_allocated:vega.BTCDeposit.targetPartyId)
}

// -------------------------------------------------------------------

// BTCWithdrawal

// string vegaAssetID = 1;
inline void BTCWithdrawal::clear_vegaassetid() {
  vegaassetid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BTCWithdrawal::vegaassetid() const {
  // @@protoc_insertion_point(field_get:vega.BTCWithdrawal.vegaAssetID)
  return vegaassetid_.GetNoArena();
}
inline void BTCWithdrawal::set_vegaassetid(const ::std::string& value) {

  vegaassetid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vega.BTCWithdrawal.vegaAssetID)
}
#if LANG_CXX11
inline void BTCWithdrawal::set_vegaassetid(::std::string&& value) {

  vegaassetid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vega.BTCWithdrawal.vegaAssetID)
}
#endif
inline void BTCWithdrawal::set_vegaassetid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  vegaassetid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vega.BTCWithdrawal.vegaAssetID)
}
inline void BTCWithdrawal::set_vegaassetid(const char* value, size_t size) {

  vegaassetid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vega.BTCWithdrawal.vegaAssetID)
}
inline ::std::string* BTCWithdrawal::mutable_vegaassetid() {

  // @@protoc_insertion_point(field_mutable:vega.BTCWithdrawal.vegaAssetID)
  return vegaassetid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BTCWithdrawal::release_vegaassetid() {
  // @@protoc_insertion_point(field_release:vega.BTCWithdrawal.vegaAssetID)

  return vegaassetid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BTCWithdrawal::set_allocated_vegaassetid(::std::string* vegaassetid) {
  if (vegaassetid != nullptr) {

  } else {

  }
  vegaassetid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), vegaassetid);
  // @@protoc_insertion_point(field_set_allocated:vega.BTCWithdrawal.vegaAssetID)
}

// string sourcePartyId = 2;
inline void BTCWithdrawal::clear_sourcepartyid() {
  sourcepartyid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BTCWithdrawal::sourcepartyid() const {
  // @@protoc_insertion_point(field_get:vega.BTCWithdrawal.sourcePartyId)
  return sourcepartyid_.GetNoArena();
}
inline void BTCWithdrawal::set_sourcepartyid(const ::std::string& value) {

  sourcepartyid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vega.BTCWithdrawal.sourcePartyId)
}
#if LANG_CXX11
inline void BTCWithdrawal::set_sourcepartyid(::std::string&& value) {

  sourcepartyid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vega.BTCWithdrawal.sourcePartyId)
}
#endif
inline void BTCWithdrawal::set_sourcepartyid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  sourcepartyid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vega.BTCWithdrawal.sourcePartyId)
}
inline void BTCWithdrawal::set_sourcepartyid(const char* value, size_t size) {

  sourcepartyid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vega.BTCWithdrawal.sourcePartyId)
}
inline ::std::string* BTCWithdrawal::mutable_sourcepartyid() {

  // @@protoc_insertion_point(field_mutable:vega.BTCWithdrawal.sourcePartyId)
  return sourcepartyid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BTCWithdrawal::release_sourcepartyid() {
  // @@protoc_insertion_point(field_release:vega.BTCWithdrawal.sourcePartyId)

  return sourcepartyid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BTCWithdrawal::set_allocated_sourcepartyid(::std::string* sourcepartyid) {
  if (sourcepartyid != nullptr) {

  } else {

  }
  sourcepartyid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sourcepartyid);
  // @@protoc_insertion_point(field_set_allocated:vega.BTCWithdrawal.sourcePartyId)
}

// string targetBTCAddress = 3;
inline void BTCWithdrawal::clear_targetbtcaddress() {
  targetbtcaddress_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BTCWithdrawal::targetbtcaddress() const {
  // @@protoc_insertion_point(field_get:vega.BTCWithdrawal.targetBTCAddress)
  return targetbtcaddress_.GetNoArena();
}
inline void BTCWithdrawal::set_targetbtcaddress(const ::std::string& value) {

  targetbtcaddress_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vega.BTCWithdrawal.targetBTCAddress)
}
#if LANG_CXX11
inline void BTCWithdrawal::set_targetbtcaddress(::std::string&& value) {

  targetbtcaddress_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vega.BTCWithdrawal.targetBTCAddress)
}
#endif
inline void BTCWithdrawal::set_targetbtcaddress(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  targetbtcaddress_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vega.BTCWithdrawal.targetBTCAddress)
}
inline void BTCWithdrawal::set_targetbtcaddress(const char* value, size_t size) {

  targetbtcaddress_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vega.BTCWithdrawal.targetBTCAddress)
}
inline ::std::string* BTCWithdrawal::mutable_targetbtcaddress() {

  // @@protoc_insertion_point(field_mutable:vega.BTCWithdrawal.targetBTCAddress)
  return targetbtcaddress_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BTCWithdrawal::release_targetbtcaddress() {
  // @@protoc_insertion_point(field_release:vega.BTCWithdrawal.targetBTCAddress)

  return targetbtcaddress_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BTCWithdrawal::set_allocated_targetbtcaddress(::std::string* targetbtcaddress) {
  if (targetbtcaddress != nullptr) {

  } else {

  }
  targetbtcaddress_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), targetbtcaddress);
  // @@protoc_insertion_point(field_set_allocated:vega.BTCWithdrawal.targetBTCAddress)
}

// string referenceNonce = 4;
inline void BTCWithdrawal::clear_referencenonce() {
  referencenonce_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BTCWithdrawal::referencenonce() const {
  // @@protoc_insertion_point(field_get:vega.BTCWithdrawal.referenceNonce)
  return referencenonce_.GetNoArena();
}
inline void BTCWithdrawal::set_referencenonce(const ::std::string& value) {

  referencenonce_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vega.BTCWithdrawal.referenceNonce)
}
#if LANG_CXX11
inline void BTCWithdrawal::set_referencenonce(::std::string&& value) {

  referencenonce_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vega.BTCWithdrawal.referenceNonce)
}
#endif
inline void BTCWithdrawal::set_referencenonce(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  referencenonce_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vega.BTCWithdrawal.referenceNonce)
}
inline void BTCWithdrawal::set_referencenonce(const char* value, size_t size) {

  referencenonce_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vega.BTCWithdrawal.referenceNonce)
}
inline ::std::string* BTCWithdrawal::mutable_referencenonce() {

  // @@protoc_insertion_point(field_mutable:vega.BTCWithdrawal.referenceNonce)
  return referencenonce_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BTCWithdrawal::release_referencenonce() {
  // @@protoc_insertion_point(field_release:vega.BTCWithdrawal.referenceNonce)

  return referencenonce_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BTCWithdrawal::set_allocated_referencenonce(::std::string* referencenonce) {
  if (referencenonce != nullptr) {

  } else {

  }
  referencenonce_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), referencenonce);
  // @@protoc_insertion_point(field_set_allocated:vega.BTCWithdrawal.referenceNonce)
}

// -------------------------------------------------------------------

// BTCEvent

// uint64 index = 1;
inline void BTCEvent::clear_index() {
  index_ = PROTOBUF_ULONGLONG(0);
}
inline ::google::protobuf::uint64 BTCEvent::index() const {
  // @@protoc_insertion_point(field_get:vega.BTCEvent.index)
  return index_;
}
inline void BTCEvent::set_index(::google::protobuf::uint64 value) {

  index_ = value;
  // @@protoc_insertion_point(field_set:vega.BTCEvent.index)
}

// uint64 block = 2;
inline void BTCEvent::clear_block() {
  block_ = PROTOBUF_ULONGLONG(0);
}
inline ::google::protobuf::uint64 BTCEvent::block() const {
  // @@protoc_insertion_point(field_get:vega.BTCEvent.block)
  return block_;
}
inline void BTCEvent::set_block(::google::protobuf::uint64 value) {

  block_ = value;
  // @@protoc_insertion_point(field_set:vega.BTCEvent.block)
}

// .vega.BTCDeposit deposit = 1001;
inline bool BTCEvent::has_deposit() const {
  return action_case() == kDeposit;
}
inline void BTCEvent::set_has_deposit() {
  _oneof_case_[0] = kDeposit;
}
inline void BTCEvent::clear_deposit() {
  if (has_deposit()) {
    delete action_.deposit_;
    clear_has_action();
  }
}
inline ::vega::BTCDeposit* BTCEvent::release_deposit() {
  // @@protoc_insertion_point(field_release:vega.BTCEvent.deposit)
  if (has_deposit()) {
    clear_has_action();
      ::vega::BTCDeposit* temp = action_.deposit_;
    action_.deposit_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vega::BTCDeposit& BTCEvent::deposit() const {
  // @@protoc_insertion_point(field_get:vega.BTCEvent.deposit)
  return has_deposit()
      ? *action_.deposit_
      : *reinterpret_cast< ::vega::BTCDeposit*>(&::vega::_BTCDeposit_default_instance_);
}
inline ::vega::BTCDeposit* BTCEvent::mutable_deposit() {
  if (!has_deposit()) {
    clear_action();
    set_has_deposit();
    action_.deposit_ = CreateMaybeMessage< ::vega::BTCDeposit >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:vega.BTCEvent.deposit)
  return action_.deposit_;
}

// .vega.BTCWithdrawal withdrawal = 1002;
inline bool BTCEvent::has_withdrawal() const {
  return action_case() == kWithdrawal;
}
inline void BTCEvent::set_has_withdrawal() {
  _oneof_case_[0] = kWithdrawal;
}
inline void BTCEvent::clear_withdrawal() {
  if (has_withdrawal()) {
    delete action_.withdrawal_;
    clear_has_action();
  }
}
inline ::vega::BTCWithdrawal* BTCEvent::release_withdrawal() {
  // @@protoc_insertion_point(field_release:vega.BTCEvent.withdrawal)
  if (has_withdrawal()) {
    clear_has_action();
      ::vega::BTCWithdrawal* temp = action_.withdrawal_;
    action_.withdrawal_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vega::BTCWithdrawal& BTCEvent::withdrawal() const {
  // @@protoc_insertion_point(field_get:vega.BTCEvent.withdrawal)
  return has_withdrawal()
      ? *action_.withdrawal_
      : *reinterpret_cast< ::vega::BTCWithdrawal*>(&::vega::_BTCWithdrawal_default_instance_);
}
inline ::vega::BTCWithdrawal* BTCEvent::mutable_withdrawal() {
  if (!has_withdrawal()) {
    clear_action();
    set_has_withdrawal();
    action_.withdrawal_ = CreateMaybeMessage< ::vega::BTCWithdrawal >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:vega.BTCEvent.withdrawal)
  return action_.withdrawal_;
}

inline bool BTCEvent::has_action() const {
  return action_case() != ACTION_NOT_SET;
}
inline void BTCEvent::clear_has_action() {
  _oneof_case_[0] = ACTION_NOT_SET;
}
inline BTCEvent::ActionCase BTCEvent::action_case() const {
  return BTCEvent::ActionCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// EthereumAddress

// string address = 1;
inline void EthereumAddress::clear_address() {
  address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& EthereumAddress::address() const {
  // @@protoc_insertion_point(field_get:vega.EthereumAddress.address)
  return address_.GetNoArena();
}
inline void EthereumAddress::set_address(const ::std::string& value) {

  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vega.EthereumAddress.address)
}
#if LANG_CXX11
inline void EthereumAddress::set_address(::std::string&& value) {

  address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vega.EthereumAddress.address)
}
#endif
inline void EthereumAddress::set_address(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vega.EthereumAddress.address)
}
inline void EthereumAddress::set_address(const char* value, size_t size) {

  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vega.EthereumAddress.address)
}
inline ::std::string* EthereumAddress::mutable_address() {

  // @@protoc_insertion_point(field_mutable:vega.EthereumAddress.address)
  return address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EthereumAddress::release_address() {
  // @@protoc_insertion_point(field_release:vega.EthereumAddress.address)

  return address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EthereumAddress::set_allocated_address(::std::string* address) {
  if (address != nullptr) {

  } else {

  }
  address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), address);
  // @@protoc_insertion_point(field_set_allocated:vega.EthereumAddress.address)
}

// -------------------------------------------------------------------

// BitcoinAddress

// string address = 1;
inline void BitcoinAddress::clear_address() {
  address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BitcoinAddress::address() const {
  // @@protoc_insertion_point(field_get:vega.BitcoinAddress.address)
  return address_.GetNoArena();
}
inline void BitcoinAddress::set_address(const ::std::string& value) {

  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vega.BitcoinAddress.address)
}
#if LANG_CXX11
inline void BitcoinAddress::set_address(::std::string&& value) {

  address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vega.BitcoinAddress.address)
}
#endif
inline void BitcoinAddress::set_address(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vega.BitcoinAddress.address)
}
inline void BitcoinAddress::set_address(const char* value, size_t size) {

  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vega.BitcoinAddress.address)
}
inline ::std::string* BitcoinAddress::mutable_address() {

  // @@protoc_insertion_point(field_mutable:vega.BitcoinAddress.address)
  return address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BitcoinAddress::release_address() {
  // @@protoc_insertion_point(field_release:vega.BitcoinAddress.address)

  return address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BitcoinAddress::set_allocated_address(::std::string* address) {
  if (address != nullptr) {

  } else {

  }
  address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), address);
  // @@protoc_insertion_point(field_set_allocated:vega.BitcoinAddress.address)
}

// -------------------------------------------------------------------

// Identifier

// .vega.EthereumAddress ethereumAddress = 1;
inline bool Identifier::has_ethereumaddress() const {
  return identifier_case() == kEthereumAddress;
}
inline void Identifier::set_has_ethereumaddress() {
  _oneof_case_[0] = kEthereumAddress;
}
inline void Identifier::clear_ethereumaddress() {
  if (has_ethereumaddress()) {
    delete identifier_.ethereumaddress_;
    clear_has_identifier();
  }
}
inline ::vega::EthereumAddress* Identifier::release_ethereumaddress() {
  // @@protoc_insertion_point(field_release:vega.Identifier.ethereumAddress)
  if (has_ethereumaddress()) {
    clear_has_identifier();
      ::vega::EthereumAddress* temp = identifier_.ethereumaddress_;
    identifier_.ethereumaddress_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vega::EthereumAddress& Identifier::ethereumaddress() const {
  // @@protoc_insertion_point(field_get:vega.Identifier.ethereumAddress)
  return has_ethereumaddress()
      ? *identifier_.ethereumaddress_
      : *reinterpret_cast< ::vega::EthereumAddress*>(&::vega::_EthereumAddress_default_instance_);
}
inline ::vega::EthereumAddress* Identifier::mutable_ethereumaddress() {
  if (!has_ethereumaddress()) {
    clear_identifier();
    set_has_ethereumaddress();
    identifier_.ethereumaddress_ = CreateMaybeMessage< ::vega::EthereumAddress >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:vega.Identifier.ethereumAddress)
  return identifier_.ethereumaddress_;
}

// .vega.BitcoinAddress bitcoinAddress = 2;
inline bool Identifier::has_bitcoinaddress() const {
  return identifier_case() == kBitcoinAddress;
}
inline void Identifier::set_has_bitcoinaddress() {
  _oneof_case_[0] = kBitcoinAddress;
}
inline void Identifier::clear_bitcoinaddress() {
  if (has_bitcoinaddress()) {
    delete identifier_.bitcoinaddress_;
    clear_has_identifier();
  }
}
inline ::vega::BitcoinAddress* Identifier::release_bitcoinaddress() {
  // @@protoc_insertion_point(field_release:vega.Identifier.bitcoinAddress)
  if (has_bitcoinaddress()) {
    clear_has_identifier();
      ::vega::BitcoinAddress* temp = identifier_.bitcoinaddress_;
    identifier_.bitcoinaddress_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vega::BitcoinAddress& Identifier::bitcoinaddress() const {
  // @@protoc_insertion_point(field_get:vega.Identifier.bitcoinAddress)
  return has_bitcoinaddress()
      ? *identifier_.bitcoinaddress_
      : *reinterpret_cast< ::vega::BitcoinAddress*>(&::vega::_BitcoinAddress_default_instance_);
}
inline ::vega::BitcoinAddress* Identifier::mutable_bitcoinaddress() {
  if (!has_bitcoinaddress()) {
    clear_identifier();
    set_has_bitcoinaddress();
    identifier_.bitcoinaddress_ = CreateMaybeMessage< ::vega::BitcoinAddress >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:vega.Identifier.bitcoinAddress)
  return identifier_.bitcoinaddress_;
}

inline bool Identifier::has_identifier() const {
  return identifier_case() != IDENTIFIER_NOT_SET;
}
inline void Identifier::clear_has_identifier() {
  _oneof_case_[0] = IDENTIFIER_NOT_SET;
}
inline Identifier::IdentifierCase Identifier::identifier_case() const {
  return Identifier::IdentifierCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// AddValidator

// .vega.Identifier id = 1;
inline bool AddValidator::has_id() const {
  return this != internal_default_instance() && id_ != nullptr;
}
inline void AddValidator::clear_id() {
  if (GetArenaNoVirtual() == nullptr && id_ != nullptr) {
    delete id_;
  }
  id_ = nullptr;
}
inline const ::vega::Identifier& AddValidator::id() const {
  const ::vega::Identifier* p = id_;
  // @@protoc_insertion_point(field_get:vega.AddValidator.id)
  return p != nullptr ? *p : *reinterpret_cast<const ::vega::Identifier*>(
      &::vega::_Identifier_default_instance_);
}
inline ::vega::Identifier* AddValidator::release_id() {
  // @@protoc_insertion_point(field_release:vega.AddValidator.id)

  ::vega::Identifier* temp = id_;
  id_ = nullptr;
  return temp;
}
inline ::vega::Identifier* AddValidator::mutable_id() {

  if (id_ == nullptr) {
    auto* p = CreateMaybeMessage<::vega::Identifier>(GetArenaNoVirtual());
    id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:vega.AddValidator.id)
  return id_;
}
inline void AddValidator::set_allocated_id(::vega::Identifier* id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete id_;
  }
  if (id) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, id, submessage_arena);
    }

  } else {

  }
  id_ = id;
  // @@protoc_insertion_point(field_set_allocated:vega.AddValidator.id)
}

// -------------------------------------------------------------------

// RemoveValidator

// .vega.Identifier id = 1;
inline bool RemoveValidator::has_id() const {
  return this != internal_default_instance() && id_ != nullptr;
}
inline void RemoveValidator::clear_id() {
  if (GetArenaNoVirtual() == nullptr && id_ != nullptr) {
    delete id_;
  }
  id_ = nullptr;
}
inline const ::vega::Identifier& RemoveValidator::id() const {
  const ::vega::Identifier* p = id_;
  // @@protoc_insertion_point(field_get:vega.RemoveValidator.id)
  return p != nullptr ? *p : *reinterpret_cast<const ::vega::Identifier*>(
      &::vega::_Identifier_default_instance_);
}
inline ::vega::Identifier* RemoveValidator::release_id() {
  // @@protoc_insertion_point(field_release:vega.RemoveValidator.id)

  ::vega::Identifier* temp = id_;
  id_ = nullptr;
  return temp;
}
inline ::vega::Identifier* RemoveValidator::mutable_id() {

  if (id_ == nullptr) {
    auto* p = CreateMaybeMessage<::vega::Identifier>(GetArenaNoVirtual());
    id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:vega.RemoveValidator.id)
  return id_;
}
inline void RemoveValidator::set_allocated_id(::vega::Identifier* id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete id_;
  }
  if (id) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, id, submessage_arena);
    }

  } else {

  }
  id_ = id;
  // @@protoc_insertion_point(field_set_allocated:vega.RemoveValidator.id)
}

// -------------------------------------------------------------------

// ValidatorEvent

// string sourceID = 1;
inline void ValidatorEvent::clear_sourceid() {
  sourceid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ValidatorEvent::sourceid() const {
  // @@protoc_insertion_point(field_get:vega.ValidatorEvent.sourceID)
  return sourceid_.GetNoArena();
}
inline void ValidatorEvent::set_sourceid(const ::std::string& value) {

  sourceid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vega.ValidatorEvent.sourceID)
}
#if LANG_CXX11
inline void ValidatorEvent::set_sourceid(::std::string&& value) {

  sourceid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vega.ValidatorEvent.sourceID)
}
#endif
inline void ValidatorEvent::set_sourceid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  sourceid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vega.ValidatorEvent.sourceID)
}
inline void ValidatorEvent::set_sourceid(const char* value, size_t size) {

  sourceid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vega.ValidatorEvent.sourceID)
}
inline ::std::string* ValidatorEvent::mutable_sourceid() {

  // @@protoc_insertion_point(field_mutable:vega.ValidatorEvent.sourceID)
  return sourceid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ValidatorEvent::release_sourceid() {
  // @@protoc_insertion_point(field_release:vega.ValidatorEvent.sourceID)

  return sourceid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ValidatorEvent::set_allocated_sourceid(::std::string* sourceid) {
  if (sourceid != nullptr) {

  } else {

  }
  sourceid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sourceid);
  // @@protoc_insertion_point(field_set_allocated:vega.ValidatorEvent.sourceID)
}

// .vega.AddValidator add = 1001;
inline bool ValidatorEvent::has_add() const {
  return action_case() == kAdd;
}
inline void ValidatorEvent::set_has_add() {
  _oneof_case_[0] = kAdd;
}
inline void ValidatorEvent::clear_add() {
  if (has_add()) {
    delete action_.add_;
    clear_has_action();
  }
}
inline ::vega::AddValidator* ValidatorEvent::release_add() {
  // @@protoc_insertion_point(field_release:vega.ValidatorEvent.add)
  if (has_add()) {
    clear_has_action();
      ::vega::AddValidator* temp = action_.add_;
    action_.add_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vega::AddValidator& ValidatorEvent::add() const {
  // @@protoc_insertion_point(field_get:vega.ValidatorEvent.add)
  return has_add()
      ? *action_.add_
      : *reinterpret_cast< ::vega::AddValidator*>(&::vega::_AddValidator_default_instance_);
}
inline ::vega::AddValidator* ValidatorEvent::mutable_add() {
  if (!has_add()) {
    clear_action();
    set_has_add();
    action_.add_ = CreateMaybeMessage< ::vega::AddValidator >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:vega.ValidatorEvent.add)
  return action_.add_;
}

// .vega.RemoveValidator rm = 1002;
inline bool ValidatorEvent::has_rm() const {
  return action_case() == kRm;
}
inline void ValidatorEvent::set_has_rm() {
  _oneof_case_[0] = kRm;
}
inline void ValidatorEvent::clear_rm() {
  if (has_rm()) {
    delete action_.rm_;
    clear_has_action();
  }
}
inline ::vega::RemoveValidator* ValidatorEvent::release_rm() {
  // @@protoc_insertion_point(field_release:vega.ValidatorEvent.rm)
  if (has_rm()) {
    clear_has_action();
      ::vega::RemoveValidator* temp = action_.rm_;
    action_.rm_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vega::RemoveValidator& ValidatorEvent::rm() const {
  // @@protoc_insertion_point(field_get:vega.ValidatorEvent.rm)
  return has_rm()
      ? *action_.rm_
      : *reinterpret_cast< ::vega::RemoveValidator*>(&::vega::_RemoveValidator_default_instance_);
}
inline ::vega::RemoveValidator* ValidatorEvent::mutable_rm() {
  if (!has_rm()) {
    clear_action();
    set_has_rm();
    action_.rm_ = CreateMaybeMessage< ::vega::RemoveValidator >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:vega.ValidatorEvent.rm)
  return action_.rm_;
}

inline bool ValidatorEvent::has_action() const {
  return action_case() != ACTION_NOT_SET;
}
inline void ValidatorEvent::clear_has_action() {
  _oneof_case_[0] = ACTION_NOT_SET;
}
inline ValidatorEvent::ActionCase ValidatorEvent::action_case() const {
  return ValidatorEvent::ActionCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ChainEvent

// string txID = 1;
inline void ChainEvent::clear_txid() {
  txid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ChainEvent::txid() const {
  // @@protoc_insertion_point(field_get:vega.ChainEvent.txID)
  return txid_.GetNoArena();
}
inline void ChainEvent::set_txid(const ::std::string& value) {

  txid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vega.ChainEvent.txID)
}
#if LANG_CXX11
inline void ChainEvent::set_txid(::std::string&& value) {

  txid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vega.ChainEvent.txID)
}
#endif
inline void ChainEvent::set_txid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  txid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vega.ChainEvent.txID)
}
inline void ChainEvent::set_txid(const char* value, size_t size) {

  txid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vega.ChainEvent.txID)
}
inline ::std::string* ChainEvent::mutable_txid() {

  // @@protoc_insertion_point(field_mutable:vega.ChainEvent.txID)
  return txid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ChainEvent::release_txid() {
  // @@protoc_insertion_point(field_release:vega.ChainEvent.txID)

  return txid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ChainEvent::set_allocated_txid(::std::string* txid) {
  if (txid != nullptr) {

  } else {

  }
  txid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), txid);
  // @@protoc_insertion_point(field_set_allocated:vega.ChainEvent.txID)
}

// uint64 nonce = 2;
inline void ChainEvent::clear_nonce() {
  nonce_ = PROTOBUF_ULONGLONG(0);
}
inline ::google::protobuf::uint64 ChainEvent::nonce() const {
  // @@protoc_insertion_point(field_get:vega.ChainEvent.nonce)
  return nonce_;
}
inline void ChainEvent::set_nonce(::google::protobuf::uint64 value) {

  nonce_ = value;
  // @@protoc_insertion_point(field_set:vega.ChainEvent.nonce)
}

// .vega.BuiltinAssetEvent builtin = 1001;
inline bool ChainEvent::has_builtin() const {
  return event_case() == kBuiltin;
}
inline void ChainEvent::set_has_builtin() {
  _oneof_case_[0] = kBuiltin;
}
inline void ChainEvent::clear_builtin() {
  if (has_builtin()) {
    delete event_.builtin_;
    clear_has_event();
  }
}
inline ::vega::BuiltinAssetEvent* ChainEvent::release_builtin() {
  // @@protoc_insertion_point(field_release:vega.ChainEvent.builtin)
  if (has_builtin()) {
    clear_has_event();
      ::vega::BuiltinAssetEvent* temp = event_.builtin_;
    event_.builtin_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vega::BuiltinAssetEvent& ChainEvent::builtin() const {
  // @@protoc_insertion_point(field_get:vega.ChainEvent.builtin)
  return has_builtin()
      ? *event_.builtin_
      : *reinterpret_cast< ::vega::BuiltinAssetEvent*>(&::vega::_BuiltinAssetEvent_default_instance_);
}
inline ::vega::BuiltinAssetEvent* ChainEvent::mutable_builtin() {
  if (!has_builtin()) {
    clear_event();
    set_has_builtin();
    event_.builtin_ = CreateMaybeMessage< ::vega::BuiltinAssetEvent >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:vega.ChainEvent.builtin)
  return event_.builtin_;
}

// .vega.ERC20Event erc20 = 1002;
inline bool ChainEvent::has_erc20() const {
  return event_case() == kErc20;
}
inline void ChainEvent::set_has_erc20() {
  _oneof_case_[0] = kErc20;
}
inline void ChainEvent::clear_erc20() {
  if (has_erc20()) {
    delete event_.erc20_;
    clear_has_event();
  }
}
inline ::vega::ERC20Event* ChainEvent::release_erc20() {
  // @@protoc_insertion_point(field_release:vega.ChainEvent.erc20)
  if (has_erc20()) {
    clear_has_event();
      ::vega::ERC20Event* temp = event_.erc20_;
    event_.erc20_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vega::ERC20Event& ChainEvent::erc20() const {
  // @@protoc_insertion_point(field_get:vega.ChainEvent.erc20)
  return has_erc20()
      ? *event_.erc20_
      : *reinterpret_cast< ::vega::ERC20Event*>(&::vega::_ERC20Event_default_instance_);
}
inline ::vega::ERC20Event* ChainEvent::mutable_erc20() {
  if (!has_erc20()) {
    clear_event();
    set_has_erc20();
    event_.erc20_ = CreateMaybeMessage< ::vega::ERC20Event >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:vega.ChainEvent.erc20)
  return event_.erc20_;
}

// .vega.BTCEvent btc = 1003;
inline bool ChainEvent::has_btc() const {
  return event_case() == kBtc;
}
inline void ChainEvent::set_has_btc() {
  _oneof_case_[0] = kBtc;
}
inline void ChainEvent::clear_btc() {
  if (has_btc()) {
    delete event_.btc_;
    clear_has_event();
  }
}
inline ::vega::BTCEvent* ChainEvent::release_btc() {
  // @@protoc_insertion_point(field_release:vega.ChainEvent.btc)
  if (has_btc()) {
    clear_has_event();
      ::vega::BTCEvent* temp = event_.btc_;
    event_.btc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vega::BTCEvent& ChainEvent::btc() const {
  // @@protoc_insertion_point(field_get:vega.ChainEvent.btc)
  return has_btc()
      ? *event_.btc_
      : *reinterpret_cast< ::vega::BTCEvent*>(&::vega::_BTCEvent_default_instance_);
}
inline ::vega::BTCEvent* ChainEvent::mutable_btc() {
  if (!has_btc()) {
    clear_event();
    set_has_btc();
    event_.btc_ = CreateMaybeMessage< ::vega::BTCEvent >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:vega.ChainEvent.btc)
  return event_.btc_;
}

// .vega.ValidatorEvent validator = 1004;
inline bool ChainEvent::has_validator() const {
  return event_case() == kValidator;
}
inline void ChainEvent::set_has_validator() {
  _oneof_case_[0] = kValidator;
}
inline void ChainEvent::clear_validator() {
  if (has_validator()) {
    delete event_.validator_;
    clear_has_event();
  }
}
inline ::vega::ValidatorEvent* ChainEvent::release_validator() {
  // @@protoc_insertion_point(field_release:vega.ChainEvent.validator)
  if (has_validator()) {
    clear_has_event();
      ::vega::ValidatorEvent* temp = event_.validator_;
    event_.validator_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vega::ValidatorEvent& ChainEvent::validator() const {
  // @@protoc_insertion_point(field_get:vega.ChainEvent.validator)
  return has_validator()
      ? *event_.validator_
      : *reinterpret_cast< ::vega::ValidatorEvent*>(&::vega::_ValidatorEvent_default_instance_);
}
inline ::vega::ValidatorEvent* ChainEvent::mutable_validator() {
  if (!has_validator()) {
    clear_event();
    set_has_validator();
    event_.validator_ = CreateMaybeMessage< ::vega::ValidatorEvent >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:vega.ChainEvent.validator)
  return event_.validator_;
}

inline bool ChainEvent::has_event() const {
  return event_case() != EVENT_NOT_SET;
}
inline void ChainEvent::clear_has_event() {
  _oneof_case_[0] = EVENT_NOT_SET;
}
inline ChainEvent::EventCase ChainEvent::event_case() const {
  return ChainEvent::EventCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace vega

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // PROTOBUF_INCLUDED_proto_2fchain_5fevents_2eproto

// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: proto/markets.proto

#include "proto/markets.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

extern PROTOBUF_INTERNAL_EXPORT_proto_2fmarkets_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_AuctionDuration_proto_2fmarkets_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_proto_2fmarkets_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_ContinuousTrading_proto_2fmarkets_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_proto_2fmarkets_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_DiscreteTrading_proto_2fmarkets_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_proto_2fmarkets_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_EthereumEvent_proto_2fmarkets_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_proto_2fmarkets_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_FeeFactors_proto_2fmarkets_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_proto_2fmarkets_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_InstrumentMetadata_proto_2fmarkets_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_proto_2fmarkets_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_LogNormalModelParams_proto_2fmarkets_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_proto_2fmarkets_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_PriceMonitoringParameters_proto_2fmarkets_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_proto_2fmarkets_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_ScalingFactors_proto_2fmarkets_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_proto_2fmarkets_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_SimpleModelParams_proto_2fmarkets_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_proto_2fmarkets_2eproto ::google::protobuf::internal::SCCInfo<1> scc_info_Fees_proto_2fmarkets_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_proto_2fmarkets_2eproto ::google::protobuf::internal::SCCInfo<1> scc_info_Future_proto_2fmarkets_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_proto_2fmarkets_2eproto ::google::protobuf::internal::SCCInfo<1> scc_info_LogNormalRiskModel_proto_2fmarkets_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_proto_2fmarkets_2eproto ::google::protobuf::internal::SCCInfo<1> scc_info_MarginCalculator_proto_2fmarkets_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_proto_2fmarkets_2eproto ::google::protobuf::internal::SCCInfo<1> scc_info_PriceMonitoringSettings_proto_2fmarkets_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_proto_2fmarkets_2eproto ::google::protobuf::internal::SCCInfo<1> scc_info_SimpleRiskModel_proto_2fmarkets_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_proto_2fmarkets_2eproto ::google::protobuf::internal::SCCInfo<2> scc_info_Instrument_proto_2fmarkets_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_proto_2fmarkets_2eproto ::google::protobuf::internal::SCCInfo<4> scc_info_TradableInstrument_proto_2fmarkets_2eproto;
namespace vega {
class AuctionDurationDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<AuctionDuration> _instance;
} _AuctionDuration_default_instance_;
class ContinuousTradingDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<ContinuousTrading> _instance;
} _ContinuousTrading_default_instance_;
class DiscreteTradingDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<DiscreteTrading> _instance;
} _DiscreteTrading_default_instance_;
class FutureDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Future> _instance;
  const ::vega::EthereumEvent* ethereumevent_;
} _Future_default_instance_;
class EthereumEventDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<EthereumEvent> _instance;
} _EthereumEvent_default_instance_;
class InstrumentMetadataDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<InstrumentMetadata> _instance;
} _InstrumentMetadata_default_instance_;
class InstrumentDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Instrument> _instance;
  const ::vega::Future* future_;
} _Instrument_default_instance_;
class LogNormalRiskModelDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<LogNormalRiskModel> _instance;
} _LogNormalRiskModel_default_instance_;
class LogNormalModelParamsDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<LogNormalModelParams> _instance;
} _LogNormalModelParams_default_instance_;
class SimpleRiskModelDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<SimpleRiskModel> _instance;
} _SimpleRiskModel_default_instance_;
class SimpleModelParamsDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<SimpleModelParams> _instance;
} _SimpleModelParams_default_instance_;
class ScalingFactorsDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<ScalingFactors> _instance;
} _ScalingFactors_default_instance_;
class MarginCalculatorDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<MarginCalculator> _instance;
} _MarginCalculator_default_instance_;
class TradableInstrumentDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<TradableInstrument> _instance;
  const ::vega::LogNormalRiskModel* lognormalriskmodel_;
  const ::vega::SimpleRiskModel* simpleriskmodel_;
} _TradableInstrument_default_instance_;
class FeeFactorsDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<FeeFactors> _instance;
} _FeeFactors_default_instance_;
class FeesDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Fees> _instance;
} _Fees_default_instance_;
class PriceMonitoringParametersDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<PriceMonitoringParameters> _instance;
} _PriceMonitoringParameters_default_instance_;
class PriceMonitoringSettingsDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<PriceMonitoringSettings> _instance;
} _PriceMonitoringSettings_default_instance_;
class MarketDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Market> _instance;
  const ::vega::ContinuousTrading* continuous_;
  const ::vega::DiscreteTrading* discrete_;
} _Market_default_instance_;
}  // namespace vega
static void InitDefaultsAuctionDuration_proto_2fmarkets_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::vega::_AuctionDuration_default_instance_;
    new (ptr) ::vega::AuctionDuration();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::vega::AuctionDuration::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_AuctionDuration_proto_2fmarkets_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsAuctionDuration_proto_2fmarkets_2eproto}, {}};

static void InitDefaultsContinuousTrading_proto_2fmarkets_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::vega::_ContinuousTrading_default_instance_;
    new (ptr) ::vega::ContinuousTrading();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::vega::ContinuousTrading::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_ContinuousTrading_proto_2fmarkets_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsContinuousTrading_proto_2fmarkets_2eproto}, {}};

static void InitDefaultsDiscreteTrading_proto_2fmarkets_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::vega::_DiscreteTrading_default_instance_;
    new (ptr) ::vega::DiscreteTrading();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::vega::DiscreteTrading::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_DiscreteTrading_proto_2fmarkets_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsDiscreteTrading_proto_2fmarkets_2eproto}, {}};

static void InitDefaultsFuture_proto_2fmarkets_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::vega::_Future_default_instance_;
    new (ptr) ::vega::Future();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::vega::Future::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_Future_proto_2fmarkets_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsFuture_proto_2fmarkets_2eproto}, {
      &scc_info_EthereumEvent_proto_2fmarkets_2eproto.base,}};

static void InitDefaultsEthereumEvent_proto_2fmarkets_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::vega::_EthereumEvent_default_instance_;
    new (ptr) ::vega::EthereumEvent();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::vega::EthereumEvent::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_EthereumEvent_proto_2fmarkets_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsEthereumEvent_proto_2fmarkets_2eproto}, {}};

static void InitDefaultsInstrumentMetadata_proto_2fmarkets_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::vega::_InstrumentMetadata_default_instance_;
    new (ptr) ::vega::InstrumentMetadata();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::vega::InstrumentMetadata::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_InstrumentMetadata_proto_2fmarkets_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsInstrumentMetadata_proto_2fmarkets_2eproto}, {}};

static void InitDefaultsInstrument_proto_2fmarkets_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::vega::_Instrument_default_instance_;
    new (ptr) ::vega::Instrument();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::vega::Instrument::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<2> scc_info_Instrument_proto_2fmarkets_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 2, InitDefaultsInstrument_proto_2fmarkets_2eproto}, {
      &scc_info_InstrumentMetadata_proto_2fmarkets_2eproto.base,
      &scc_info_Future_proto_2fmarkets_2eproto.base,}};

static void InitDefaultsLogNormalRiskModel_proto_2fmarkets_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::vega::_LogNormalRiskModel_default_instance_;
    new (ptr) ::vega::LogNormalRiskModel();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::vega::LogNormalRiskModel::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_LogNormalRiskModel_proto_2fmarkets_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsLogNormalRiskModel_proto_2fmarkets_2eproto}, {
      &scc_info_LogNormalModelParams_proto_2fmarkets_2eproto.base,}};

static void InitDefaultsLogNormalModelParams_proto_2fmarkets_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::vega::_LogNormalModelParams_default_instance_;
    new (ptr) ::vega::LogNormalModelParams();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::vega::LogNormalModelParams::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_LogNormalModelParams_proto_2fmarkets_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsLogNormalModelParams_proto_2fmarkets_2eproto}, {}};

static void InitDefaultsSimpleRiskModel_proto_2fmarkets_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::vega::_SimpleRiskModel_default_instance_;
    new (ptr) ::vega::SimpleRiskModel();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::vega::SimpleRiskModel::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_SimpleRiskModel_proto_2fmarkets_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsSimpleRiskModel_proto_2fmarkets_2eproto}, {
      &scc_info_SimpleModelParams_proto_2fmarkets_2eproto.base,}};

static void InitDefaultsSimpleModelParams_proto_2fmarkets_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::vega::_SimpleModelParams_default_instance_;
    new (ptr) ::vega::SimpleModelParams();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::vega::SimpleModelParams::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_SimpleModelParams_proto_2fmarkets_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsSimpleModelParams_proto_2fmarkets_2eproto}, {}};

static void InitDefaultsScalingFactors_proto_2fmarkets_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::vega::_ScalingFactors_default_instance_;
    new (ptr) ::vega::ScalingFactors();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::vega::ScalingFactors::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_ScalingFactors_proto_2fmarkets_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsScalingFactors_proto_2fmarkets_2eproto}, {}};

static void InitDefaultsMarginCalculator_proto_2fmarkets_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::vega::_MarginCalculator_default_instance_;
    new (ptr) ::vega::MarginCalculator();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::vega::MarginCalculator::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_MarginCalculator_proto_2fmarkets_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsMarginCalculator_proto_2fmarkets_2eproto}, {
      &scc_info_ScalingFactors_proto_2fmarkets_2eproto.base,}};

static void InitDefaultsTradableInstrument_proto_2fmarkets_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::vega::_TradableInstrument_default_instance_;
    new (ptr) ::vega::TradableInstrument();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::vega::TradableInstrument::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<4> scc_info_TradableInstrument_proto_2fmarkets_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 4, InitDefaultsTradableInstrument_proto_2fmarkets_2eproto}, {
      &scc_info_Instrument_proto_2fmarkets_2eproto.base,
      &scc_info_MarginCalculator_proto_2fmarkets_2eproto.base,
      &scc_info_LogNormalRiskModel_proto_2fmarkets_2eproto.base,
      &scc_info_SimpleRiskModel_proto_2fmarkets_2eproto.base,}};

static void InitDefaultsFeeFactors_proto_2fmarkets_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::vega::_FeeFactors_default_instance_;
    new (ptr) ::vega::FeeFactors();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::vega::FeeFactors::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_FeeFactors_proto_2fmarkets_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsFeeFactors_proto_2fmarkets_2eproto}, {}};

static void InitDefaultsFees_proto_2fmarkets_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::vega::_Fees_default_instance_;
    new (ptr) ::vega::Fees();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::vega::Fees::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_Fees_proto_2fmarkets_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsFees_proto_2fmarkets_2eproto}, {
      &scc_info_FeeFactors_proto_2fmarkets_2eproto.base,}};

static void InitDefaultsPriceMonitoringParameters_proto_2fmarkets_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::vega::_PriceMonitoringParameters_default_instance_;
    new (ptr) ::vega::PriceMonitoringParameters();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::vega::PriceMonitoringParameters::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_PriceMonitoringParameters_proto_2fmarkets_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsPriceMonitoringParameters_proto_2fmarkets_2eproto}, {}};

static void InitDefaultsPriceMonitoringSettings_proto_2fmarkets_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::vega::_PriceMonitoringSettings_default_instance_;
    new (ptr) ::vega::PriceMonitoringSettings();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::vega::PriceMonitoringSettings::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_PriceMonitoringSettings_proto_2fmarkets_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsPriceMonitoringSettings_proto_2fmarkets_2eproto}, {
      &scc_info_PriceMonitoringParameters_proto_2fmarkets_2eproto.base,}};

static void InitDefaultsMarket_proto_2fmarkets_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::vega::_Market_default_instance_;
    new (ptr) ::vega::Market();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::vega::Market::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<6> scc_info_Market_proto_2fmarkets_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 6, InitDefaultsMarket_proto_2fmarkets_2eproto}, {
      &scc_info_TradableInstrument_proto_2fmarkets_2eproto.base,
      &scc_info_Fees_proto_2fmarkets_2eproto.base,
      &scc_info_AuctionDuration_proto_2fmarkets_2eproto.base,
      &scc_info_ContinuousTrading_proto_2fmarkets_2eproto.base,
      &scc_info_DiscreteTrading_proto_2fmarkets_2eproto.base,
      &scc_info_PriceMonitoringSettings_proto_2fmarkets_2eproto.base,}};

void InitDefaults_proto_2fmarkets_2eproto() {
  ::google::protobuf::internal::InitSCC(&scc_info_AuctionDuration_proto_2fmarkets_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_ContinuousTrading_proto_2fmarkets_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_DiscreteTrading_proto_2fmarkets_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_Future_proto_2fmarkets_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_EthereumEvent_proto_2fmarkets_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_InstrumentMetadata_proto_2fmarkets_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_Instrument_proto_2fmarkets_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_LogNormalRiskModel_proto_2fmarkets_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_LogNormalModelParams_proto_2fmarkets_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_SimpleRiskModel_proto_2fmarkets_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_SimpleModelParams_proto_2fmarkets_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_ScalingFactors_proto_2fmarkets_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_MarginCalculator_proto_2fmarkets_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_TradableInstrument_proto_2fmarkets_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_FeeFactors_proto_2fmarkets_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_Fees_proto_2fmarkets_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_PriceMonitoringParameters_proto_2fmarkets_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_PriceMonitoringSettings_proto_2fmarkets_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_Market_proto_2fmarkets_2eproto.base);
}

::google::protobuf::Metadata file_level_metadata_proto_2fmarkets_2eproto[19];
constexpr ::google::protobuf::EnumDescriptor const** file_level_enum_descriptors_proto_2fmarkets_2eproto = nullptr;
constexpr ::google::protobuf::ServiceDescriptor const** file_level_service_descriptors_proto_2fmarkets_2eproto = nullptr;

const ::google::protobuf::uint32 TableStruct_proto_2fmarkets_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vega::AuctionDuration, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::vega::AuctionDuration, duration_),
  PROTOBUF_FIELD_OFFSET(::vega::AuctionDuration, volume_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vega::ContinuousTrading, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::vega::ContinuousTrading, ticksize_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vega::DiscreteTrading, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::vega::DiscreteTrading, durationns_),
  PROTOBUF_FIELD_OFFSET(::vega::DiscreteTrading, ticksize_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vega::Future, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::vega::Future, _oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::vega::Future, maturity_),
  PROTOBUF_FIELD_OFFSET(::vega::Future, asset_),
  offsetof(::vega::FutureDefaultTypeInternal, ethereumevent_),
  PROTOBUF_FIELD_OFFSET(::vega::Future, oracle_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vega::EthereumEvent, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::vega::EthereumEvent, contractid_),
  PROTOBUF_FIELD_OFFSET(::vega::EthereumEvent, event_),
  PROTOBUF_FIELD_OFFSET(::vega::EthereumEvent, value_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vega::InstrumentMetadata, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::vega::InstrumentMetadata, tags_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vega::Instrument, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::vega::Instrument, _oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::vega::Instrument, id_),
  PROTOBUF_FIELD_OFFSET(::vega::Instrument, code_),
  PROTOBUF_FIELD_OFFSET(::vega::Instrument, name_),
  PROTOBUF_FIELD_OFFSET(::vega::Instrument, basename_),
  PROTOBUF_FIELD_OFFSET(::vega::Instrument, quotename_),
  PROTOBUF_FIELD_OFFSET(::vega::Instrument, metadata_),
  PROTOBUF_FIELD_OFFSET(::vega::Instrument, initialmarkprice_),
  offsetof(::vega::InstrumentDefaultTypeInternal, future_),
  PROTOBUF_FIELD_OFFSET(::vega::Instrument, product_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vega::LogNormalRiskModel, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::vega::LogNormalRiskModel, riskaversionparameter_),
  PROTOBUF_FIELD_OFFSET(::vega::LogNormalRiskModel, tau_),
  PROTOBUF_FIELD_OFFSET(::vega::LogNormalRiskModel, params_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vega::LogNormalModelParams, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::vega::LogNormalModelParams, mu_),
  PROTOBUF_FIELD_OFFSET(::vega::LogNormalModelParams, r_),
  PROTOBUF_FIELD_OFFSET(::vega::LogNormalModelParams, sigma_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vega::SimpleRiskModel, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::vega::SimpleRiskModel, params_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vega::SimpleModelParams, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::vega::SimpleModelParams, factorlong_),
  PROTOBUF_FIELD_OFFSET(::vega::SimpleModelParams, factorshort_),
  PROTOBUF_FIELD_OFFSET(::vega::SimpleModelParams, maxmoveup_),
  PROTOBUF_FIELD_OFFSET(::vega::SimpleModelParams, minmovedown_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vega::ScalingFactors, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::vega::ScalingFactors, searchlevel_),
  PROTOBUF_FIELD_OFFSET(::vega::ScalingFactors, initialmargin_),
  PROTOBUF_FIELD_OFFSET(::vega::ScalingFactors, collateralrelease_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vega::MarginCalculator, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::vega::MarginCalculator, scalingfactors_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vega::TradableInstrument, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::vega::TradableInstrument, _oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::vega::TradableInstrument, instrument_),
  PROTOBUF_FIELD_OFFSET(::vega::TradableInstrument, margincalculator_),
  offsetof(::vega::TradableInstrumentDefaultTypeInternal, lognormalriskmodel_),
  offsetof(::vega::TradableInstrumentDefaultTypeInternal, simpleriskmodel_),
  PROTOBUF_FIELD_OFFSET(::vega::TradableInstrument, riskModel_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vega::FeeFactors, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::vega::FeeFactors, makerfee_),
  PROTOBUF_FIELD_OFFSET(::vega::FeeFactors, infrastructurefee_),
  PROTOBUF_FIELD_OFFSET(::vega::FeeFactors, liquidityfee_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vega::Fees, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::vega::Fees, factors_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vega::PriceMonitoringParameters, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::vega::PriceMonitoringParameters, horizon_),
  PROTOBUF_FIELD_OFFSET(::vega::PriceMonitoringParameters, probability_),
  PROTOBUF_FIELD_OFFSET(::vega::PriceMonitoringParameters, auctionextension_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vega::PriceMonitoringSettings, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::vega::PriceMonitoringSettings, pricemonitoringparameters_),
  PROTOBUF_FIELD_OFFSET(::vega::PriceMonitoringSettings, updatefrequency_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vega::Market, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::vega::Market, _oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::vega::Market, id_),
  PROTOBUF_FIELD_OFFSET(::vega::Market, tradableinstrument_),
  PROTOBUF_FIELD_OFFSET(::vega::Market, decimalplaces_),
  PROTOBUF_FIELD_OFFSET(::vega::Market, fees_),
  PROTOBUF_FIELD_OFFSET(::vega::Market, openingauction_),
  offsetof(::vega::MarketDefaultTypeInternal, continuous_),
  offsetof(::vega::MarketDefaultTypeInternal, discrete_),
  PROTOBUF_FIELD_OFFSET(::vega::Market, pricemonitoringsettings_),
  PROTOBUF_FIELD_OFFSET(::vega::Market, tradingMode_),
};
static const ::google::protobuf::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, sizeof(::vega::AuctionDuration)},
  { 7, -1, sizeof(::vega::ContinuousTrading)},
  { 13, -1, sizeof(::vega::DiscreteTrading)},
  { 20, -1, sizeof(::vega::Future)},
  { 29, -1, sizeof(::vega::EthereumEvent)},
  { 37, -1, sizeof(::vega::InstrumentMetadata)},
  { 43, -1, sizeof(::vega::Instrument)},
  { 57, -1, sizeof(::vega::LogNormalRiskModel)},
  { 65, -1, sizeof(::vega::LogNormalModelParams)},
  { 73, -1, sizeof(::vega::SimpleRiskModel)},
  { 79, -1, sizeof(::vega::SimpleModelParams)},
  { 88, -1, sizeof(::vega::ScalingFactors)},
  { 96, -1, sizeof(::vega::MarginCalculator)},
  { 102, -1, sizeof(::vega::TradableInstrument)},
  { 112, -1, sizeof(::vega::FeeFactors)},
  { 120, -1, sizeof(::vega::Fees)},
  { 126, -1, sizeof(::vega::PriceMonitoringParameters)},
  { 134, -1, sizeof(::vega::PriceMonitoringSettings)},
  { 141, -1, sizeof(::vega::Market)},
};

static ::google::protobuf::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::google::protobuf::Message*>(&::vega::_AuctionDuration_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::vega::_ContinuousTrading_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::vega::_DiscreteTrading_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::vega::_Future_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::vega::_EthereumEvent_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::vega::_InstrumentMetadata_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::vega::_Instrument_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::vega::_LogNormalRiskModel_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::vega::_LogNormalModelParams_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::vega::_SimpleRiskModel_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::vega::_SimpleModelParams_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::vega::_ScalingFactors_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::vega::_MarginCalculator_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::vega::_TradableInstrument_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::vega::_FeeFactors_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::vega::_Fees_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::vega::_PriceMonitoringParameters_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::vega::_PriceMonitoringSettings_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::vega::_Market_default_instance_),
};

::google::protobuf::internal::AssignDescriptorsTable assign_descriptors_table_proto_2fmarkets_2eproto = {
  {}, AddDescriptors_proto_2fmarkets_2eproto, "proto/markets.proto", schemas,
  file_default_instances, TableStruct_proto_2fmarkets_2eproto::offsets,
  file_level_metadata_proto_2fmarkets_2eproto, 19, file_level_enum_descriptors_proto_2fmarkets_2eproto, file_level_service_descriptors_proto_2fmarkets_2eproto,
};

const char descriptor_table_protodef_proto_2fmarkets_2eproto[] =
  "\n\023proto/markets.proto\022\004vega\0326github.com/"
  "mwitkow/go-proto-validators/validator.pr"
  "oto\"3\n\017AuctionDuration\022\020\n\010duration\030\001 \001(\003"
  "\022\016\n\006volume\030\002 \001(\004\"%\n\021ContinuousTrading\022\020\n"
  "\010tickSize\030\001 \001(\t\"H\n\017DiscreteTrading\022#\n\ndu"
  "rationNs\030\001 \001(\003B\017\342\337\037\013\020\000\030\200\200\210\272\220\255\315\004\022\020\n\010tickS"
  "ize\030\002 \001(\t\"a\n\006Future\022\020\n\010maturity\030\001 \001(\t\022\r\n"
  "\005asset\030\002 \001(\t\022,\n\rethereumEvent\030d \001(\0132\023.ve"
  "ga.EthereumEventH\000B\010\n\006oracle\"A\n\rEthereum"
  "Event\022\022\n\ncontractID\030\001 \001(\t\022\r\n\005event\030\002 \001(\t"
  "\022\r\n\005value\030\003 \001(\004\"\"\n\022InstrumentMetadata\022\014\n"
  "\004tags\030\001 \003(\t\"\312\001\n\nInstrument\022\n\n\002id\030\001 \001(\t\022\014"
  "\n\004code\030\002 \001(\t\022\014\n\004name\030\003 \001(\t\022\020\n\010baseName\030\004"
  " \001(\t\022\021\n\tquoteName\030\005 \001(\t\022*\n\010metadata\030\006 \001("
  "\0132\030.vega.InstrumentMetadata\022\030\n\020initialMa"
  "rkPrice\030\007 \001(\004\022\036\n\006future\030d \001(\0132\014.vega.Fut"
  "ureH\000B\t\n\007product\"l\n\022LogNormalRiskModel\022\035"
  "\n\025riskAversionParameter\030\001 \001(\001\022\013\n\003tau\030\002 \001"
  "(\001\022*\n\006params\030\003 \001(\0132\032.vega.LogNormalModel"
  "Params\"<\n\024LogNormalModelParams\022\n\n\002mu\030\001 \001"
  "(\001\022\t\n\001r\030\002 \001(\001\022\r\n\005sigma\030\003 \001(\001\":\n\017SimpleRi"
  "skModel\022\'\n\006params\030\001 \001(\0132\027.vega.SimpleMod"
  "elParams\"\202\001\n\021SimpleModelParams\022\022\n\nfactor"
  "Long\030\001 \001(\001\022\023\n\013factorShort\030\002 \001(\001\022 \n\tmaxMo"
  "veUp\030\003 \001(\001B\r\342\337\037\tI\000\000\000\000\000\000\000\000\022\"\n\013minMoveDown"
  "\030\004 \001(\001B\r\342\337\037\tQ\000\000\000\000\000\000\000\000\"W\n\016ScalingFactors\022"
  "\023\n\013searchLevel\030\001 \001(\001\022\025\n\rinitialMargin\030\002 "
  "\001(\001\022\031\n\021collateralRelease\030\003 \001(\001\"@\n\020Margin"
  "Calculator\022,\n\016scalingFactors\030\001 \001(\0132\024.veg"
  "a.ScalingFactors\"\343\001\n\022TradableInstrument\022"
  "$\n\ninstrument\030\001 \001(\0132\020.vega.Instrument\0220\n"
  "\020marginCalculator\030\002 \001(\0132\026.vega.MarginCal"
  "culator\0226\n\022logNormalRiskModel\030d \001(\0132\030.ve"
  "ga.LogNormalRiskModelH\000\0220\n\017simpleRiskMod"
  "el\030e \001(\0132\025.vega.SimpleRiskModelH\000B\013\n\tris"
  "kModel\"O\n\nFeeFactors\022\020\n\010makerFee\030\001 \001(\t\022\031"
  "\n\021infrastructureFee\030\002 \001(\t\022\024\n\014liquidityFe"
  "e\030\003 \001(\t\")\n\004Fees\022!\n\007factors\030\001 \001(\0132\020.vega."
  "FeeFactors\"\203\001\n\031PriceMonitoringParameters"
  "\022\027\n\007horizon\030\001 \001(\003B\006\342\337\037\002\020\000\022+\n\013probability"
  "\030\002 \001(\001B\026\342\337\037\0221\000\000\000\000\000\000\000\0009\000\000\000\000\000\000\360\?\022 \n\020auctio"
  "nExtension\030\003 \001(\003B\006\342\337\037\002\020\000\"v\n\027PriceMonitor"
  "ingSettings\022B\n\031priceMonitoringParameters"
  "\030\001 \003(\0132\037.vega.PriceMonitoringParameters\022"
  "\027\n\017updateFrequency\030\002 \001(\003\"\323\002\n\006Market\022\n\n\002i"
  "d\030\001 \001(\t\0224\n\022tradableInstrument\030\002 \001(\0132\030.ve"
  "ga.TradableInstrument\022\025\n\rdecimalPlaces\030\003"
  " \001(\004\022\030\n\004fees\030\004 \001(\0132\n.vega.Fees\022-\n\016openin"
  "gAuction\030\005 \001(\0132\025.vega.AuctionDuration\022-\n"
  "\ncontinuous\030d \001(\0132\027.vega.ContinuousTradi"
  "ngH\000\022)\n\010discrete\030e \001(\0132\025.vega.DiscreteTr"
  "adingH\000\022>\n\027priceMonitoringSettings\030\006 \001(\013"
  "2\035.vega.PriceMonitoringSettingsB\r\n\013tradi"
  "ngModeB7\n\024io.vegaprotocol.vegaZ\037code.veg"
  "aprotocol.io/vega/protob\006proto3"
  ;
::google::protobuf::internal::DescriptorTable descriptor_table_proto_2fmarkets_2eproto = {
  false, InitDefaults_proto_2fmarkets_2eproto, 
  descriptor_table_protodef_proto_2fmarkets_2eproto,
  "proto/markets.proto", &assign_descriptors_table_proto_2fmarkets_2eproto, 2191,
};

void AddDescriptors_proto_2fmarkets_2eproto() {
  static constexpr ::google::protobuf::internal::InitFunc deps[1] =
  {
    ::AddDescriptors_github_2ecom_2fmwitkow_2fgo_2dproto_2dvalidators_2fvalidator_2eproto,
  };
 ::google::protobuf::internal::AddDescriptors(&descriptor_table_proto_2fmarkets_2eproto, deps, 1);
}

// Force running AddDescriptors() at dynamic initialization time.
static bool dynamic_init_dummy_proto_2fmarkets_2eproto = []() { AddDescriptors_proto_2fmarkets_2eproto(); return true; }();
namespace vega {

// ===================================================================

void AuctionDuration::InitAsDefaultInstance() {
}
class AuctionDuration::HasBitSetters {
 public:
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int AuctionDuration::kDurationFieldNumber;
const int AuctionDuration::kVolumeFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

AuctionDuration::AuctionDuration()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:vega.AuctionDuration)
}
AuctionDuration::AuctionDuration(const AuctionDuration& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&duration_, &from.duration_,
    static_cast<size_t>(reinterpret_cast<char*>(&volume_) -
    reinterpret_cast<char*>(&duration_)) + sizeof(volume_));
  // @@protoc_insertion_point(copy_constructor:vega.AuctionDuration)
}

void AuctionDuration::SharedCtor() {
  ::memset(&duration_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&volume_) -
      reinterpret_cast<char*>(&duration_)) + sizeof(volume_));
}

AuctionDuration::~AuctionDuration() {
  // @@protoc_insertion_point(destructor:vega.AuctionDuration)
  SharedDtor();
}

void AuctionDuration::SharedDtor() {
}

void AuctionDuration::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const AuctionDuration& AuctionDuration::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_AuctionDuration_proto_2fmarkets_2eproto.base);
  return *internal_default_instance();
}


void AuctionDuration::Clear() {
// @@protoc_insertion_point(message_clear_start:vega.AuctionDuration)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&duration_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&volume_) -
      reinterpret_cast<char*>(&duration_)) + sizeof(volume_));
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* AuctionDuration::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<AuctionDuration*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // int64 duration = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        msg->set_duration(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // uint64 volume = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 16) goto handle_unusual;
        msg->set_volume(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool AuctionDuration::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vega.AuctionDuration)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // int64 duration = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &duration_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // uint64 volume = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (16 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &volume_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vega.AuctionDuration)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vega.AuctionDuration)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void AuctionDuration::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vega.AuctionDuration)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // int64 duration = 1;
  if (this->duration() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->duration(), output);
  }

  // uint64 volume = 2;
  if (this->volume() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->volume(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:vega.AuctionDuration)
}

::google::protobuf::uint8* AuctionDuration::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:vega.AuctionDuration)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // int64 duration = 1;
  if (this->duration() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(1, this->duration(), target);
  }

  // uint64 volume = 2;
  if (this->volume() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(2, this->volume(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vega.AuctionDuration)
  return target;
}

size_t AuctionDuration::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vega.AuctionDuration)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int64 duration = 1;
  if (this->duration() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int64Size(
        this->duration());
  }

  // uint64 volume = 2;
  if (this->volume() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->volume());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AuctionDuration::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:vega.AuctionDuration)
  GOOGLE_DCHECK_NE(&from, this);
  const AuctionDuration* source =
      ::google::protobuf::DynamicCastToGenerated<AuctionDuration>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:vega.AuctionDuration)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:vega.AuctionDuration)
    MergeFrom(*source);
  }
}

void AuctionDuration::MergeFrom(const AuctionDuration& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vega.AuctionDuration)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.duration() != 0) {
    set_duration(from.duration());
  }
  if (from.volume() != 0) {
    set_volume(from.volume());
  }
}

void AuctionDuration::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:vega.AuctionDuration)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AuctionDuration::CopyFrom(const AuctionDuration& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vega.AuctionDuration)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AuctionDuration::IsInitialized() const {
  return true;
}

void AuctionDuration::Swap(AuctionDuration* other) {
  if (other == this) return;
  InternalSwap(other);
}
void AuctionDuration::InternalSwap(AuctionDuration* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(duration_, other->duration_);
  swap(volume_, other->volume_);
}

::google::protobuf::Metadata AuctionDuration::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_proto_2fmarkets_2eproto);
  return ::file_level_metadata_proto_2fmarkets_2eproto[kIndexInFileMessages];
}


// ===================================================================

void ContinuousTrading::InitAsDefaultInstance() {
}
class ContinuousTrading::HasBitSetters {
 public:
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ContinuousTrading::kTickSizeFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ContinuousTrading::ContinuousTrading()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:vega.ContinuousTrading)
}
ContinuousTrading::ContinuousTrading(const ContinuousTrading& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ticksize_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.ticksize().size() > 0) {
    ticksize_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.ticksize_);
  }
  // @@protoc_insertion_point(copy_constructor:vega.ContinuousTrading)
}

void ContinuousTrading::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_ContinuousTrading_proto_2fmarkets_2eproto.base);
  ticksize_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

ContinuousTrading::~ContinuousTrading() {
  // @@protoc_insertion_point(destructor:vega.ContinuousTrading)
  SharedDtor();
}

void ContinuousTrading::SharedDtor() {
  ticksize_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void ContinuousTrading::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ContinuousTrading& ContinuousTrading::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_ContinuousTrading_proto_2fmarkets_2eproto.base);
  return *internal_default_instance();
}


void ContinuousTrading::Clear() {
// @@protoc_insertion_point(message_clear_start:vega.ContinuousTrading)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ticksize_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* ContinuousTrading::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<ContinuousTrading*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // string tickSize = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ctx->extra_parse_data().SetFieldName("vega.ContinuousTrading.tickSize");
        object = msg->mutable_ticksize();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParserUTF8;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheckUTF8(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
string_till_end:
  static_cast<::std::string*>(object)->clear();
  static_cast<::std::string*>(object)->reserve(size);
  goto len_delim_till_end;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool ContinuousTrading::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vega.ContinuousTrading)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // string tickSize = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_ticksize()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->ticksize().data(), static_cast<int>(this->ticksize().length()),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "vega.ContinuousTrading.tickSize"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vega.ContinuousTrading)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vega.ContinuousTrading)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void ContinuousTrading::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vega.ContinuousTrading)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // string tickSize = 1;
  if (this->ticksize().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->ticksize().data(), static_cast<int>(this->ticksize().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "vega.ContinuousTrading.tickSize");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->ticksize(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:vega.ContinuousTrading)
}

::google::protobuf::uint8* ContinuousTrading::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:vega.ContinuousTrading)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // string tickSize = 1;
  if (this->ticksize().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->ticksize().data(), static_cast<int>(this->ticksize().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "vega.ContinuousTrading.tickSize");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->ticksize(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vega.ContinuousTrading)
  return target;
}

size_t ContinuousTrading::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vega.ContinuousTrading)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string tickSize = 1;
  if (this->ticksize().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->ticksize());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ContinuousTrading::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:vega.ContinuousTrading)
  GOOGLE_DCHECK_NE(&from, this);
  const ContinuousTrading* source =
      ::google::protobuf::DynamicCastToGenerated<ContinuousTrading>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:vega.ContinuousTrading)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:vega.ContinuousTrading)
    MergeFrom(*source);
  }
}

void ContinuousTrading::MergeFrom(const ContinuousTrading& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vega.ContinuousTrading)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.ticksize().size() > 0) {

    ticksize_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.ticksize_);
  }
}

void ContinuousTrading::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:vega.ContinuousTrading)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ContinuousTrading::CopyFrom(const ContinuousTrading& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vega.ContinuousTrading)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ContinuousTrading::IsInitialized() const {
  return true;
}

void ContinuousTrading::Swap(ContinuousTrading* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ContinuousTrading::InternalSwap(ContinuousTrading* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  ticksize_.Swap(&other->ticksize_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
}

::google::protobuf::Metadata ContinuousTrading::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_proto_2fmarkets_2eproto);
  return ::file_level_metadata_proto_2fmarkets_2eproto[kIndexInFileMessages];
}


// ===================================================================

void DiscreteTrading::InitAsDefaultInstance() {
}
class DiscreteTrading::HasBitSetters {
 public:
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int DiscreteTrading::kDurationNsFieldNumber;
const int DiscreteTrading::kTickSizeFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

DiscreteTrading::DiscreteTrading()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:vega.DiscreteTrading)
}
DiscreteTrading::DiscreteTrading(const DiscreteTrading& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ticksize_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.ticksize().size() > 0) {
    ticksize_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.ticksize_);
  }
  durationns_ = from.durationns_;
  // @@protoc_insertion_point(copy_constructor:vega.DiscreteTrading)
}

void DiscreteTrading::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_DiscreteTrading_proto_2fmarkets_2eproto.base);
  ticksize_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  durationns_ = PROTOBUF_LONGLONG(0);
}

DiscreteTrading::~DiscreteTrading() {
  // @@protoc_insertion_point(destructor:vega.DiscreteTrading)
  SharedDtor();
}

void DiscreteTrading::SharedDtor() {
  ticksize_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void DiscreteTrading::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const DiscreteTrading& DiscreteTrading::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_DiscreteTrading_proto_2fmarkets_2eproto.base);
  return *internal_default_instance();
}


void DiscreteTrading::Clear() {
// @@protoc_insertion_point(message_clear_start:vega.DiscreteTrading)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ticksize_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  durationns_ = PROTOBUF_LONGLONG(0);
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* DiscreteTrading::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<DiscreteTrading*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // int64 durationNs = 1 [(.validator.field) = {
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        msg->set_durationns(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // string tickSize = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ctx->extra_parse_data().SetFieldName("vega.DiscreteTrading.tickSize");
        object = msg->mutable_ticksize();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParserUTF8;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheckUTF8(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
string_till_end:
  static_cast<::std::string*>(object)->clear();
  static_cast<::std::string*>(object)->reserve(size);
  goto len_delim_till_end;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool DiscreteTrading::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vega.DiscreteTrading)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // int64 durationNs = 1 [(.validator.field) = {
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &durationns_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // string tickSize = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_ticksize()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->ticksize().data(), static_cast<int>(this->ticksize().length()),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "vega.DiscreteTrading.tickSize"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vega.DiscreteTrading)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vega.DiscreteTrading)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void DiscreteTrading::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vega.DiscreteTrading)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // int64 durationNs = 1 [(.validator.field) = {
  if (this->durationns() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->durationns(), output);
  }

  // string tickSize = 2;
  if (this->ticksize().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->ticksize().data(), static_cast<int>(this->ticksize().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "vega.DiscreteTrading.tickSize");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->ticksize(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:vega.DiscreteTrading)
}

::google::protobuf::uint8* DiscreteTrading::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:vega.DiscreteTrading)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // int64 durationNs = 1 [(.validator.field) = {
  if (this->durationns() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(1, this->durationns(), target);
  }

  // string tickSize = 2;
  if (this->ticksize().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->ticksize().data(), static_cast<int>(this->ticksize().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "vega.DiscreteTrading.tickSize");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->ticksize(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vega.DiscreteTrading)
  return target;
}

size_t DiscreteTrading::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vega.DiscreteTrading)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string tickSize = 2;
  if (this->ticksize().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->ticksize());
  }

  // int64 durationNs = 1 [(.validator.field) = {
  if (this->durationns() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int64Size(
        this->durationns());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DiscreteTrading::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:vega.DiscreteTrading)
  GOOGLE_DCHECK_NE(&from, this);
  const DiscreteTrading* source =
      ::google::protobuf::DynamicCastToGenerated<DiscreteTrading>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:vega.DiscreteTrading)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:vega.DiscreteTrading)
    MergeFrom(*source);
  }
}

void DiscreteTrading::MergeFrom(const DiscreteTrading& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vega.DiscreteTrading)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.ticksize().size() > 0) {

    ticksize_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.ticksize_);
  }
  if (from.durationns() != 0) {
    set_durationns(from.durationns());
  }
}

void DiscreteTrading::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:vega.DiscreteTrading)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DiscreteTrading::CopyFrom(const DiscreteTrading& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vega.DiscreteTrading)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DiscreteTrading::IsInitialized() const {
  return true;
}

void DiscreteTrading::Swap(DiscreteTrading* other) {
  if (other == this) return;
  InternalSwap(other);
}
void DiscreteTrading::InternalSwap(DiscreteTrading* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  ticksize_.Swap(&other->ticksize_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(durationns_, other->durationns_);
}

::google::protobuf::Metadata DiscreteTrading::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_proto_2fmarkets_2eproto);
  return ::file_level_metadata_proto_2fmarkets_2eproto[kIndexInFileMessages];
}


// ===================================================================

void Future::InitAsDefaultInstance() {
  ::vega::_Future_default_instance_.ethereumevent_ = const_cast< ::vega::EthereumEvent*>(
      ::vega::EthereumEvent::internal_default_instance());
}
class Future::HasBitSetters {
 public:
  static const ::vega::EthereumEvent& ethereumevent(const Future* msg);
};

const ::vega::EthereumEvent&
Future::HasBitSetters::ethereumevent(const Future* msg) {
  return *msg->oracle_.ethereumevent_;
}
void Future::set_allocated_ethereumevent(::vega::EthereumEvent* ethereumevent) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  clear_oracle();
  if (ethereumevent) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      ethereumevent = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ethereumevent, submessage_arena);
    }
    set_has_ethereumevent();
    oracle_.ethereumevent_ = ethereumevent;
  }
  // @@protoc_insertion_point(field_set_allocated:vega.Future.ethereumEvent)
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Future::kMaturityFieldNumber;
const int Future::kAssetFieldNumber;
const int Future::kEthereumEventFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Future::Future()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:vega.Future)
}
Future::Future(const Future& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  maturity_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.maturity().size() > 0) {
    maturity_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.maturity_);
  }
  asset_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.asset().size() > 0) {
    asset_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.asset_);
  }
  clear_has_oracle();
  switch (from.oracle_case()) {
    case kEthereumEvent: {
      mutable_ethereumevent()->::vega::EthereumEvent::MergeFrom(from.ethereumevent());
      break;
    }
    case ORACLE_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:vega.Future)
}

void Future::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_Future_proto_2fmarkets_2eproto.base);
  maturity_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  asset_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_oracle();
}

Future::~Future() {
  // @@protoc_insertion_point(destructor:vega.Future)
  SharedDtor();
}

void Future::SharedDtor() {
  maturity_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  asset_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (has_oracle()) {
    clear_oracle();
  }
}

void Future::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Future& Future::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_Future_proto_2fmarkets_2eproto.base);
  return *internal_default_instance();
}


void Future::clear_oracle() {
// @@protoc_insertion_point(one_of_clear_start:vega.Future)
  switch (oracle_case()) {
    case kEthereumEvent: {
      delete oracle_.ethereumevent_;
      break;
    }
    case ORACLE_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = ORACLE_NOT_SET;
}


void Future::Clear() {
// @@protoc_insertion_point(message_clear_start:vega.Future)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  maturity_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  asset_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_oracle();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Future::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<Future*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // string maturity = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ctx->extra_parse_data().SetFieldName("vega.Future.maturity");
        object = msg->mutable_maturity();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParserUTF8;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheckUTF8(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      // string asset = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ctx->extra_parse_data().SetFieldName("vega.Future.asset");
        object = msg->mutable_asset();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParserUTF8;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheckUTF8(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      // .vega.EthereumEvent ethereumEvent = 100;
      case 100: {
        if (static_cast<::google::protobuf::uint8>(tag) != 34) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::vega::EthereumEvent::_InternalParse;
        object = msg->mutable_ethereumevent();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
string_till_end:
  static_cast<::std::string*>(object)->clear();
  static_cast<::std::string*>(object)->reserve(size);
  goto len_delim_till_end;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Future::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vega.Future)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(16383u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // string maturity = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_maturity()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->maturity().data(), static_cast<int>(this->maturity().length()),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "vega.Future.maturity"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // string asset = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_asset()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->asset().data(), static_cast<int>(this->asset().length()),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "vega.Future.asset"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .vega.EthereumEvent ethereumEvent = 100;
      case 100: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (802 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_ethereumevent()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vega.Future)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vega.Future)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Future::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vega.Future)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // string maturity = 1;
  if (this->maturity().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->maturity().data(), static_cast<int>(this->maturity().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "vega.Future.maturity");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->maturity(), output);
  }

  // string asset = 2;
  if (this->asset().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->asset().data(), static_cast<int>(this->asset().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "vega.Future.asset");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->asset(), output);
  }

  // .vega.EthereumEvent ethereumEvent = 100;
  if (has_ethereumevent()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      100, HasBitSetters::ethereumevent(this), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:vega.Future)
}

::google::protobuf::uint8* Future::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:vega.Future)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // string maturity = 1;
  if (this->maturity().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->maturity().data(), static_cast<int>(this->maturity().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "vega.Future.maturity");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->maturity(), target);
  }

  // string asset = 2;
  if (this->asset().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->asset().data(), static_cast<int>(this->asset().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "vega.Future.asset");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->asset(), target);
  }

  // .vega.EthereumEvent ethereumEvent = 100;
  if (has_ethereumevent()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        100, HasBitSetters::ethereumevent(this), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vega.Future)
  return target;
}

size_t Future::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vega.Future)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string maturity = 1;
  if (this->maturity().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->maturity());
  }

  // string asset = 2;
  if (this->asset().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->asset());
  }

  switch (oracle_case()) {
    // .vega.EthereumEvent ethereumEvent = 100;
    case kEthereumEvent: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *oracle_.ethereumevent_);
      break;
    }
    case ORACLE_NOT_SET: {
      break;
    }
  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Future::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:vega.Future)
  GOOGLE_DCHECK_NE(&from, this);
  const Future* source =
      ::google::protobuf::DynamicCastToGenerated<Future>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:vega.Future)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:vega.Future)
    MergeFrom(*source);
  }
}

void Future::MergeFrom(const Future& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vega.Future)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.maturity().size() > 0) {

    maturity_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.maturity_);
  }
  if (from.asset().size() > 0) {

    asset_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.asset_);
  }
  switch (from.oracle_case()) {
    case kEthereumEvent: {
      mutable_ethereumevent()->::vega::EthereumEvent::MergeFrom(from.ethereumevent());
      break;
    }
    case ORACLE_NOT_SET: {
      break;
    }
  }
}

void Future::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:vega.Future)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Future::CopyFrom(const Future& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vega.Future)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Future::IsInitialized() const {
  return true;
}

void Future::Swap(Future* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Future::InternalSwap(Future* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  maturity_.Swap(&other->maturity_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  asset_.Swap(&other->asset_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(oracle_, other->oracle_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

::google::protobuf::Metadata Future::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_proto_2fmarkets_2eproto);
  return ::file_level_metadata_proto_2fmarkets_2eproto[kIndexInFileMessages];
}


// ===================================================================

void EthereumEvent::InitAsDefaultInstance() {
}
class EthereumEvent::HasBitSetters {
 public:
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int EthereumEvent::kContractIDFieldNumber;
const int EthereumEvent::kEventFieldNumber;
const int EthereumEvent::kValueFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

EthereumEvent::EthereumEvent()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:vega.EthereumEvent)
}
EthereumEvent::EthereumEvent(const EthereumEvent& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  contractid_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.contractid().size() > 0) {
    contractid_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.contractid_);
  }
  event_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.event().size() > 0) {
    event_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.event_);
  }
  value_ = from.value_;
  // @@protoc_insertion_point(copy_constructor:vega.EthereumEvent)
}

void EthereumEvent::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_EthereumEvent_proto_2fmarkets_2eproto.base);
  contractid_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  event_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  value_ = PROTOBUF_ULONGLONG(0);
}

EthereumEvent::~EthereumEvent() {
  // @@protoc_insertion_point(destructor:vega.EthereumEvent)
  SharedDtor();
}

void EthereumEvent::SharedDtor() {
  contractid_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  event_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void EthereumEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const EthereumEvent& EthereumEvent::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_EthereumEvent_proto_2fmarkets_2eproto.base);
  return *internal_default_instance();
}


void EthereumEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:vega.EthereumEvent)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  contractid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  event_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  value_ = PROTOBUF_ULONGLONG(0);
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* EthereumEvent::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<EthereumEvent*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // string contractID = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ctx->extra_parse_data().SetFieldName("vega.EthereumEvent.contractID");
        object = msg->mutable_contractid();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParserUTF8;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheckUTF8(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      // string event = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ctx->extra_parse_data().SetFieldName("vega.EthereumEvent.event");
        object = msg->mutable_event();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParserUTF8;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheckUTF8(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      // uint64 value = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 24) goto handle_unusual;
        msg->set_value(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
string_till_end:
  static_cast<::std::string*>(object)->clear();
  static_cast<::std::string*>(object)->reserve(size);
  goto len_delim_till_end;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool EthereumEvent::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vega.EthereumEvent)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // string contractID = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_contractid()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->contractid().data(), static_cast<int>(this->contractid().length()),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "vega.EthereumEvent.contractID"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // string event = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_event()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->event().data(), static_cast<int>(this->event().length()),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "vega.EthereumEvent.event"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // uint64 value = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (24 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &value_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vega.EthereumEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vega.EthereumEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void EthereumEvent::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vega.EthereumEvent)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // string contractID = 1;
  if (this->contractid().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->contractid().data(), static_cast<int>(this->contractid().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "vega.EthereumEvent.contractID");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->contractid(), output);
  }

  // string event = 2;
  if (this->event().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->event().data(), static_cast<int>(this->event().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "vega.EthereumEvent.event");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->event(), output);
  }

  // uint64 value = 3;
  if (this->value() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->value(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:vega.EthereumEvent)
}

::google::protobuf::uint8* EthereumEvent::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:vega.EthereumEvent)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // string contractID = 1;
  if (this->contractid().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->contractid().data(), static_cast<int>(this->contractid().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "vega.EthereumEvent.contractID");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->contractid(), target);
  }

  // string event = 2;
  if (this->event().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->event().data(), static_cast<int>(this->event().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "vega.EthereumEvent.event");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->event(), target);
  }

  // uint64 value = 3;
  if (this->value() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(3, this->value(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vega.EthereumEvent)
  return target;
}

size_t EthereumEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vega.EthereumEvent)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string contractID = 1;
  if (this->contractid().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->contractid());
  }

  // string event = 2;
  if (this->event().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->event());
  }

  // uint64 value = 3;
  if (this->value() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->value());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void EthereumEvent::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:vega.EthereumEvent)
  GOOGLE_DCHECK_NE(&from, this);
  const EthereumEvent* source =
      ::google::protobuf::DynamicCastToGenerated<EthereumEvent>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:vega.EthereumEvent)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:vega.EthereumEvent)
    MergeFrom(*source);
  }
}

void EthereumEvent::MergeFrom(const EthereumEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vega.EthereumEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.contractid().size() > 0) {

    contractid_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.contractid_);
  }
  if (from.event().size() > 0) {

    event_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.event_);
  }
  if (from.value() != 0) {
    set_value(from.value());
  }
}

void EthereumEvent::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:vega.EthereumEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EthereumEvent::CopyFrom(const EthereumEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vega.EthereumEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EthereumEvent::IsInitialized() const {
  return true;
}

void EthereumEvent::Swap(EthereumEvent* other) {
  if (other == this) return;
  InternalSwap(other);
}
void EthereumEvent::InternalSwap(EthereumEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  contractid_.Swap(&other->contractid_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  event_.Swap(&other->event_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(value_, other->value_);
}

::google::protobuf::Metadata EthereumEvent::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_proto_2fmarkets_2eproto);
  return ::file_level_metadata_proto_2fmarkets_2eproto[kIndexInFileMessages];
}


// ===================================================================

void InstrumentMetadata::InitAsDefaultInstance() {
}
class InstrumentMetadata::HasBitSetters {
 public:
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int InstrumentMetadata::kTagsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

InstrumentMetadata::InstrumentMetadata()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:vega.InstrumentMetadata)
}
InstrumentMetadata::InstrumentMetadata(const InstrumentMetadata& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      tags_(from.tags_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:vega.InstrumentMetadata)
}

void InstrumentMetadata::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_InstrumentMetadata_proto_2fmarkets_2eproto.base);
}

InstrumentMetadata::~InstrumentMetadata() {
  // @@protoc_insertion_point(destructor:vega.InstrumentMetadata)
  SharedDtor();
}

void InstrumentMetadata::SharedDtor() {
}

void InstrumentMetadata::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const InstrumentMetadata& InstrumentMetadata::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_InstrumentMetadata_proto_2fmarkets_2eproto.base);
  return *internal_default_instance();
}


void InstrumentMetadata::Clear() {
// @@protoc_insertion_point(message_clear_start:vega.InstrumentMetadata)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  tags_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* InstrumentMetadata::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<InstrumentMetadata*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // repeated string tags = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        do {
          ptr = ::google::protobuf::io::ReadSize(ptr, &size);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
          ctx->extra_parse_data().SetFieldName("vega.InstrumentMetadata.tags");
          object = msg->add_tags();
          if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
            parser_till_end = ::google::protobuf::internal::GreedyStringParserUTF8;
            goto string_till_end;
          }
          GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheckUTF8(ptr, size, ctx));
          ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
          ptr += size;
          if (ptr >= end) break;
        } while ((::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 10 && (ptr += 1));
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
string_till_end:
  static_cast<::std::string*>(object)->clear();
  static_cast<::std::string*>(object)->reserve(size);
  goto len_delim_till_end;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool InstrumentMetadata::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vega.InstrumentMetadata)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated string tags = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_tags()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->tags(this->tags_size() - 1).data(),
            static_cast<int>(this->tags(this->tags_size() - 1).length()),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "vega.InstrumentMetadata.tags"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vega.InstrumentMetadata)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vega.InstrumentMetadata)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void InstrumentMetadata::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vega.InstrumentMetadata)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated string tags = 1;
  for (int i = 0, n = this->tags_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->tags(i).data(), static_cast<int>(this->tags(i).length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "vega.InstrumentMetadata.tags");
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->tags(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:vega.InstrumentMetadata)
}

::google::protobuf::uint8* InstrumentMetadata::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:vega.InstrumentMetadata)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated string tags = 1;
  for (int i = 0, n = this->tags_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->tags(i).data(), static_cast<int>(this->tags(i).length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "vega.InstrumentMetadata.tags");
    target = ::google::protobuf::internal::WireFormatLite::
      WriteStringToArray(1, this->tags(i), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vega.InstrumentMetadata)
  return target;
}

size_t InstrumentMetadata::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vega.InstrumentMetadata)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string tags = 1;
  total_size += 1 *
      ::google::protobuf::internal::FromIntSize(this->tags_size());
  for (int i = 0, n = this->tags_size(); i < n; i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->tags(i));
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void InstrumentMetadata::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:vega.InstrumentMetadata)
  GOOGLE_DCHECK_NE(&from, this);
  const InstrumentMetadata* source =
      ::google::protobuf::DynamicCastToGenerated<InstrumentMetadata>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:vega.InstrumentMetadata)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:vega.InstrumentMetadata)
    MergeFrom(*source);
  }
}

void InstrumentMetadata::MergeFrom(const InstrumentMetadata& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vega.InstrumentMetadata)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  tags_.MergeFrom(from.tags_);
}

void InstrumentMetadata::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:vega.InstrumentMetadata)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void InstrumentMetadata::CopyFrom(const InstrumentMetadata& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vega.InstrumentMetadata)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InstrumentMetadata::IsInitialized() const {
  return true;
}

void InstrumentMetadata::Swap(InstrumentMetadata* other) {
  if (other == this) return;
  InternalSwap(other);
}
void InstrumentMetadata::InternalSwap(InstrumentMetadata* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  tags_.InternalSwap(CastToBase(&other->tags_));
}

::google::protobuf::Metadata InstrumentMetadata::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_proto_2fmarkets_2eproto);
  return ::file_level_metadata_proto_2fmarkets_2eproto[kIndexInFileMessages];
}


// ===================================================================

void Instrument::InitAsDefaultInstance() {
  ::vega::_Instrument_default_instance_._instance.get_mutable()->metadata_ = const_cast< ::vega::InstrumentMetadata*>(
      ::vega::InstrumentMetadata::internal_default_instance());
  ::vega::_Instrument_default_instance_.future_ = const_cast< ::vega::Future*>(
      ::vega::Future::internal_default_instance());
}
class Instrument::HasBitSetters {
 public:
  static const ::vega::InstrumentMetadata& metadata(const Instrument* msg);
  static const ::vega::Future& future(const Instrument* msg);
};

const ::vega::InstrumentMetadata&
Instrument::HasBitSetters::metadata(const Instrument* msg) {
  return *msg->metadata_;
}
const ::vega::Future&
Instrument::HasBitSetters::future(const Instrument* msg) {
  return *msg->product_.future_;
}
void Instrument::set_allocated_future(::vega::Future* future) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  clear_product();
  if (future) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      future = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, future, submessage_arena);
    }
    set_has_future();
    product_.future_ = future;
  }
  // @@protoc_insertion_point(field_set_allocated:vega.Instrument.future)
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Instrument::kIdFieldNumber;
const int Instrument::kCodeFieldNumber;
const int Instrument::kNameFieldNumber;
const int Instrument::kBaseNameFieldNumber;
const int Instrument::kQuoteNameFieldNumber;
const int Instrument::kMetadataFieldNumber;
const int Instrument::kInitialMarkPriceFieldNumber;
const int Instrument::kFutureFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Instrument::Instrument()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:vega.Instrument)
}
Instrument::Instrument(const Instrument& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.id().size() > 0) {
    id_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.id_);
  }
  code_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.code().size() > 0) {
    code_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.code_);
  }
  name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.name().size() > 0) {
    name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
  }
  basename_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.basename().size() > 0) {
    basename_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.basename_);
  }
  quotename_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.quotename().size() > 0) {
    quotename_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.quotename_);
  }
  if (from.has_metadata()) {
    metadata_ = new ::vega::InstrumentMetadata(*from.metadata_);
  } else {
    metadata_ = nullptr;
  }
  initialmarkprice_ = from.initialmarkprice_;
  clear_has_product();
  switch (from.product_case()) {
    case kFuture: {
      mutable_future()->::vega::Future::MergeFrom(from.future());
      break;
    }
    case PRODUCT_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:vega.Instrument)
}

void Instrument::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_Instrument_proto_2fmarkets_2eproto.base);
  id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  code_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  basename_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  quotename_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(&metadata_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&initialmarkprice_) -
      reinterpret_cast<char*>(&metadata_)) + sizeof(initialmarkprice_));
  clear_has_product();
}

Instrument::~Instrument() {
  // @@protoc_insertion_point(destructor:vega.Instrument)
  SharedDtor();
}

void Instrument::SharedDtor() {
  id_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  code_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  basename_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  quotename_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete metadata_;
  if (has_product()) {
    clear_product();
  }
}

void Instrument::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Instrument& Instrument::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_Instrument_proto_2fmarkets_2eproto.base);
  return *internal_default_instance();
}


void Instrument::clear_product() {
// @@protoc_insertion_point(one_of_clear_start:vega.Instrument)
  switch (product_case()) {
    case kFuture: {
      delete product_.future_;
      break;
    }
    case PRODUCT_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = PRODUCT_NOT_SET;
}


void Instrument::Clear() {
// @@protoc_insertion_point(message_clear_start:vega.Instrument)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  code_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  basename_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  quotename_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (GetArenaNoVirtual() == nullptr && metadata_ != nullptr) {
    delete metadata_;
  }
  metadata_ = nullptr;
  initialmarkprice_ = PROTOBUF_ULONGLONG(0);
  clear_product();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Instrument::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<Instrument*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // string id = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ctx->extra_parse_data().SetFieldName("vega.Instrument.id");
        object = msg->mutable_id();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParserUTF8;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheckUTF8(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      // string code = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ctx->extra_parse_data().SetFieldName("vega.Instrument.code");
        object = msg->mutable_code();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParserUTF8;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheckUTF8(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      // string name = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 26) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ctx->extra_parse_data().SetFieldName("vega.Instrument.name");
        object = msg->mutable_name();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParserUTF8;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheckUTF8(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      // string baseName = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 34) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ctx->extra_parse_data().SetFieldName("vega.Instrument.baseName");
        object = msg->mutable_basename();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParserUTF8;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheckUTF8(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      // string quoteName = 5;
      case 5: {
        if (static_cast<::google::protobuf::uint8>(tag) != 42) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ctx->extra_parse_data().SetFieldName("vega.Instrument.quoteName");
        object = msg->mutable_quotename();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParserUTF8;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheckUTF8(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      // .vega.InstrumentMetadata metadata = 6;
      case 6: {
        if (static_cast<::google::protobuf::uint8>(tag) != 50) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::vega::InstrumentMetadata::_InternalParse;
        object = msg->mutable_metadata();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // uint64 initialMarkPrice = 7;
      case 7: {
        if (static_cast<::google::protobuf::uint8>(tag) != 56) goto handle_unusual;
        msg->set_initialmarkprice(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // .vega.Future future = 100;
      case 100: {
        if (static_cast<::google::protobuf::uint8>(tag) != 34) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::vega::Future::_InternalParse;
        object = msg->mutable_future();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
string_till_end:
  static_cast<::std::string*>(object)->clear();
  static_cast<::std::string*>(object)->reserve(size);
  goto len_delim_till_end;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Instrument::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vega.Instrument)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(16383u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // string id = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_id()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->id().data(), static_cast<int>(this->id().length()),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "vega.Instrument.id"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // string code = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_code()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->code().data(), static_cast<int>(this->code().length()),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "vega.Instrument.code"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // string name = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (26 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->name().data(), static_cast<int>(this->name().length()),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "vega.Instrument.name"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // string baseName = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (34 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_basename()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->basename().data(), static_cast<int>(this->basename().length()),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "vega.Instrument.baseName"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // string quoteName = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (42 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_quotename()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->quotename().data(), static_cast<int>(this->quotename().length()),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "vega.Instrument.quoteName"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .vega.InstrumentMetadata metadata = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (50 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_metadata()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // uint64 initialMarkPrice = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (56 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &initialmarkprice_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .vega.Future future = 100;
      case 100: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (802 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_future()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vega.Instrument)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vega.Instrument)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Instrument::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vega.Instrument)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // string id = 1;
  if (this->id().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->id().data(), static_cast<int>(this->id().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "vega.Instrument.id");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->id(), output);
  }

  // string code = 2;
  if (this->code().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->code().data(), static_cast<int>(this->code().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "vega.Instrument.code");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->code(), output);
  }

  // string name = 3;
  if (this->name().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->name().data(), static_cast<int>(this->name().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "vega.Instrument.name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->name(), output);
  }

  // string baseName = 4;
  if (this->basename().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->basename().data(), static_cast<int>(this->basename().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "vega.Instrument.baseName");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->basename(), output);
  }

  // string quoteName = 5;
  if (this->quotename().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->quotename().data(), static_cast<int>(this->quotename().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "vega.Instrument.quoteName");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      5, this->quotename(), output);
  }

  // .vega.InstrumentMetadata metadata = 6;
  if (this->has_metadata()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, HasBitSetters::metadata(this), output);
  }

  // uint64 initialMarkPrice = 7;
  if (this->initialmarkprice() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(7, this->initialmarkprice(), output);
  }

  // .vega.Future future = 100;
  if (has_future()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      100, HasBitSetters::future(this), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:vega.Instrument)
}

::google::protobuf::uint8* Instrument::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:vega.Instrument)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // string id = 1;
  if (this->id().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->id().data(), static_cast<int>(this->id().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "vega.Instrument.id");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->id(), target);
  }

  // string code = 2;
  if (this->code().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->code().data(), static_cast<int>(this->code().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "vega.Instrument.code");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->code(), target);
  }

  // string name = 3;
  if (this->name().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->name().data(), static_cast<int>(this->name().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "vega.Instrument.name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->name(), target);
  }

  // string baseName = 4;
  if (this->basename().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->basename().data(), static_cast<int>(this->basename().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "vega.Instrument.baseName");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->basename(), target);
  }

  // string quoteName = 5;
  if (this->quotename().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->quotename().data(), static_cast<int>(this->quotename().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "vega.Instrument.quoteName");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        5, this->quotename(), target);
  }

  // .vega.InstrumentMetadata metadata = 6;
  if (this->has_metadata()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        6, HasBitSetters::metadata(this), target);
  }

  // uint64 initialMarkPrice = 7;
  if (this->initialmarkprice() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(7, this->initialmarkprice(), target);
  }

  // .vega.Future future = 100;
  if (has_future()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        100, HasBitSetters::future(this), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vega.Instrument)
  return target;
}

size_t Instrument::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vega.Instrument)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string id = 1;
  if (this->id().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->id());
  }

  // string code = 2;
  if (this->code().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->code());
  }

  // string name = 3;
  if (this->name().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->name());
  }

  // string baseName = 4;
  if (this->basename().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->basename());
  }

  // string quoteName = 5;
  if (this->quotename().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->quotename());
  }

  // .vega.InstrumentMetadata metadata = 6;
  if (this->has_metadata()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *metadata_);
  }

  // uint64 initialMarkPrice = 7;
  if (this->initialmarkprice() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->initialmarkprice());
  }

  switch (product_case()) {
    // .vega.Future future = 100;
    case kFuture: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *product_.future_);
      break;
    }
    case PRODUCT_NOT_SET: {
      break;
    }
  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Instrument::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:vega.Instrument)
  GOOGLE_DCHECK_NE(&from, this);
  const Instrument* source =
      ::google::protobuf::DynamicCastToGenerated<Instrument>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:vega.Instrument)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:vega.Instrument)
    MergeFrom(*source);
  }
}

void Instrument::MergeFrom(const Instrument& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vega.Instrument)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.id().size() > 0) {

    id_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.id_);
  }
  if (from.code().size() > 0) {

    code_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.code_);
  }
  if (from.name().size() > 0) {

    name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
  }
  if (from.basename().size() > 0) {

    basename_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.basename_);
  }
  if (from.quotename().size() > 0) {

    quotename_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.quotename_);
  }
  if (from.has_metadata()) {
    mutable_metadata()->::vega::InstrumentMetadata::MergeFrom(from.metadata());
  }
  if (from.initialmarkprice() != 0) {
    set_initialmarkprice(from.initialmarkprice());
  }
  switch (from.product_case()) {
    case kFuture: {
      mutable_future()->::vega::Future::MergeFrom(from.future());
      break;
    }
    case PRODUCT_NOT_SET: {
      break;
    }
  }
}

void Instrument::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:vega.Instrument)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Instrument::CopyFrom(const Instrument& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vega.Instrument)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Instrument::IsInitialized() const {
  return true;
}

void Instrument::Swap(Instrument* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Instrument::InternalSwap(Instrument* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  id_.Swap(&other->id_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  code_.Swap(&other->code_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  name_.Swap(&other->name_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  basename_.Swap(&other->basename_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  quotename_.Swap(&other->quotename_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(metadata_, other->metadata_);
  swap(initialmarkprice_, other->initialmarkprice_);
  swap(product_, other->product_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

::google::protobuf::Metadata Instrument::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_proto_2fmarkets_2eproto);
  return ::file_level_metadata_proto_2fmarkets_2eproto[kIndexInFileMessages];
}


// ===================================================================

void LogNormalRiskModel::InitAsDefaultInstance() {
  ::vega::_LogNormalRiskModel_default_instance_._instance.get_mutable()->params_ = const_cast< ::vega::LogNormalModelParams*>(
      ::vega::LogNormalModelParams::internal_default_instance());
}
class LogNormalRiskModel::HasBitSetters {
 public:
  static const ::vega::LogNormalModelParams& params(const LogNormalRiskModel* msg);
};

const ::vega::LogNormalModelParams&
LogNormalRiskModel::HasBitSetters::params(const LogNormalRiskModel* msg) {
  return *msg->params_;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int LogNormalRiskModel::kRiskAversionParameterFieldNumber;
const int LogNormalRiskModel::kTauFieldNumber;
const int LogNormalRiskModel::kParamsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

LogNormalRiskModel::LogNormalRiskModel()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:vega.LogNormalRiskModel)
}
LogNormalRiskModel::LogNormalRiskModel(const LogNormalRiskModel& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_params()) {
    params_ = new ::vega::LogNormalModelParams(*from.params_);
  } else {
    params_ = nullptr;
  }
  ::memcpy(&riskaversionparameter_, &from.riskaversionparameter_,
    static_cast<size_t>(reinterpret_cast<char*>(&tau_) -
    reinterpret_cast<char*>(&riskaversionparameter_)) + sizeof(tau_));
  // @@protoc_insertion_point(copy_constructor:vega.LogNormalRiskModel)
}

void LogNormalRiskModel::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_LogNormalRiskModel_proto_2fmarkets_2eproto.base);
  ::memset(&params_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&tau_) -
      reinterpret_cast<char*>(&params_)) + sizeof(tau_));
}

LogNormalRiskModel::~LogNormalRiskModel() {
  // @@protoc_insertion_point(destructor:vega.LogNormalRiskModel)
  SharedDtor();
}

void LogNormalRiskModel::SharedDtor() {
  if (this != internal_default_instance()) delete params_;
}

void LogNormalRiskModel::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const LogNormalRiskModel& LogNormalRiskModel::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_LogNormalRiskModel_proto_2fmarkets_2eproto.base);
  return *internal_default_instance();
}


void LogNormalRiskModel::Clear() {
// @@protoc_insertion_point(message_clear_start:vega.LogNormalRiskModel)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaNoVirtual() == nullptr && params_ != nullptr) {
    delete params_;
  }
  params_ = nullptr;
  ::memset(&riskaversionparameter_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&tau_) -
      reinterpret_cast<char*>(&riskaversionparameter_)) + sizeof(tau_));
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* LogNormalRiskModel::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<LogNormalRiskModel*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // double riskAversionParameter = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 9) goto handle_unusual;
        msg->set_riskaversionparameter(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // double tau = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 17) goto handle_unusual;
        msg->set_tau(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // .vega.LogNormalModelParams params = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 26) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::vega::LogNormalModelParams::_InternalParse;
        object = msg->mutable_params();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool LogNormalRiskModel::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vega.LogNormalRiskModel)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // double riskAversionParameter = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (9 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &riskaversionparameter_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // double tau = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (17 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &tau_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .vega.LogNormalModelParams params = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (26 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_params()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vega.LogNormalRiskModel)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vega.LogNormalRiskModel)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void LogNormalRiskModel::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vega.LogNormalRiskModel)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // double riskAversionParameter = 1;
  if (this->riskaversionparameter() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->riskaversionparameter(), output);
  }

  // double tau = 2;
  if (this->tau() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->tau(), output);
  }

  // .vega.LogNormalModelParams params = 3;
  if (this->has_params()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, HasBitSetters::params(this), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:vega.LogNormalRiskModel)
}

::google::protobuf::uint8* LogNormalRiskModel::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:vega.LogNormalRiskModel)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // double riskAversionParameter = 1;
  if (this->riskaversionparameter() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(1, this->riskaversionparameter(), target);
  }

  // double tau = 2;
  if (this->tau() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->tau(), target);
  }

  // .vega.LogNormalModelParams params = 3;
  if (this->has_params()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        3, HasBitSetters::params(this), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vega.LogNormalRiskModel)
  return target;
}

size_t LogNormalRiskModel::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vega.LogNormalRiskModel)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .vega.LogNormalModelParams params = 3;
  if (this->has_params()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *params_);
  }

  // double riskAversionParameter = 1;
  if (this->riskaversionparameter() != 0) {
    total_size += 1 + 8;
  }

  // double tau = 2;
  if (this->tau() != 0) {
    total_size += 1 + 8;
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void LogNormalRiskModel::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:vega.LogNormalRiskModel)
  GOOGLE_DCHECK_NE(&from, this);
  const LogNormalRiskModel* source =
      ::google::protobuf::DynamicCastToGenerated<LogNormalRiskModel>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:vega.LogNormalRiskModel)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:vega.LogNormalRiskModel)
    MergeFrom(*source);
  }
}

void LogNormalRiskModel::MergeFrom(const LogNormalRiskModel& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vega.LogNormalRiskModel)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_params()) {
    mutable_params()->::vega::LogNormalModelParams::MergeFrom(from.params());
  }
  if (from.riskaversionparameter() != 0) {
    set_riskaversionparameter(from.riskaversionparameter());
  }
  if (from.tau() != 0) {
    set_tau(from.tau());
  }
}

void LogNormalRiskModel::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:vega.LogNormalRiskModel)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void LogNormalRiskModel::CopyFrom(const LogNormalRiskModel& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vega.LogNormalRiskModel)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LogNormalRiskModel::IsInitialized() const {
  return true;
}

void LogNormalRiskModel::Swap(LogNormalRiskModel* other) {
  if (other == this) return;
  InternalSwap(other);
}
void LogNormalRiskModel::InternalSwap(LogNormalRiskModel* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(params_, other->params_);
  swap(riskaversionparameter_, other->riskaversionparameter_);
  swap(tau_, other->tau_);
}

::google::protobuf::Metadata LogNormalRiskModel::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_proto_2fmarkets_2eproto);
  return ::file_level_metadata_proto_2fmarkets_2eproto[kIndexInFileMessages];
}


// ===================================================================

void LogNormalModelParams::InitAsDefaultInstance() {
}
class LogNormalModelParams::HasBitSetters {
 public:
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int LogNormalModelParams::kMuFieldNumber;
const int LogNormalModelParams::kRFieldNumber;
const int LogNormalModelParams::kSigmaFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

LogNormalModelParams::LogNormalModelParams()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:vega.LogNormalModelParams)
}
LogNormalModelParams::LogNormalModelParams(const LogNormalModelParams& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&mu_, &from.mu_,
    static_cast<size_t>(reinterpret_cast<char*>(&sigma_) -
    reinterpret_cast<char*>(&mu_)) + sizeof(sigma_));
  // @@protoc_insertion_point(copy_constructor:vega.LogNormalModelParams)
}

void LogNormalModelParams::SharedCtor() {
  ::memset(&mu_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&sigma_) -
      reinterpret_cast<char*>(&mu_)) + sizeof(sigma_));
}

LogNormalModelParams::~LogNormalModelParams() {
  // @@protoc_insertion_point(destructor:vega.LogNormalModelParams)
  SharedDtor();
}

void LogNormalModelParams::SharedDtor() {
}

void LogNormalModelParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const LogNormalModelParams& LogNormalModelParams::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_LogNormalModelParams_proto_2fmarkets_2eproto.base);
  return *internal_default_instance();
}


void LogNormalModelParams::Clear() {
// @@protoc_insertion_point(message_clear_start:vega.LogNormalModelParams)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&mu_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&sigma_) -
      reinterpret_cast<char*>(&mu_)) + sizeof(sigma_));
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* LogNormalModelParams::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<LogNormalModelParams*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // double mu = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 9) goto handle_unusual;
        msg->set_mu(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // double r = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 17) goto handle_unusual;
        msg->set_r(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // double sigma = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 25) goto handle_unusual;
        msg->set_sigma(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool LogNormalModelParams::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vega.LogNormalModelParams)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // double mu = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (9 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &mu_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // double r = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (17 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &r_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // double sigma = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (25 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &sigma_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vega.LogNormalModelParams)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vega.LogNormalModelParams)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void LogNormalModelParams::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vega.LogNormalModelParams)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // double mu = 1;
  if (this->mu() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->mu(), output);
  }

  // double r = 2;
  if (this->r() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->r(), output);
  }

  // double sigma = 3;
  if (this->sigma() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->sigma(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:vega.LogNormalModelParams)
}

::google::protobuf::uint8* LogNormalModelParams::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:vega.LogNormalModelParams)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // double mu = 1;
  if (this->mu() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(1, this->mu(), target);
  }

  // double r = 2;
  if (this->r() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->r(), target);
  }

  // double sigma = 3;
  if (this->sigma() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->sigma(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vega.LogNormalModelParams)
  return target;
}

size_t LogNormalModelParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vega.LogNormalModelParams)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // double mu = 1;
  if (this->mu() != 0) {
    total_size += 1 + 8;
  }

  // double r = 2;
  if (this->r() != 0) {
    total_size += 1 + 8;
  }

  // double sigma = 3;
  if (this->sigma() != 0) {
    total_size += 1 + 8;
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void LogNormalModelParams::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:vega.LogNormalModelParams)
  GOOGLE_DCHECK_NE(&from, this);
  const LogNormalModelParams* source =
      ::google::protobuf::DynamicCastToGenerated<LogNormalModelParams>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:vega.LogNormalModelParams)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:vega.LogNormalModelParams)
    MergeFrom(*source);
  }
}

void LogNormalModelParams::MergeFrom(const LogNormalModelParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vega.LogNormalModelParams)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.mu() != 0) {
    set_mu(from.mu());
  }
  if (from.r() != 0) {
    set_r(from.r());
  }
  if (from.sigma() != 0) {
    set_sigma(from.sigma());
  }
}

void LogNormalModelParams::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:vega.LogNormalModelParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void LogNormalModelParams::CopyFrom(const LogNormalModelParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vega.LogNormalModelParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LogNormalModelParams::IsInitialized() const {
  return true;
}

void LogNormalModelParams::Swap(LogNormalModelParams* other) {
  if (other == this) return;
  InternalSwap(other);
}
void LogNormalModelParams::InternalSwap(LogNormalModelParams* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(mu_, other->mu_);
  swap(r_, other->r_);
  swap(sigma_, other->sigma_);
}

::google::protobuf::Metadata LogNormalModelParams::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_proto_2fmarkets_2eproto);
  return ::file_level_metadata_proto_2fmarkets_2eproto[kIndexInFileMessages];
}


// ===================================================================

void SimpleRiskModel::InitAsDefaultInstance() {
  ::vega::_SimpleRiskModel_default_instance_._instance.get_mutable()->params_ = const_cast< ::vega::SimpleModelParams*>(
      ::vega::SimpleModelParams::internal_default_instance());
}
class SimpleRiskModel::HasBitSetters {
 public:
  static const ::vega::SimpleModelParams& params(const SimpleRiskModel* msg);
};

const ::vega::SimpleModelParams&
SimpleRiskModel::HasBitSetters::params(const SimpleRiskModel* msg) {
  return *msg->params_;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int SimpleRiskModel::kParamsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

SimpleRiskModel::SimpleRiskModel()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:vega.SimpleRiskModel)
}
SimpleRiskModel::SimpleRiskModel(const SimpleRiskModel& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_params()) {
    params_ = new ::vega::SimpleModelParams(*from.params_);
  } else {
    params_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:vega.SimpleRiskModel)
}

void SimpleRiskModel::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_SimpleRiskModel_proto_2fmarkets_2eproto.base);
  params_ = nullptr;
}

SimpleRiskModel::~SimpleRiskModel() {
  // @@protoc_insertion_point(destructor:vega.SimpleRiskModel)
  SharedDtor();
}

void SimpleRiskModel::SharedDtor() {
  if (this != internal_default_instance()) delete params_;
}

void SimpleRiskModel::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const SimpleRiskModel& SimpleRiskModel::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_SimpleRiskModel_proto_2fmarkets_2eproto.base);
  return *internal_default_instance();
}


void SimpleRiskModel::Clear() {
// @@protoc_insertion_point(message_clear_start:vega.SimpleRiskModel)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaNoVirtual() == nullptr && params_ != nullptr) {
    delete params_;
  }
  params_ = nullptr;
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* SimpleRiskModel::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<SimpleRiskModel*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // .vega.SimpleModelParams params = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::vega::SimpleModelParams::_InternalParse;
        object = msg->mutable_params();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool SimpleRiskModel::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vega.SimpleRiskModel)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // .vega.SimpleModelParams params = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_params()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vega.SimpleRiskModel)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vega.SimpleRiskModel)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void SimpleRiskModel::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vega.SimpleRiskModel)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .vega.SimpleModelParams params = 1;
  if (this->has_params()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, HasBitSetters::params(this), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:vega.SimpleRiskModel)
}

::google::protobuf::uint8* SimpleRiskModel::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:vega.SimpleRiskModel)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .vega.SimpleModelParams params = 1;
  if (this->has_params()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, HasBitSetters::params(this), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vega.SimpleRiskModel)
  return target;
}

size_t SimpleRiskModel::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vega.SimpleRiskModel)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .vega.SimpleModelParams params = 1;
  if (this->has_params()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *params_);
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SimpleRiskModel::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:vega.SimpleRiskModel)
  GOOGLE_DCHECK_NE(&from, this);
  const SimpleRiskModel* source =
      ::google::protobuf::DynamicCastToGenerated<SimpleRiskModel>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:vega.SimpleRiskModel)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:vega.SimpleRiskModel)
    MergeFrom(*source);
  }
}

void SimpleRiskModel::MergeFrom(const SimpleRiskModel& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vega.SimpleRiskModel)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_params()) {
    mutable_params()->::vega::SimpleModelParams::MergeFrom(from.params());
  }
}

void SimpleRiskModel::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:vega.SimpleRiskModel)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SimpleRiskModel::CopyFrom(const SimpleRiskModel& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vega.SimpleRiskModel)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SimpleRiskModel::IsInitialized() const {
  return true;
}

void SimpleRiskModel::Swap(SimpleRiskModel* other) {
  if (other == this) return;
  InternalSwap(other);
}
void SimpleRiskModel::InternalSwap(SimpleRiskModel* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(params_, other->params_);
}

::google::protobuf::Metadata SimpleRiskModel::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_proto_2fmarkets_2eproto);
  return ::file_level_metadata_proto_2fmarkets_2eproto[kIndexInFileMessages];
}


// ===================================================================

void SimpleModelParams::InitAsDefaultInstance() {
}
class SimpleModelParams::HasBitSetters {
 public:
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int SimpleModelParams::kFactorLongFieldNumber;
const int SimpleModelParams::kFactorShortFieldNumber;
const int SimpleModelParams::kMaxMoveUpFieldNumber;
const int SimpleModelParams::kMinMoveDownFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

SimpleModelParams::SimpleModelParams()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:vega.SimpleModelParams)
}
SimpleModelParams::SimpleModelParams(const SimpleModelParams& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&factorlong_, &from.factorlong_,
    static_cast<size_t>(reinterpret_cast<char*>(&minmovedown_) -
    reinterpret_cast<char*>(&factorlong_)) + sizeof(minmovedown_));
  // @@protoc_insertion_point(copy_constructor:vega.SimpleModelParams)
}

void SimpleModelParams::SharedCtor() {
  ::memset(&factorlong_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&minmovedown_) -
      reinterpret_cast<char*>(&factorlong_)) + sizeof(minmovedown_));
}

SimpleModelParams::~SimpleModelParams() {
  // @@protoc_insertion_point(destructor:vega.SimpleModelParams)
  SharedDtor();
}

void SimpleModelParams::SharedDtor() {
}

void SimpleModelParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const SimpleModelParams& SimpleModelParams::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_SimpleModelParams_proto_2fmarkets_2eproto.base);
  return *internal_default_instance();
}


void SimpleModelParams::Clear() {
// @@protoc_insertion_point(message_clear_start:vega.SimpleModelParams)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&factorlong_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&minmovedown_) -
      reinterpret_cast<char*>(&factorlong_)) + sizeof(minmovedown_));
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* SimpleModelParams::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<SimpleModelParams*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // double factorLong = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 9) goto handle_unusual;
        msg->set_factorlong(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // double factorShort = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 17) goto handle_unusual;
        msg->set_factorshort(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // double maxMoveUp = 3 [(.validator.field) = {
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 25) goto handle_unusual;
        msg->set_maxmoveup(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // double minMoveDown = 4 [(.validator.field) = {
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 33) goto handle_unusual;
        msg->set_minmovedown(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool SimpleModelParams::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vega.SimpleModelParams)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // double factorLong = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (9 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &factorlong_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // double factorShort = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (17 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &factorshort_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // double maxMoveUp = 3 [(.validator.field) = {
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (25 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &maxmoveup_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // double minMoveDown = 4 [(.validator.field) = {
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (33 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &minmovedown_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vega.SimpleModelParams)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vega.SimpleModelParams)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void SimpleModelParams::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vega.SimpleModelParams)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // double factorLong = 1;
  if (this->factorlong() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->factorlong(), output);
  }

  // double factorShort = 2;
  if (this->factorshort() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->factorshort(), output);
  }

  // double maxMoveUp = 3 [(.validator.field) = {
  if (this->maxmoveup() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->maxmoveup(), output);
  }

  // double minMoveDown = 4 [(.validator.field) = {
  if (this->minmovedown() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(4, this->minmovedown(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:vega.SimpleModelParams)
}

::google::protobuf::uint8* SimpleModelParams::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:vega.SimpleModelParams)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // double factorLong = 1;
  if (this->factorlong() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(1, this->factorlong(), target);
  }

  // double factorShort = 2;
  if (this->factorshort() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->factorshort(), target);
  }

  // double maxMoveUp = 3 [(.validator.field) = {
  if (this->maxmoveup() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->maxmoveup(), target);
  }

  // double minMoveDown = 4 [(.validator.field) = {
  if (this->minmovedown() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(4, this->minmovedown(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vega.SimpleModelParams)
  return target;
}

size_t SimpleModelParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vega.SimpleModelParams)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // double factorLong = 1;
  if (this->factorlong() != 0) {
    total_size += 1 + 8;
  }

  // double factorShort = 2;
  if (this->factorshort() != 0) {
    total_size += 1 + 8;
  }

  // double maxMoveUp = 3 [(.validator.field) = {
  if (this->maxmoveup() != 0) {
    total_size += 1 + 8;
  }

  // double minMoveDown = 4 [(.validator.field) = {
  if (this->minmovedown() != 0) {
    total_size += 1 + 8;
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SimpleModelParams::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:vega.SimpleModelParams)
  GOOGLE_DCHECK_NE(&from, this);
  const SimpleModelParams* source =
      ::google::protobuf::DynamicCastToGenerated<SimpleModelParams>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:vega.SimpleModelParams)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:vega.SimpleModelParams)
    MergeFrom(*source);
  }
}

void SimpleModelParams::MergeFrom(const SimpleModelParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vega.SimpleModelParams)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.factorlong() != 0) {
    set_factorlong(from.factorlong());
  }
  if (from.factorshort() != 0) {
    set_factorshort(from.factorshort());
  }
  if (from.maxmoveup() != 0) {
    set_maxmoveup(from.maxmoveup());
  }
  if (from.minmovedown() != 0) {
    set_minmovedown(from.minmovedown());
  }
}

void SimpleModelParams::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:vega.SimpleModelParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SimpleModelParams::CopyFrom(const SimpleModelParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vega.SimpleModelParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SimpleModelParams::IsInitialized() const {
  return true;
}

void SimpleModelParams::Swap(SimpleModelParams* other) {
  if (other == this) return;
  InternalSwap(other);
}
void SimpleModelParams::InternalSwap(SimpleModelParams* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(factorlong_, other->factorlong_);
  swap(factorshort_, other->factorshort_);
  swap(maxmoveup_, other->maxmoveup_);
  swap(minmovedown_, other->minmovedown_);
}

::google::protobuf::Metadata SimpleModelParams::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_proto_2fmarkets_2eproto);
  return ::file_level_metadata_proto_2fmarkets_2eproto[kIndexInFileMessages];
}


// ===================================================================

void ScalingFactors::InitAsDefaultInstance() {
}
class ScalingFactors::HasBitSetters {
 public:
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ScalingFactors::kSearchLevelFieldNumber;
const int ScalingFactors::kInitialMarginFieldNumber;
const int ScalingFactors::kCollateralReleaseFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ScalingFactors::ScalingFactors()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:vega.ScalingFactors)
}
ScalingFactors::ScalingFactors(const ScalingFactors& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&searchlevel_, &from.searchlevel_,
    static_cast<size_t>(reinterpret_cast<char*>(&collateralrelease_) -
    reinterpret_cast<char*>(&searchlevel_)) + sizeof(collateralrelease_));
  // @@protoc_insertion_point(copy_constructor:vega.ScalingFactors)
}

void ScalingFactors::SharedCtor() {
  ::memset(&searchlevel_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&collateralrelease_) -
      reinterpret_cast<char*>(&searchlevel_)) + sizeof(collateralrelease_));
}

ScalingFactors::~ScalingFactors() {
  // @@protoc_insertion_point(destructor:vega.ScalingFactors)
  SharedDtor();
}

void ScalingFactors::SharedDtor() {
}

void ScalingFactors::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ScalingFactors& ScalingFactors::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_ScalingFactors_proto_2fmarkets_2eproto.base);
  return *internal_default_instance();
}


void ScalingFactors::Clear() {
// @@protoc_insertion_point(message_clear_start:vega.ScalingFactors)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&searchlevel_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&collateralrelease_) -
      reinterpret_cast<char*>(&searchlevel_)) + sizeof(collateralrelease_));
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* ScalingFactors::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<ScalingFactors*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // double searchLevel = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 9) goto handle_unusual;
        msg->set_searchlevel(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // double initialMargin = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 17) goto handle_unusual;
        msg->set_initialmargin(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // double collateralRelease = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 25) goto handle_unusual;
        msg->set_collateralrelease(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool ScalingFactors::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vega.ScalingFactors)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // double searchLevel = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (9 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &searchlevel_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // double initialMargin = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (17 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &initialmargin_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // double collateralRelease = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (25 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &collateralrelease_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vega.ScalingFactors)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vega.ScalingFactors)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void ScalingFactors::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vega.ScalingFactors)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // double searchLevel = 1;
  if (this->searchlevel() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->searchlevel(), output);
  }

  // double initialMargin = 2;
  if (this->initialmargin() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->initialmargin(), output);
  }

  // double collateralRelease = 3;
  if (this->collateralrelease() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->collateralrelease(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:vega.ScalingFactors)
}

::google::protobuf::uint8* ScalingFactors::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:vega.ScalingFactors)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // double searchLevel = 1;
  if (this->searchlevel() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(1, this->searchlevel(), target);
  }

  // double initialMargin = 2;
  if (this->initialmargin() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->initialmargin(), target);
  }

  // double collateralRelease = 3;
  if (this->collateralrelease() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->collateralrelease(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vega.ScalingFactors)
  return target;
}

size_t ScalingFactors::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vega.ScalingFactors)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // double searchLevel = 1;
  if (this->searchlevel() != 0) {
    total_size += 1 + 8;
  }

  // double initialMargin = 2;
  if (this->initialmargin() != 0) {
    total_size += 1 + 8;
  }

  // double collateralRelease = 3;
  if (this->collateralrelease() != 0) {
    total_size += 1 + 8;
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ScalingFactors::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:vega.ScalingFactors)
  GOOGLE_DCHECK_NE(&from, this);
  const ScalingFactors* source =
      ::google::protobuf::DynamicCastToGenerated<ScalingFactors>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:vega.ScalingFactors)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:vega.ScalingFactors)
    MergeFrom(*source);
  }
}

void ScalingFactors::MergeFrom(const ScalingFactors& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vega.ScalingFactors)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.searchlevel() != 0) {
    set_searchlevel(from.searchlevel());
  }
  if (from.initialmargin() != 0) {
    set_initialmargin(from.initialmargin());
  }
  if (from.collateralrelease() != 0) {
    set_collateralrelease(from.collateralrelease());
  }
}

void ScalingFactors::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:vega.ScalingFactors)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ScalingFactors::CopyFrom(const ScalingFactors& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vega.ScalingFactors)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ScalingFactors::IsInitialized() const {
  return true;
}

void ScalingFactors::Swap(ScalingFactors* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ScalingFactors::InternalSwap(ScalingFactors* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(searchlevel_, other->searchlevel_);
  swap(initialmargin_, other->initialmargin_);
  swap(collateralrelease_, other->collateralrelease_);
}

::google::protobuf::Metadata ScalingFactors::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_proto_2fmarkets_2eproto);
  return ::file_level_metadata_proto_2fmarkets_2eproto[kIndexInFileMessages];
}


// ===================================================================

void MarginCalculator::InitAsDefaultInstance() {
  ::vega::_MarginCalculator_default_instance_._instance.get_mutable()->scalingfactors_ = const_cast< ::vega::ScalingFactors*>(
      ::vega::ScalingFactors::internal_default_instance());
}
class MarginCalculator::HasBitSetters {
 public:
  static const ::vega::ScalingFactors& scalingfactors(const MarginCalculator* msg);
};

const ::vega::ScalingFactors&
MarginCalculator::HasBitSetters::scalingfactors(const MarginCalculator* msg) {
  return *msg->scalingfactors_;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int MarginCalculator::kScalingFactorsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

MarginCalculator::MarginCalculator()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:vega.MarginCalculator)
}
MarginCalculator::MarginCalculator(const MarginCalculator& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_scalingfactors()) {
    scalingfactors_ = new ::vega::ScalingFactors(*from.scalingfactors_);
  } else {
    scalingfactors_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:vega.MarginCalculator)
}

void MarginCalculator::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_MarginCalculator_proto_2fmarkets_2eproto.base);
  scalingfactors_ = nullptr;
}

MarginCalculator::~MarginCalculator() {
  // @@protoc_insertion_point(destructor:vega.MarginCalculator)
  SharedDtor();
}

void MarginCalculator::SharedDtor() {
  if (this != internal_default_instance()) delete scalingfactors_;
}

void MarginCalculator::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const MarginCalculator& MarginCalculator::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_MarginCalculator_proto_2fmarkets_2eproto.base);
  return *internal_default_instance();
}


void MarginCalculator::Clear() {
// @@protoc_insertion_point(message_clear_start:vega.MarginCalculator)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaNoVirtual() == nullptr && scalingfactors_ != nullptr) {
    delete scalingfactors_;
  }
  scalingfactors_ = nullptr;
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* MarginCalculator::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<MarginCalculator*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // .vega.ScalingFactors scalingFactors = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::vega::ScalingFactors::_InternalParse;
        object = msg->mutable_scalingfactors();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool MarginCalculator::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vega.MarginCalculator)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // .vega.ScalingFactors scalingFactors = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_scalingfactors()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vega.MarginCalculator)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vega.MarginCalculator)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void MarginCalculator::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vega.MarginCalculator)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .vega.ScalingFactors scalingFactors = 1;
  if (this->has_scalingfactors()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, HasBitSetters::scalingfactors(this), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:vega.MarginCalculator)
}

::google::protobuf::uint8* MarginCalculator::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:vega.MarginCalculator)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .vega.ScalingFactors scalingFactors = 1;
  if (this->has_scalingfactors()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, HasBitSetters::scalingfactors(this), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vega.MarginCalculator)
  return target;
}

size_t MarginCalculator::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vega.MarginCalculator)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .vega.ScalingFactors scalingFactors = 1;
  if (this->has_scalingfactors()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *scalingfactors_);
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MarginCalculator::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:vega.MarginCalculator)
  GOOGLE_DCHECK_NE(&from, this);
  const MarginCalculator* source =
      ::google::protobuf::DynamicCastToGenerated<MarginCalculator>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:vega.MarginCalculator)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:vega.MarginCalculator)
    MergeFrom(*source);
  }
}

void MarginCalculator::MergeFrom(const MarginCalculator& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vega.MarginCalculator)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_scalingfactors()) {
    mutable_scalingfactors()->::vega::ScalingFactors::MergeFrom(from.scalingfactors());
  }
}

void MarginCalculator::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:vega.MarginCalculator)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MarginCalculator::CopyFrom(const MarginCalculator& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vega.MarginCalculator)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MarginCalculator::IsInitialized() const {
  return true;
}

void MarginCalculator::Swap(MarginCalculator* other) {
  if (other == this) return;
  InternalSwap(other);
}
void MarginCalculator::InternalSwap(MarginCalculator* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(scalingfactors_, other->scalingfactors_);
}

::google::protobuf::Metadata MarginCalculator::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_proto_2fmarkets_2eproto);
  return ::file_level_metadata_proto_2fmarkets_2eproto[kIndexInFileMessages];
}


// ===================================================================

void TradableInstrument::InitAsDefaultInstance() {
  ::vega::_TradableInstrument_default_instance_._instance.get_mutable()->instrument_ = const_cast< ::vega::Instrument*>(
      ::vega::Instrument::internal_default_instance());
  ::vega::_TradableInstrument_default_instance_._instance.get_mutable()->margincalculator_ = const_cast< ::vega::MarginCalculator*>(
      ::vega::MarginCalculator::internal_default_instance());
  ::vega::_TradableInstrument_default_instance_.lognormalriskmodel_ = const_cast< ::vega::LogNormalRiskModel*>(
      ::vega::LogNormalRiskModel::internal_default_instance());
  ::vega::_TradableInstrument_default_instance_.simpleriskmodel_ = const_cast< ::vega::SimpleRiskModel*>(
      ::vega::SimpleRiskModel::internal_default_instance());
}
class TradableInstrument::HasBitSetters {
 public:
  static const ::vega::Instrument& instrument(const TradableInstrument* msg);
  static const ::vega::MarginCalculator& margincalculator(const TradableInstrument* msg);
  static const ::vega::LogNormalRiskModel& lognormalriskmodel(const TradableInstrument* msg);
  static const ::vega::SimpleRiskModel& simpleriskmodel(const TradableInstrument* msg);
};

const ::vega::Instrument&
TradableInstrument::HasBitSetters::instrument(const TradableInstrument* msg) {
  return *msg->instrument_;
}
const ::vega::MarginCalculator&
TradableInstrument::HasBitSetters::margincalculator(const TradableInstrument* msg) {
  return *msg->margincalculator_;
}
const ::vega::LogNormalRiskModel&
TradableInstrument::HasBitSetters::lognormalriskmodel(const TradableInstrument* msg) {
  return *msg->riskModel_.lognormalriskmodel_;
}
const ::vega::SimpleRiskModel&
TradableInstrument::HasBitSetters::simpleriskmodel(const TradableInstrument* msg) {
  return *msg->riskModel_.simpleriskmodel_;
}
void TradableInstrument::set_allocated_lognormalriskmodel(::vega::LogNormalRiskModel* lognormalriskmodel) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  clear_riskModel();
  if (lognormalriskmodel) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      lognormalriskmodel = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, lognormalriskmodel, submessage_arena);
    }
    set_has_lognormalriskmodel();
    riskModel_.lognormalriskmodel_ = lognormalriskmodel;
  }
  // @@protoc_insertion_point(field_set_allocated:vega.TradableInstrument.logNormalRiskModel)
}
void TradableInstrument::set_allocated_simpleriskmodel(::vega::SimpleRiskModel* simpleriskmodel) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  clear_riskModel();
  if (simpleriskmodel) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      simpleriskmodel = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, simpleriskmodel, submessage_arena);
    }
    set_has_simpleriskmodel();
    riskModel_.simpleriskmodel_ = simpleriskmodel;
  }
  // @@protoc_insertion_point(field_set_allocated:vega.TradableInstrument.simpleRiskModel)
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TradableInstrument::kInstrumentFieldNumber;
const int TradableInstrument::kMarginCalculatorFieldNumber;
const int TradableInstrument::kLogNormalRiskModelFieldNumber;
const int TradableInstrument::kSimpleRiskModelFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TradableInstrument::TradableInstrument()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:vega.TradableInstrument)
}
TradableInstrument::TradableInstrument(const TradableInstrument& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_instrument()) {
    instrument_ = new ::vega::Instrument(*from.instrument_);
  } else {
    instrument_ = nullptr;
  }
  if (from.has_margincalculator()) {
    margincalculator_ = new ::vega::MarginCalculator(*from.margincalculator_);
  } else {
    margincalculator_ = nullptr;
  }
  clear_has_riskModel();
  switch (from.riskModel_case()) {
    case kLogNormalRiskModel: {
      mutable_lognormalriskmodel()->::vega::LogNormalRiskModel::MergeFrom(from.lognormalriskmodel());
      break;
    }
    case kSimpleRiskModel: {
      mutable_simpleriskmodel()->::vega::SimpleRiskModel::MergeFrom(from.simpleriskmodel());
      break;
    }
    case RISKMODEL_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:vega.TradableInstrument)
}

void TradableInstrument::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_TradableInstrument_proto_2fmarkets_2eproto.base);
  ::memset(&instrument_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&margincalculator_) -
      reinterpret_cast<char*>(&instrument_)) + sizeof(margincalculator_));
  clear_has_riskModel();
}

TradableInstrument::~TradableInstrument() {
  // @@protoc_insertion_point(destructor:vega.TradableInstrument)
  SharedDtor();
}

void TradableInstrument::SharedDtor() {
  if (this != internal_default_instance()) delete instrument_;
  if (this != internal_default_instance()) delete margincalculator_;
  if (has_riskModel()) {
    clear_riskModel();
  }
}

void TradableInstrument::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TradableInstrument& TradableInstrument::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_TradableInstrument_proto_2fmarkets_2eproto.base);
  return *internal_default_instance();
}


void TradableInstrument::clear_riskModel() {
// @@protoc_insertion_point(one_of_clear_start:vega.TradableInstrument)
  switch (riskModel_case()) {
    case kLogNormalRiskModel: {
      delete riskModel_.lognormalriskmodel_;
      break;
    }
    case kSimpleRiskModel: {
      delete riskModel_.simpleriskmodel_;
      break;
    }
    case RISKMODEL_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = RISKMODEL_NOT_SET;
}


void TradableInstrument::Clear() {
// @@protoc_insertion_point(message_clear_start:vega.TradableInstrument)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaNoVirtual() == nullptr && instrument_ != nullptr) {
    delete instrument_;
  }
  instrument_ = nullptr;
  if (GetArenaNoVirtual() == nullptr && margincalculator_ != nullptr) {
    delete margincalculator_;
  }
  margincalculator_ = nullptr;
  clear_riskModel();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* TradableInstrument::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<TradableInstrument*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // .vega.Instrument instrument = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::vega::Instrument::_InternalParse;
        object = msg->mutable_instrument();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // .vega.MarginCalculator marginCalculator = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::vega::MarginCalculator::_InternalParse;
        object = msg->mutable_margincalculator();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // .vega.LogNormalRiskModel logNormalRiskModel = 100;
      case 100: {
        if (static_cast<::google::protobuf::uint8>(tag) != 34) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::vega::LogNormalRiskModel::_InternalParse;
        object = msg->mutable_lognormalriskmodel();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // .vega.SimpleRiskModel simpleRiskModel = 101;
      case 101: {
        if (static_cast<::google::protobuf::uint8>(tag) != 42) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::vega::SimpleRiskModel::_InternalParse;
        object = msg->mutable_simpleriskmodel();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool TradableInstrument::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vega.TradableInstrument)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(16383u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // .vega.Instrument instrument = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_instrument()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .vega.MarginCalculator marginCalculator = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_margincalculator()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .vega.LogNormalRiskModel logNormalRiskModel = 100;
      case 100: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (802 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_lognormalriskmodel()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .vega.SimpleRiskModel simpleRiskModel = 101;
      case 101: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (810 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_simpleriskmodel()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vega.TradableInstrument)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vega.TradableInstrument)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void TradableInstrument::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vega.TradableInstrument)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .vega.Instrument instrument = 1;
  if (this->has_instrument()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, HasBitSetters::instrument(this), output);
  }

  // .vega.MarginCalculator marginCalculator = 2;
  if (this->has_margincalculator()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, HasBitSetters::margincalculator(this), output);
  }

  // .vega.LogNormalRiskModel logNormalRiskModel = 100;
  if (has_lognormalriskmodel()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      100, HasBitSetters::lognormalriskmodel(this), output);
  }

  // .vega.SimpleRiskModel simpleRiskModel = 101;
  if (has_simpleriskmodel()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      101, HasBitSetters::simpleriskmodel(this), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:vega.TradableInstrument)
}

::google::protobuf::uint8* TradableInstrument::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:vega.TradableInstrument)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .vega.Instrument instrument = 1;
  if (this->has_instrument()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, HasBitSetters::instrument(this), target);
  }

  // .vega.MarginCalculator marginCalculator = 2;
  if (this->has_margincalculator()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, HasBitSetters::margincalculator(this), target);
  }

  // .vega.LogNormalRiskModel logNormalRiskModel = 100;
  if (has_lognormalriskmodel()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        100, HasBitSetters::lognormalriskmodel(this), target);
  }

  // .vega.SimpleRiskModel simpleRiskModel = 101;
  if (has_simpleriskmodel()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        101, HasBitSetters::simpleriskmodel(this), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vega.TradableInstrument)
  return target;
}

size_t TradableInstrument::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vega.TradableInstrument)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .vega.Instrument instrument = 1;
  if (this->has_instrument()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *instrument_);
  }

  // .vega.MarginCalculator marginCalculator = 2;
  if (this->has_margincalculator()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *margincalculator_);
  }

  switch (riskModel_case()) {
    // .vega.LogNormalRiskModel logNormalRiskModel = 100;
    case kLogNormalRiskModel: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *riskModel_.lognormalriskmodel_);
      break;
    }
    // .vega.SimpleRiskModel simpleRiskModel = 101;
    case kSimpleRiskModel: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *riskModel_.simpleriskmodel_);
      break;
    }
    case RISKMODEL_NOT_SET: {
      break;
    }
  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TradableInstrument::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:vega.TradableInstrument)
  GOOGLE_DCHECK_NE(&from, this);
  const TradableInstrument* source =
      ::google::protobuf::DynamicCastToGenerated<TradableInstrument>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:vega.TradableInstrument)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:vega.TradableInstrument)
    MergeFrom(*source);
  }
}

void TradableInstrument::MergeFrom(const TradableInstrument& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vega.TradableInstrument)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_instrument()) {
    mutable_instrument()->::vega::Instrument::MergeFrom(from.instrument());
  }
  if (from.has_margincalculator()) {
    mutable_margincalculator()->::vega::MarginCalculator::MergeFrom(from.margincalculator());
  }
  switch (from.riskModel_case()) {
    case kLogNormalRiskModel: {
      mutable_lognormalriskmodel()->::vega::LogNormalRiskModel::MergeFrom(from.lognormalriskmodel());
      break;
    }
    case kSimpleRiskModel: {
      mutable_simpleriskmodel()->::vega::SimpleRiskModel::MergeFrom(from.simpleriskmodel());
      break;
    }
    case RISKMODEL_NOT_SET: {
      break;
    }
  }
}

void TradableInstrument::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:vega.TradableInstrument)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TradableInstrument::CopyFrom(const TradableInstrument& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vega.TradableInstrument)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TradableInstrument::IsInitialized() const {
  return true;
}

void TradableInstrument::Swap(TradableInstrument* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TradableInstrument::InternalSwap(TradableInstrument* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(instrument_, other->instrument_);
  swap(margincalculator_, other->margincalculator_);
  swap(riskModel_, other->riskModel_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

::google::protobuf::Metadata TradableInstrument::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_proto_2fmarkets_2eproto);
  return ::file_level_metadata_proto_2fmarkets_2eproto[kIndexInFileMessages];
}


// ===================================================================

void FeeFactors::InitAsDefaultInstance() {
}
class FeeFactors::HasBitSetters {
 public:
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int FeeFactors::kMakerFeeFieldNumber;
const int FeeFactors::kInfrastructureFeeFieldNumber;
const int FeeFactors::kLiquidityFeeFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

FeeFactors::FeeFactors()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:vega.FeeFactors)
}
FeeFactors::FeeFactors(const FeeFactors& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  makerfee_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.makerfee().size() > 0) {
    makerfee_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.makerfee_);
  }
  infrastructurefee_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.infrastructurefee().size() > 0) {
    infrastructurefee_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.infrastructurefee_);
  }
  liquidityfee_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.liquidityfee().size() > 0) {
    liquidityfee_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.liquidityfee_);
  }
  // @@protoc_insertion_point(copy_constructor:vega.FeeFactors)
}

void FeeFactors::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_FeeFactors_proto_2fmarkets_2eproto.base);
  makerfee_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  infrastructurefee_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  liquidityfee_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

FeeFactors::~FeeFactors() {
  // @@protoc_insertion_point(destructor:vega.FeeFactors)
  SharedDtor();
}

void FeeFactors::SharedDtor() {
  makerfee_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  infrastructurefee_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  liquidityfee_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void FeeFactors::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const FeeFactors& FeeFactors::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_FeeFactors_proto_2fmarkets_2eproto.base);
  return *internal_default_instance();
}


void FeeFactors::Clear() {
// @@protoc_insertion_point(message_clear_start:vega.FeeFactors)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  makerfee_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  infrastructurefee_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  liquidityfee_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* FeeFactors::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<FeeFactors*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // string makerFee = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ctx->extra_parse_data().SetFieldName("vega.FeeFactors.makerFee");
        object = msg->mutable_makerfee();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParserUTF8;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheckUTF8(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      // string infrastructureFee = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ctx->extra_parse_data().SetFieldName("vega.FeeFactors.infrastructureFee");
        object = msg->mutable_infrastructurefee();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParserUTF8;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheckUTF8(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      // string liquidityFee = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 26) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ctx->extra_parse_data().SetFieldName("vega.FeeFactors.liquidityFee");
        object = msg->mutable_liquidityfee();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParserUTF8;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheckUTF8(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
string_till_end:
  static_cast<::std::string*>(object)->clear();
  static_cast<::std::string*>(object)->reserve(size);
  goto len_delim_till_end;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool FeeFactors::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vega.FeeFactors)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // string makerFee = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_makerfee()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->makerfee().data(), static_cast<int>(this->makerfee().length()),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "vega.FeeFactors.makerFee"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // string infrastructureFee = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_infrastructurefee()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->infrastructurefee().data(), static_cast<int>(this->infrastructurefee().length()),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "vega.FeeFactors.infrastructureFee"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // string liquidityFee = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (26 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_liquidityfee()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->liquidityfee().data(), static_cast<int>(this->liquidityfee().length()),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "vega.FeeFactors.liquidityFee"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vega.FeeFactors)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vega.FeeFactors)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void FeeFactors::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vega.FeeFactors)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // string makerFee = 1;
  if (this->makerfee().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->makerfee().data(), static_cast<int>(this->makerfee().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "vega.FeeFactors.makerFee");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->makerfee(), output);
  }

  // string infrastructureFee = 2;
  if (this->infrastructurefee().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->infrastructurefee().data(), static_cast<int>(this->infrastructurefee().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "vega.FeeFactors.infrastructureFee");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->infrastructurefee(), output);
  }

  // string liquidityFee = 3;
  if (this->liquidityfee().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->liquidityfee().data(), static_cast<int>(this->liquidityfee().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "vega.FeeFactors.liquidityFee");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->liquidityfee(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:vega.FeeFactors)
}

::google::protobuf::uint8* FeeFactors::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:vega.FeeFactors)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // string makerFee = 1;
  if (this->makerfee().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->makerfee().data(), static_cast<int>(this->makerfee().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "vega.FeeFactors.makerFee");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->makerfee(), target);
  }

  // string infrastructureFee = 2;
  if (this->infrastructurefee().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->infrastructurefee().data(), static_cast<int>(this->infrastructurefee().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "vega.FeeFactors.infrastructureFee");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->infrastructurefee(), target);
  }

  // string liquidityFee = 3;
  if (this->liquidityfee().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->liquidityfee().data(), static_cast<int>(this->liquidityfee().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "vega.FeeFactors.liquidityFee");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->liquidityfee(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vega.FeeFactors)
  return target;
}

size_t FeeFactors::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vega.FeeFactors)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string makerFee = 1;
  if (this->makerfee().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->makerfee());
  }

  // string infrastructureFee = 2;
  if (this->infrastructurefee().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->infrastructurefee());
  }

  // string liquidityFee = 3;
  if (this->liquidityfee().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->liquidityfee());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void FeeFactors::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:vega.FeeFactors)
  GOOGLE_DCHECK_NE(&from, this);
  const FeeFactors* source =
      ::google::protobuf::DynamicCastToGenerated<FeeFactors>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:vega.FeeFactors)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:vega.FeeFactors)
    MergeFrom(*source);
  }
}

void FeeFactors::MergeFrom(const FeeFactors& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vega.FeeFactors)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.makerfee().size() > 0) {

    makerfee_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.makerfee_);
  }
  if (from.infrastructurefee().size() > 0) {

    infrastructurefee_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.infrastructurefee_);
  }
  if (from.liquidityfee().size() > 0) {

    liquidityfee_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.liquidityfee_);
  }
}

void FeeFactors::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:vega.FeeFactors)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void FeeFactors::CopyFrom(const FeeFactors& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vega.FeeFactors)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FeeFactors::IsInitialized() const {
  return true;
}

void FeeFactors::Swap(FeeFactors* other) {
  if (other == this) return;
  InternalSwap(other);
}
void FeeFactors::InternalSwap(FeeFactors* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  makerfee_.Swap(&other->makerfee_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  infrastructurefee_.Swap(&other->infrastructurefee_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  liquidityfee_.Swap(&other->liquidityfee_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
}

::google::protobuf::Metadata FeeFactors::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_proto_2fmarkets_2eproto);
  return ::file_level_metadata_proto_2fmarkets_2eproto[kIndexInFileMessages];
}


// ===================================================================

void Fees::InitAsDefaultInstance() {
  ::vega::_Fees_default_instance_._instance.get_mutable()->factors_ = const_cast< ::vega::FeeFactors*>(
      ::vega::FeeFactors::internal_default_instance());
}
class Fees::HasBitSetters {
 public:
  static const ::vega::FeeFactors& factors(const Fees* msg);
};

const ::vega::FeeFactors&
Fees::HasBitSetters::factors(const Fees* msg) {
  return *msg->factors_;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Fees::kFactorsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Fees::Fees()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:vega.Fees)
}
Fees::Fees(const Fees& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_factors()) {
    factors_ = new ::vega::FeeFactors(*from.factors_);
  } else {
    factors_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:vega.Fees)
}

void Fees::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_Fees_proto_2fmarkets_2eproto.base);
  factors_ = nullptr;
}

Fees::~Fees() {
  // @@protoc_insertion_point(destructor:vega.Fees)
  SharedDtor();
}

void Fees::SharedDtor() {
  if (this != internal_default_instance()) delete factors_;
}

void Fees::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Fees& Fees::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_Fees_proto_2fmarkets_2eproto.base);
  return *internal_default_instance();
}


void Fees::Clear() {
// @@protoc_insertion_point(message_clear_start:vega.Fees)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaNoVirtual() == nullptr && factors_ != nullptr) {
    delete factors_;
  }
  factors_ = nullptr;
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Fees::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<Fees*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // .vega.FeeFactors factors = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::vega::FeeFactors::_InternalParse;
        object = msg->mutable_factors();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Fees::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vega.Fees)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // .vega.FeeFactors factors = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_factors()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vega.Fees)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vega.Fees)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Fees::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vega.Fees)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .vega.FeeFactors factors = 1;
  if (this->has_factors()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, HasBitSetters::factors(this), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:vega.Fees)
}

::google::protobuf::uint8* Fees::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:vega.Fees)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .vega.FeeFactors factors = 1;
  if (this->has_factors()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, HasBitSetters::factors(this), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vega.Fees)
  return target;
}

size_t Fees::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vega.Fees)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .vega.FeeFactors factors = 1;
  if (this->has_factors()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *factors_);
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Fees::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:vega.Fees)
  GOOGLE_DCHECK_NE(&from, this);
  const Fees* source =
      ::google::protobuf::DynamicCastToGenerated<Fees>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:vega.Fees)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:vega.Fees)
    MergeFrom(*source);
  }
}

void Fees::MergeFrom(const Fees& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vega.Fees)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_factors()) {
    mutable_factors()->::vega::FeeFactors::MergeFrom(from.factors());
  }
}

void Fees::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:vega.Fees)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Fees::CopyFrom(const Fees& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vega.Fees)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Fees::IsInitialized() const {
  return true;
}

void Fees::Swap(Fees* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Fees::InternalSwap(Fees* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(factors_, other->factors_);
}

::google::protobuf::Metadata Fees::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_proto_2fmarkets_2eproto);
  return ::file_level_metadata_proto_2fmarkets_2eproto[kIndexInFileMessages];
}


// ===================================================================

void PriceMonitoringParameters::InitAsDefaultInstance() {
}
class PriceMonitoringParameters::HasBitSetters {
 public:
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int PriceMonitoringParameters::kHorizonFieldNumber;
const int PriceMonitoringParameters::kProbabilityFieldNumber;
const int PriceMonitoringParameters::kAuctionExtensionFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

PriceMonitoringParameters::PriceMonitoringParameters()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:vega.PriceMonitoringParameters)
}
PriceMonitoringParameters::PriceMonitoringParameters(const PriceMonitoringParameters& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&horizon_, &from.horizon_,
    static_cast<size_t>(reinterpret_cast<char*>(&auctionextension_) -
    reinterpret_cast<char*>(&horizon_)) + sizeof(auctionextension_));
  // @@protoc_insertion_point(copy_constructor:vega.PriceMonitoringParameters)
}

void PriceMonitoringParameters::SharedCtor() {
  ::memset(&horizon_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&auctionextension_) -
      reinterpret_cast<char*>(&horizon_)) + sizeof(auctionextension_));
}

PriceMonitoringParameters::~PriceMonitoringParameters() {
  // @@protoc_insertion_point(destructor:vega.PriceMonitoringParameters)
  SharedDtor();
}

void PriceMonitoringParameters::SharedDtor() {
}

void PriceMonitoringParameters::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const PriceMonitoringParameters& PriceMonitoringParameters::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_PriceMonitoringParameters_proto_2fmarkets_2eproto.base);
  return *internal_default_instance();
}


void PriceMonitoringParameters::Clear() {
// @@protoc_insertion_point(message_clear_start:vega.PriceMonitoringParameters)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&horizon_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&auctionextension_) -
      reinterpret_cast<char*>(&horizon_)) + sizeof(auctionextension_));
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* PriceMonitoringParameters::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<PriceMonitoringParameters*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // int64 horizon = 1 [(.validator.field) = {
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        msg->set_horizon(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // double probability = 2 [(.validator.field) = {
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 17) goto handle_unusual;
        msg->set_probability(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // int64 auctionExtension = 3 [(.validator.field) = {
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 24) goto handle_unusual;
        msg->set_auctionextension(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool PriceMonitoringParameters::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vega.PriceMonitoringParameters)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // int64 horizon = 1 [(.validator.field) = {
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &horizon_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // double probability = 2 [(.validator.field) = {
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (17 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &probability_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // int64 auctionExtension = 3 [(.validator.field) = {
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (24 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &auctionextension_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vega.PriceMonitoringParameters)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vega.PriceMonitoringParameters)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void PriceMonitoringParameters::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vega.PriceMonitoringParameters)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // int64 horizon = 1 [(.validator.field) = {
  if (this->horizon() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->horizon(), output);
  }

  // double probability = 2 [(.validator.field) = {
  if (this->probability() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->probability(), output);
  }

  // int64 auctionExtension = 3 [(.validator.field) = {
  if (this->auctionextension() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(3, this->auctionextension(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:vega.PriceMonitoringParameters)
}

::google::protobuf::uint8* PriceMonitoringParameters::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:vega.PriceMonitoringParameters)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // int64 horizon = 1 [(.validator.field) = {
  if (this->horizon() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(1, this->horizon(), target);
  }

  // double probability = 2 [(.validator.field) = {
  if (this->probability() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->probability(), target);
  }

  // int64 auctionExtension = 3 [(.validator.field) = {
  if (this->auctionextension() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(3, this->auctionextension(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vega.PriceMonitoringParameters)
  return target;
}

size_t PriceMonitoringParameters::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vega.PriceMonitoringParameters)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int64 horizon = 1 [(.validator.field) = {
  if (this->horizon() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int64Size(
        this->horizon());
  }

  // double probability = 2 [(.validator.field) = {
  if (this->probability() != 0) {
    total_size += 1 + 8;
  }

  // int64 auctionExtension = 3 [(.validator.field) = {
  if (this->auctionextension() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int64Size(
        this->auctionextension());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PriceMonitoringParameters::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:vega.PriceMonitoringParameters)
  GOOGLE_DCHECK_NE(&from, this);
  const PriceMonitoringParameters* source =
      ::google::protobuf::DynamicCastToGenerated<PriceMonitoringParameters>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:vega.PriceMonitoringParameters)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:vega.PriceMonitoringParameters)
    MergeFrom(*source);
  }
}

void PriceMonitoringParameters::MergeFrom(const PriceMonitoringParameters& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vega.PriceMonitoringParameters)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.horizon() != 0) {
    set_horizon(from.horizon());
  }
  if (from.probability() != 0) {
    set_probability(from.probability());
  }
  if (from.auctionextension() != 0) {
    set_auctionextension(from.auctionextension());
  }
}

void PriceMonitoringParameters::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:vega.PriceMonitoringParameters)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PriceMonitoringParameters::CopyFrom(const PriceMonitoringParameters& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vega.PriceMonitoringParameters)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PriceMonitoringParameters::IsInitialized() const {
  return true;
}

void PriceMonitoringParameters::Swap(PriceMonitoringParameters* other) {
  if (other == this) return;
  InternalSwap(other);
}
void PriceMonitoringParameters::InternalSwap(PriceMonitoringParameters* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(horizon_, other->horizon_);
  swap(probability_, other->probability_);
  swap(auctionextension_, other->auctionextension_);
}

::google::protobuf::Metadata PriceMonitoringParameters::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_proto_2fmarkets_2eproto);
  return ::file_level_metadata_proto_2fmarkets_2eproto[kIndexInFileMessages];
}


// ===================================================================

void PriceMonitoringSettings::InitAsDefaultInstance() {
}
class PriceMonitoringSettings::HasBitSetters {
 public:
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int PriceMonitoringSettings::kPriceMonitoringParametersFieldNumber;
const int PriceMonitoringSettings::kUpdateFrequencyFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

PriceMonitoringSettings::PriceMonitoringSettings()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:vega.PriceMonitoringSettings)
}
PriceMonitoringSettings::PriceMonitoringSettings(const PriceMonitoringSettings& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      pricemonitoringparameters_(from.pricemonitoringparameters_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  updatefrequency_ = from.updatefrequency_;
  // @@protoc_insertion_point(copy_constructor:vega.PriceMonitoringSettings)
}

void PriceMonitoringSettings::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_PriceMonitoringSettings_proto_2fmarkets_2eproto.base);
  updatefrequency_ = PROTOBUF_LONGLONG(0);
}

PriceMonitoringSettings::~PriceMonitoringSettings() {
  // @@protoc_insertion_point(destructor:vega.PriceMonitoringSettings)
  SharedDtor();
}

void PriceMonitoringSettings::SharedDtor() {
}

void PriceMonitoringSettings::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const PriceMonitoringSettings& PriceMonitoringSettings::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_PriceMonitoringSettings_proto_2fmarkets_2eproto.base);
  return *internal_default_instance();
}


void PriceMonitoringSettings::Clear() {
// @@protoc_insertion_point(message_clear_start:vega.PriceMonitoringSettings)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  pricemonitoringparameters_.Clear();
  updatefrequency_ = PROTOBUF_LONGLONG(0);
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* PriceMonitoringSettings::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<PriceMonitoringSettings*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // repeated .vega.PriceMonitoringParameters priceMonitoringParameters = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        do {
          ptr = ::google::protobuf::io::ReadSize(ptr, &size);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
          parser_till_end = ::vega::PriceMonitoringParameters::_InternalParse;
          object = msg->add_pricemonitoringparameters();
          if (size > end - ptr) goto len_delim_till_end;
          ptr += size;
          GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
              {parser_till_end, object}, ptr - size, ptr));
          if (ptr >= end) break;
        } while ((::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 10 && (ptr += 1));
        break;
      }
      // int64 updateFrequency = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 16) goto handle_unusual;
        msg->set_updatefrequency(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool PriceMonitoringSettings::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vega.PriceMonitoringSettings)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .vega.PriceMonitoringParameters priceMonitoringParameters = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
                input, add_pricemonitoringparameters()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // int64 updateFrequency = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (16 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &updatefrequency_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vega.PriceMonitoringSettings)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vega.PriceMonitoringSettings)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void PriceMonitoringSettings::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vega.PriceMonitoringSettings)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .vega.PriceMonitoringParameters priceMonitoringParameters = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->pricemonitoringparameters_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1,
      this->pricemonitoringparameters(static_cast<int>(i)),
      output);
  }

  // int64 updateFrequency = 2;
  if (this->updatefrequency() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(2, this->updatefrequency(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:vega.PriceMonitoringSettings)
}

::google::protobuf::uint8* PriceMonitoringSettings::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:vega.PriceMonitoringSettings)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .vega.PriceMonitoringParameters priceMonitoringParameters = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->pricemonitoringparameters_size()); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, this->pricemonitoringparameters(static_cast<int>(i)), target);
  }

  // int64 updateFrequency = 2;
  if (this->updatefrequency() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(2, this->updatefrequency(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vega.PriceMonitoringSettings)
  return target;
}

size_t PriceMonitoringSettings::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vega.PriceMonitoringSettings)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .vega.PriceMonitoringParameters priceMonitoringParameters = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->pricemonitoringparameters_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->pricemonitoringparameters(static_cast<int>(i)));
    }
  }

  // int64 updateFrequency = 2;
  if (this->updatefrequency() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int64Size(
        this->updatefrequency());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PriceMonitoringSettings::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:vega.PriceMonitoringSettings)
  GOOGLE_DCHECK_NE(&from, this);
  const PriceMonitoringSettings* source =
      ::google::protobuf::DynamicCastToGenerated<PriceMonitoringSettings>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:vega.PriceMonitoringSettings)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:vega.PriceMonitoringSettings)
    MergeFrom(*source);
  }
}

void PriceMonitoringSettings::MergeFrom(const PriceMonitoringSettings& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vega.PriceMonitoringSettings)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  pricemonitoringparameters_.MergeFrom(from.pricemonitoringparameters_);
  if (from.updatefrequency() != 0) {
    set_updatefrequency(from.updatefrequency());
  }
}

void PriceMonitoringSettings::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:vega.PriceMonitoringSettings)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PriceMonitoringSettings::CopyFrom(const PriceMonitoringSettings& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vega.PriceMonitoringSettings)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PriceMonitoringSettings::IsInitialized() const {
  return true;
}

void PriceMonitoringSettings::Swap(PriceMonitoringSettings* other) {
  if (other == this) return;
  InternalSwap(other);
}
void PriceMonitoringSettings::InternalSwap(PriceMonitoringSettings* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  CastToBase(&pricemonitoringparameters_)->InternalSwap(CastToBase(&other->pricemonitoringparameters_));
  swap(updatefrequency_, other->updatefrequency_);
}

::google::protobuf::Metadata PriceMonitoringSettings::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_proto_2fmarkets_2eproto);
  return ::file_level_metadata_proto_2fmarkets_2eproto[kIndexInFileMessages];
}


// ===================================================================

void Market::InitAsDefaultInstance() {
  ::vega::_Market_default_instance_._instance.get_mutable()->tradableinstrument_ = const_cast< ::vega::TradableInstrument*>(
      ::vega::TradableInstrument::internal_default_instance());
  ::vega::_Market_default_instance_._instance.get_mutable()->fees_ = const_cast< ::vega::Fees*>(
      ::vega::Fees::internal_default_instance());
  ::vega::_Market_default_instance_._instance.get_mutable()->openingauction_ = const_cast< ::vega::AuctionDuration*>(
      ::vega::AuctionDuration::internal_default_instance());
  ::vega::_Market_default_instance_.continuous_ = const_cast< ::vega::ContinuousTrading*>(
      ::vega::ContinuousTrading::internal_default_instance());
  ::vega::_Market_default_instance_.discrete_ = const_cast< ::vega::DiscreteTrading*>(
      ::vega::DiscreteTrading::internal_default_instance());
  ::vega::_Market_default_instance_._instance.get_mutable()->pricemonitoringsettings_ = const_cast< ::vega::PriceMonitoringSettings*>(
      ::vega::PriceMonitoringSettings::internal_default_instance());
}
class Market::HasBitSetters {
 public:
  static const ::vega::TradableInstrument& tradableinstrument(const Market* msg);
  static const ::vega::Fees& fees(const Market* msg);
  static const ::vega::AuctionDuration& openingauction(const Market* msg);
  static const ::vega::ContinuousTrading& continuous(const Market* msg);
  static const ::vega::DiscreteTrading& discrete(const Market* msg);
  static const ::vega::PriceMonitoringSettings& pricemonitoringsettings(const Market* msg);
};

const ::vega::TradableInstrument&
Market::HasBitSetters::tradableinstrument(const Market* msg) {
  return *msg->tradableinstrument_;
}
const ::vega::Fees&
Market::HasBitSetters::fees(const Market* msg) {
  return *msg->fees_;
}
const ::vega::AuctionDuration&
Market::HasBitSetters::openingauction(const Market* msg) {
  return *msg->openingauction_;
}
const ::vega::ContinuousTrading&
Market::HasBitSetters::continuous(const Market* msg) {
  return *msg->tradingMode_.continuous_;
}
const ::vega::DiscreteTrading&
Market::HasBitSetters::discrete(const Market* msg) {
  return *msg->tradingMode_.discrete_;
}
const ::vega::PriceMonitoringSettings&
Market::HasBitSetters::pricemonitoringsettings(const Market* msg) {
  return *msg->pricemonitoringsettings_;
}
void Market::set_allocated_continuous(::vega::ContinuousTrading* continuous) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  clear_tradingMode();
  if (continuous) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      continuous = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, continuous, submessage_arena);
    }
    set_has_continuous();
    tradingMode_.continuous_ = continuous;
  }
  // @@protoc_insertion_point(field_set_allocated:vega.Market.continuous)
}
void Market::set_allocated_discrete(::vega::DiscreteTrading* discrete) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  clear_tradingMode();
  if (discrete) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      discrete = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, discrete, submessage_arena);
    }
    set_has_discrete();
    tradingMode_.discrete_ = discrete;
  }
  // @@protoc_insertion_point(field_set_allocated:vega.Market.discrete)
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Market::kIdFieldNumber;
const int Market::kTradableInstrumentFieldNumber;
const int Market::kDecimalPlacesFieldNumber;
const int Market::kFeesFieldNumber;
const int Market::kOpeningAuctionFieldNumber;
const int Market::kContinuousFieldNumber;
const int Market::kDiscreteFieldNumber;
const int Market::kPriceMonitoringSettingsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Market::Market()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:vega.Market)
}
Market::Market(const Market& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.id().size() > 0) {
    id_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.id_);
  }
  if (from.has_tradableinstrument()) {
    tradableinstrument_ = new ::vega::TradableInstrument(*from.tradableinstrument_);
  } else {
    tradableinstrument_ = nullptr;
  }
  if (from.has_fees()) {
    fees_ = new ::vega::Fees(*from.fees_);
  } else {
    fees_ = nullptr;
  }
  if (from.has_openingauction()) {
    openingauction_ = new ::vega::AuctionDuration(*from.openingauction_);
  } else {
    openingauction_ = nullptr;
  }
  if (from.has_pricemonitoringsettings()) {
    pricemonitoringsettings_ = new ::vega::PriceMonitoringSettings(*from.pricemonitoringsettings_);
  } else {
    pricemonitoringsettings_ = nullptr;
  }
  decimalplaces_ = from.decimalplaces_;
  clear_has_tradingMode();
  switch (from.tradingMode_case()) {
    case kContinuous: {
      mutable_continuous()->::vega::ContinuousTrading::MergeFrom(from.continuous());
      break;
    }
    case kDiscrete: {
      mutable_discrete()->::vega::DiscreteTrading::MergeFrom(from.discrete());
      break;
    }
    case TRADINGMODE_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:vega.Market)
}

void Market::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_Market_proto_2fmarkets_2eproto.base);
  id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(&tradableinstrument_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&decimalplaces_) -
      reinterpret_cast<char*>(&tradableinstrument_)) + sizeof(decimalplaces_));
  clear_has_tradingMode();
}

Market::~Market() {
  // @@protoc_insertion_point(destructor:vega.Market)
  SharedDtor();
}

void Market::SharedDtor() {
  id_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete tradableinstrument_;
  if (this != internal_default_instance()) delete fees_;
  if (this != internal_default_instance()) delete openingauction_;
  if (this != internal_default_instance()) delete pricemonitoringsettings_;
  if (has_tradingMode()) {
    clear_tradingMode();
  }
}

void Market::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Market& Market::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_Market_proto_2fmarkets_2eproto.base);
  return *internal_default_instance();
}


void Market::clear_tradingMode() {
// @@protoc_insertion_point(one_of_clear_start:vega.Market)
  switch (tradingMode_case()) {
    case kContinuous: {
      delete tradingMode_.continuous_;
      break;
    }
    case kDiscrete: {
      delete tradingMode_.discrete_;
      break;
    }
    case TRADINGMODE_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = TRADINGMODE_NOT_SET;
}


void Market::Clear() {
// @@protoc_insertion_point(message_clear_start:vega.Market)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (GetArenaNoVirtual() == nullptr && tradableinstrument_ != nullptr) {
    delete tradableinstrument_;
  }
  tradableinstrument_ = nullptr;
  if (GetArenaNoVirtual() == nullptr && fees_ != nullptr) {
    delete fees_;
  }
  fees_ = nullptr;
  if (GetArenaNoVirtual() == nullptr && openingauction_ != nullptr) {
    delete openingauction_;
  }
  openingauction_ = nullptr;
  if (GetArenaNoVirtual() == nullptr && pricemonitoringsettings_ != nullptr) {
    delete pricemonitoringsettings_;
  }
  pricemonitoringsettings_ = nullptr;
  decimalplaces_ = PROTOBUF_ULONGLONG(0);
  clear_tradingMode();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Market::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<Market*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // string id = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ctx->extra_parse_data().SetFieldName("vega.Market.id");
        object = msg->mutable_id();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParserUTF8;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheckUTF8(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      // .vega.TradableInstrument tradableInstrument = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::vega::TradableInstrument::_InternalParse;
        object = msg->mutable_tradableinstrument();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // uint64 decimalPlaces = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 24) goto handle_unusual;
        msg->set_decimalplaces(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // .vega.Fees fees = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 34) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::vega::Fees::_InternalParse;
        object = msg->mutable_fees();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // .vega.AuctionDuration openingAuction = 5;
      case 5: {
        if (static_cast<::google::protobuf::uint8>(tag) != 42) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::vega::AuctionDuration::_InternalParse;
        object = msg->mutable_openingauction();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // .vega.PriceMonitoringSettings priceMonitoringSettings = 6;
      case 6: {
        if (static_cast<::google::protobuf::uint8>(tag) != 50) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::vega::PriceMonitoringSettings::_InternalParse;
        object = msg->mutable_pricemonitoringsettings();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // .vega.ContinuousTrading continuous = 100;
      case 100: {
        if (static_cast<::google::protobuf::uint8>(tag) != 34) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::vega::ContinuousTrading::_InternalParse;
        object = msg->mutable_continuous();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // .vega.DiscreteTrading discrete = 101;
      case 101: {
        if (static_cast<::google::protobuf::uint8>(tag) != 42) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::vega::DiscreteTrading::_InternalParse;
        object = msg->mutable_discrete();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
string_till_end:
  static_cast<::std::string*>(object)->clear();
  static_cast<::std::string*>(object)->reserve(size);
  goto len_delim_till_end;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Market::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vega.Market)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(16383u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // string id = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_id()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->id().data(), static_cast<int>(this->id().length()),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "vega.Market.id"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .vega.TradableInstrument tradableInstrument = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_tradableinstrument()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // uint64 decimalPlaces = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (24 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &decimalplaces_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .vega.Fees fees = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (34 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_fees()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .vega.AuctionDuration openingAuction = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (42 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_openingauction()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .vega.PriceMonitoringSettings priceMonitoringSettings = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (50 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_pricemonitoringsettings()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .vega.ContinuousTrading continuous = 100;
      case 100: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (802 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_continuous()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .vega.DiscreteTrading discrete = 101;
      case 101: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (810 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_discrete()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vega.Market)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vega.Market)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Market::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vega.Market)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // string id = 1;
  if (this->id().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->id().data(), static_cast<int>(this->id().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "vega.Market.id");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->id(), output);
  }

  // .vega.TradableInstrument tradableInstrument = 2;
  if (this->has_tradableinstrument()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, HasBitSetters::tradableinstrument(this), output);
  }

  // uint64 decimalPlaces = 3;
  if (this->decimalplaces() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->decimalplaces(), output);
  }

  // .vega.Fees fees = 4;
  if (this->has_fees()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, HasBitSetters::fees(this), output);
  }

  // .vega.AuctionDuration openingAuction = 5;
  if (this->has_openingauction()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, HasBitSetters::openingauction(this), output);
  }

  // .vega.PriceMonitoringSettings priceMonitoringSettings = 6;
  if (this->has_pricemonitoringsettings()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, HasBitSetters::pricemonitoringsettings(this), output);
  }

  // .vega.ContinuousTrading continuous = 100;
  if (has_continuous()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      100, HasBitSetters::continuous(this), output);
  }

  // .vega.DiscreteTrading discrete = 101;
  if (has_discrete()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      101, HasBitSetters::discrete(this), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:vega.Market)
}

::google::protobuf::uint8* Market::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:vega.Market)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // string id = 1;
  if (this->id().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->id().data(), static_cast<int>(this->id().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "vega.Market.id");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->id(), target);
  }

  // .vega.TradableInstrument tradableInstrument = 2;
  if (this->has_tradableinstrument()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, HasBitSetters::tradableinstrument(this), target);
  }

  // uint64 decimalPlaces = 3;
  if (this->decimalplaces() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(3, this->decimalplaces(), target);
  }

  // .vega.Fees fees = 4;
  if (this->has_fees()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        4, HasBitSetters::fees(this), target);
  }

  // .vega.AuctionDuration openingAuction = 5;
  if (this->has_openingauction()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        5, HasBitSetters::openingauction(this), target);
  }

  // .vega.PriceMonitoringSettings priceMonitoringSettings = 6;
  if (this->has_pricemonitoringsettings()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        6, HasBitSetters::pricemonitoringsettings(this), target);
  }

  // .vega.ContinuousTrading continuous = 100;
  if (has_continuous()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        100, HasBitSetters::continuous(this), target);
  }

  // .vega.DiscreteTrading discrete = 101;
  if (has_discrete()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        101, HasBitSetters::discrete(this), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vega.Market)
  return target;
}

size_t Market::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vega.Market)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string id = 1;
  if (this->id().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->id());
  }

  // .vega.TradableInstrument tradableInstrument = 2;
  if (this->has_tradableinstrument()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *tradableinstrument_);
  }

  // .vega.Fees fees = 4;
  if (this->has_fees()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *fees_);
  }

  // .vega.AuctionDuration openingAuction = 5;
  if (this->has_openingauction()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *openingauction_);
  }

  // .vega.PriceMonitoringSettings priceMonitoringSettings = 6;
  if (this->has_pricemonitoringsettings()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *pricemonitoringsettings_);
  }

  // uint64 decimalPlaces = 3;
  if (this->decimalplaces() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->decimalplaces());
  }

  switch (tradingMode_case()) {
    // .vega.ContinuousTrading continuous = 100;
    case kContinuous: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *tradingMode_.continuous_);
      break;
    }
    // .vega.DiscreteTrading discrete = 101;
    case kDiscrete: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *tradingMode_.discrete_);
      break;
    }
    case TRADINGMODE_NOT_SET: {
      break;
    }
  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Market::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:vega.Market)
  GOOGLE_DCHECK_NE(&from, this);
  const Market* source =
      ::google::protobuf::DynamicCastToGenerated<Market>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:vega.Market)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:vega.Market)
    MergeFrom(*source);
  }
}

void Market::MergeFrom(const Market& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vega.Market)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.id().size() > 0) {

    id_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.id_);
  }
  if (from.has_tradableinstrument()) {
    mutable_tradableinstrument()->::vega::TradableInstrument::MergeFrom(from.tradableinstrument());
  }
  if (from.has_fees()) {
    mutable_fees()->::vega::Fees::MergeFrom(from.fees());
  }
  if (from.has_openingauction()) {
    mutable_openingauction()->::vega::AuctionDuration::MergeFrom(from.openingauction());
  }
  if (from.has_pricemonitoringsettings()) {
    mutable_pricemonitoringsettings()->::vega::PriceMonitoringSettings::MergeFrom(from.pricemonitoringsettings());
  }
  if (from.decimalplaces() != 0) {
    set_decimalplaces(from.decimalplaces());
  }
  switch (from.tradingMode_case()) {
    case kContinuous: {
      mutable_continuous()->::vega::ContinuousTrading::MergeFrom(from.continuous());
      break;
    }
    case kDiscrete: {
      mutable_discrete()->::vega::DiscreteTrading::MergeFrom(from.discrete());
      break;
    }
    case TRADINGMODE_NOT_SET: {
      break;
    }
  }
}

void Market::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:vega.Market)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Market::CopyFrom(const Market& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vega.Market)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Market::IsInitialized() const {
  return true;
}

void Market::Swap(Market* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Market::InternalSwap(Market* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  id_.Swap(&other->id_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(tradableinstrument_, other->tradableinstrument_);
  swap(fees_, other->fees_);
  swap(openingauction_, other->openingauction_);
  swap(pricemonitoringsettings_, other->pricemonitoringsettings_);
  swap(decimalplaces_, other->decimalplaces_);
  swap(tradingMode_, other->tradingMode_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

::google::protobuf::Metadata Market::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_proto_2fmarkets_2eproto);
  return ::file_level_metadata_proto_2fmarkets_2eproto[kIndexInFileMessages];
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace vega
namespace google {
namespace protobuf {
template<> PROTOBUF_NOINLINE ::vega::AuctionDuration* Arena::CreateMaybeMessage< ::vega::AuctionDuration >(Arena* arena) {
  return Arena::CreateInternal< ::vega::AuctionDuration >(arena);
}
template<> PROTOBUF_NOINLINE ::vega::ContinuousTrading* Arena::CreateMaybeMessage< ::vega::ContinuousTrading >(Arena* arena) {
  return Arena::CreateInternal< ::vega::ContinuousTrading >(arena);
}
template<> PROTOBUF_NOINLINE ::vega::DiscreteTrading* Arena::CreateMaybeMessage< ::vega::DiscreteTrading >(Arena* arena) {
  return Arena::CreateInternal< ::vega::DiscreteTrading >(arena);
}
template<> PROTOBUF_NOINLINE ::vega::Future* Arena::CreateMaybeMessage< ::vega::Future >(Arena* arena) {
  return Arena::CreateInternal< ::vega::Future >(arena);
}
template<> PROTOBUF_NOINLINE ::vega::EthereumEvent* Arena::CreateMaybeMessage< ::vega::EthereumEvent >(Arena* arena) {
  return Arena::CreateInternal< ::vega::EthereumEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::vega::InstrumentMetadata* Arena::CreateMaybeMessage< ::vega::InstrumentMetadata >(Arena* arena) {
  return Arena::CreateInternal< ::vega::InstrumentMetadata >(arena);
}
template<> PROTOBUF_NOINLINE ::vega::Instrument* Arena::CreateMaybeMessage< ::vega::Instrument >(Arena* arena) {
  return Arena::CreateInternal< ::vega::Instrument >(arena);
}
template<> PROTOBUF_NOINLINE ::vega::LogNormalRiskModel* Arena::CreateMaybeMessage< ::vega::LogNormalRiskModel >(Arena* arena) {
  return Arena::CreateInternal< ::vega::LogNormalRiskModel >(arena);
}
template<> PROTOBUF_NOINLINE ::vega::LogNormalModelParams* Arena::CreateMaybeMessage< ::vega::LogNormalModelParams >(Arena* arena) {
  return Arena::CreateInternal< ::vega::LogNormalModelParams >(arena);
}
template<> PROTOBUF_NOINLINE ::vega::SimpleRiskModel* Arena::CreateMaybeMessage< ::vega::SimpleRiskModel >(Arena* arena) {
  return Arena::CreateInternal< ::vega::SimpleRiskModel >(arena);
}
template<> PROTOBUF_NOINLINE ::vega::SimpleModelParams* Arena::CreateMaybeMessage< ::vega::SimpleModelParams >(Arena* arena) {
  return Arena::CreateInternal< ::vega::SimpleModelParams >(arena);
}
template<> PROTOBUF_NOINLINE ::vega::ScalingFactors* Arena::CreateMaybeMessage< ::vega::ScalingFactors >(Arena* arena) {
  return Arena::CreateInternal< ::vega::ScalingFactors >(arena);
}
template<> PROTOBUF_NOINLINE ::vega::MarginCalculator* Arena::CreateMaybeMessage< ::vega::MarginCalculator >(Arena* arena) {
  return Arena::CreateInternal< ::vega::MarginCalculator >(arena);
}
template<> PROTOBUF_NOINLINE ::vega::TradableInstrument* Arena::CreateMaybeMessage< ::vega::TradableInstrument >(Arena* arena) {
  return Arena::CreateInternal< ::vega::TradableInstrument >(arena);
}
template<> PROTOBUF_NOINLINE ::vega::FeeFactors* Arena::CreateMaybeMessage< ::vega::FeeFactors >(Arena* arena) {
  return Arena::CreateInternal< ::vega::FeeFactors >(arena);
}
template<> PROTOBUF_NOINLINE ::vega::Fees* Arena::CreateMaybeMessage< ::vega::Fees >(Arena* arena) {
  return Arena::CreateInternal< ::vega::Fees >(arena);
}
template<> PROTOBUF_NOINLINE ::vega::PriceMonitoringParameters* Arena::CreateMaybeMessage< ::vega::PriceMonitoringParameters >(Arena* arena) {
  return Arena::CreateInternal< ::vega::PriceMonitoringParameters >(arena);
}
template<> PROTOBUF_NOINLINE ::vega::PriceMonitoringSettings* Arena::CreateMaybeMessage< ::vega::PriceMonitoringSettings >(Arena* arena) {
  return Arena::CreateInternal< ::vega::PriceMonitoringSettings >(arena);
}
template<> PROTOBUF_NOINLINE ::vega::Market* Arena::CreateMaybeMessage< ::vega::Market >(Arena* arena) {
  return Arena::CreateInternal< ::vega::Market >(arena);
}
}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>

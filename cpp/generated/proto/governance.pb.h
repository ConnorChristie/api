// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: proto/governance.proto

#ifndef PROTOBUF_INCLUDED_proto_2fgovernance_2eproto
#define PROTOBUF_INCLUDED_proto_2fgovernance_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3007000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3007001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "github.com/mwitkow/go-proto-validators/validator.pb.h"
#include "proto/markets.pb.h"
#include "proto/assets.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_proto_2fgovernance_2eproto

// Internal implementation detail -- do not use these members.
struct TableStruct_proto_2fgovernance_2eproto {
  static const ::google::protobuf::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::ParseTable schema[15]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors_proto_2fgovernance_2eproto();
namespace vega {
class FeeFactorsConfiguration;
class FeeFactorsConfigurationDefaultTypeInternal;
extern FeeFactorsConfigurationDefaultTypeInternal _FeeFactorsConfiguration_default_instance_;
class FutureProduct;
class FutureProductDefaultTypeInternal;
extern FutureProductDefaultTypeInternal _FutureProduct_default_instance_;
class GovernanceData;
class GovernanceDataDefaultTypeInternal;
extern GovernanceDataDefaultTypeInternal _GovernanceData_default_instance_;
class GovernanceData_NoPartyEntry_DoNotUse;
class GovernanceData_NoPartyEntry_DoNotUseDefaultTypeInternal;
extern GovernanceData_NoPartyEntry_DoNotUseDefaultTypeInternal _GovernanceData_NoPartyEntry_DoNotUse_default_instance_;
class GovernanceData_YesPartyEntry_DoNotUse;
class GovernanceData_YesPartyEntry_DoNotUseDefaultTypeInternal;
extern GovernanceData_YesPartyEntry_DoNotUseDefaultTypeInternal _GovernanceData_YesPartyEntry_DoNotUse_default_instance_;
class InstrumentConfiguration;
class InstrumentConfigurationDefaultTypeInternal;
extern InstrumentConfigurationDefaultTypeInternal _InstrumentConfiguration_default_instance_;
class NetworkConfiguration;
class NetworkConfigurationDefaultTypeInternal;
extern NetworkConfigurationDefaultTypeInternal _NetworkConfiguration_default_instance_;
class NewAsset;
class NewAssetDefaultTypeInternal;
extern NewAssetDefaultTypeInternal _NewAsset_default_instance_;
class NewMarket;
class NewMarketDefaultTypeInternal;
extern NewMarketDefaultTypeInternal _NewMarket_default_instance_;
class NewMarketConfiguration;
class NewMarketConfigurationDefaultTypeInternal;
extern NewMarketConfigurationDefaultTypeInternal _NewMarketConfiguration_default_instance_;
class Proposal;
class ProposalDefaultTypeInternal;
extern ProposalDefaultTypeInternal _Proposal_default_instance_;
class ProposalTerms;
class ProposalTermsDefaultTypeInternal;
extern ProposalTermsDefaultTypeInternal _ProposalTerms_default_instance_;
class UpdateMarket;
class UpdateMarketDefaultTypeInternal;
extern UpdateMarketDefaultTypeInternal _UpdateMarket_default_instance_;
class UpdateNetwork;
class UpdateNetworkDefaultTypeInternal;
extern UpdateNetworkDefaultTypeInternal _UpdateNetwork_default_instance_;
class Vote;
class VoteDefaultTypeInternal;
extern VoteDefaultTypeInternal _Vote_default_instance_;
}  // namespace vega
namespace google {
namespace protobuf {
template<> ::vega::FeeFactorsConfiguration* Arena::CreateMaybeMessage<::vega::FeeFactorsConfiguration>(Arena*);
template<> ::vega::FutureProduct* Arena::CreateMaybeMessage<::vega::FutureProduct>(Arena*);
template<> ::vega::GovernanceData* Arena::CreateMaybeMessage<::vega::GovernanceData>(Arena*);
template<> ::vega::GovernanceData_NoPartyEntry_DoNotUse* Arena::CreateMaybeMessage<::vega::GovernanceData_NoPartyEntry_DoNotUse>(Arena*);
template<> ::vega::GovernanceData_YesPartyEntry_DoNotUse* Arena::CreateMaybeMessage<::vega::GovernanceData_YesPartyEntry_DoNotUse>(Arena*);
template<> ::vega::InstrumentConfiguration* Arena::CreateMaybeMessage<::vega::InstrumentConfiguration>(Arena*);
template<> ::vega::NetworkConfiguration* Arena::CreateMaybeMessage<::vega::NetworkConfiguration>(Arena*);
template<> ::vega::NewAsset* Arena::CreateMaybeMessage<::vega::NewAsset>(Arena*);
template<> ::vega::NewMarket* Arena::CreateMaybeMessage<::vega::NewMarket>(Arena*);
template<> ::vega::NewMarketConfiguration* Arena::CreateMaybeMessage<::vega::NewMarketConfiguration>(Arena*);
template<> ::vega::Proposal* Arena::CreateMaybeMessage<::vega::Proposal>(Arena*);
template<> ::vega::ProposalTerms* Arena::CreateMaybeMessage<::vega::ProposalTerms>(Arena*);
template<> ::vega::UpdateMarket* Arena::CreateMaybeMessage<::vega::UpdateMarket>(Arena*);
template<> ::vega::UpdateNetwork* Arena::CreateMaybeMessage<::vega::UpdateNetwork>(Arena*);
template<> ::vega::Vote* Arena::CreateMaybeMessage<::vega::Vote>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace vega {

enum Proposal_State {
  Proposal_State_STATE_UNSPECIFIED = 0,
  Proposal_State_STATE_FAILED = 1,
  Proposal_State_STATE_OPEN = 2,
  Proposal_State_STATE_PASSED = 3,
  Proposal_State_STATE_REJECTED = 4,
  Proposal_State_STATE_DECLINED = 5,
  Proposal_State_STATE_ENACTED = 6,
  Proposal_State_STATE_WAITING_FOR_NODE_VOTE = 7,
  Proposal_State_Proposal_State_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::min(),
  Proposal_State_Proposal_State_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::max()
};
bool Proposal_State_IsValid(int value);
const Proposal_State Proposal_State_State_MIN = Proposal_State_STATE_UNSPECIFIED;
const Proposal_State Proposal_State_State_MAX = Proposal_State_STATE_WAITING_FOR_NODE_VOTE;
const int Proposal_State_State_ARRAYSIZE = Proposal_State_State_MAX + 1;

const ::google::protobuf::EnumDescriptor* Proposal_State_descriptor();
inline const ::std::string& Proposal_State_Name(Proposal_State value) {
  return ::google::protobuf::internal::NameOfEnum(
    Proposal_State_descriptor(), value);
}
inline bool Proposal_State_Parse(
    const ::std::string& name, Proposal_State* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Proposal_State>(
    Proposal_State_descriptor(), name, value);
}
enum Vote_Value {
  Vote_Value_VALUE_UNSPECIFIED = 0,
  Vote_Value_VALUE_NO = 1,
  Vote_Value_VALUE_YES = 2,
  Vote_Value_Vote_Value_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::min(),
  Vote_Value_Vote_Value_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::max()
};
bool Vote_Value_IsValid(int value);
const Vote_Value Vote_Value_Value_MIN = Vote_Value_VALUE_UNSPECIFIED;
const Vote_Value Vote_Value_Value_MAX = Vote_Value_VALUE_YES;
const int Vote_Value_Value_ARRAYSIZE = Vote_Value_Value_MAX + 1;

const ::google::protobuf::EnumDescriptor* Vote_Value_descriptor();
inline const ::std::string& Vote_Value_Name(Vote_Value value) {
  return ::google::protobuf::internal::NameOfEnum(
    Vote_Value_descriptor(), value);
}
inline bool Vote_Value_Parse(
    const ::std::string& name, Vote_Value* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Vote_Value>(
    Vote_Value_descriptor(), name, value);
}
enum ProposalError {
  PROPOSAL_ERROR_UNSPECIFIED = 0,
  PROPOSAL_ERROR_CLOSE_TIME_TOO_SOON = 1,
  PROPOSAL_ERROR_CLOSE_TIME_TOO_LATE = 2,
  PROPOSAL_ERROR_ENACT_TIME_TOO_SOON = 3,
  PROPOSAL_ERROR_ENACT_TIME_TOO_LATE = 4,
  PROPOSAL_ERROR_INSUFFICIENT_TOKENS = 5,
  PROPOSAL_ERROR_INVALID_INSTRUMENT_SECURITY = 6,
  PROPOSAL_ERROR_NO_PRODUCT = 7,
  PROPOSAL_ERROR_UNSUPPORTED_PRODUCT = 8,
  PROPOSAL_ERROR_INVALID_FUTURE_PRODUCT_TIMESTAMP = 9,
  PROPOSAL_ERROR_PRODUCT_MATURITY_IS_PASSED = 10,
  PROPOSAL_ERROR_NO_TRADING_MODE = 11,
  PROPOSAL_ERROR_UNSUPPORTED_TRADING_MODE = 12,
  PROPOSAL_ERROR_NODE_VALIDATION_FAILED = 13,
  PROPOSAL_ERROR_MISSING_BUILTIN_ASSET_FIELD = 14,
  PROPOSAL_ERROR_MISSING_ERC20_CONTRACT_ADDRESS = 15,
  PROPOSAL_ERROR_INVALID_ASSET = 16,
  PROPOSAL_ERROR_INCOMPATIBLE_TIMESTAMPS = 17,
  ProposalError_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::min(),
  ProposalError_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::max()
};
bool ProposalError_IsValid(int value);
const ProposalError ProposalError_MIN = PROPOSAL_ERROR_UNSPECIFIED;
const ProposalError ProposalError_MAX = PROPOSAL_ERROR_INCOMPATIBLE_TIMESTAMPS;
const int ProposalError_ARRAYSIZE = ProposalError_MAX + 1;

const ::google::protobuf::EnumDescriptor* ProposalError_descriptor();
inline const ::std::string& ProposalError_Name(ProposalError value) {
  return ::google::protobuf::internal::NameOfEnum(
    ProposalError_descriptor(), value);
}
inline bool ProposalError_Parse(
    const ::std::string& name, ProposalError* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ProposalError>(
    ProposalError_descriptor(), name, value);
}
// ===================================================================

class NetworkConfiguration :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vega.NetworkConfiguration) */ {
 public:
  NetworkConfiguration();
  virtual ~NetworkConfiguration();

  NetworkConfiguration(const NetworkConfiguration& from);

  inline NetworkConfiguration& operator=(const NetworkConfiguration& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NetworkConfiguration(NetworkConfiguration&& from) noexcept
    : NetworkConfiguration() {
    *this = ::std::move(from);
  }

  inline NetworkConfiguration& operator=(NetworkConfiguration&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const NetworkConfiguration& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NetworkConfiguration* internal_default_instance() {
    return reinterpret_cast<const NetworkConfiguration*>(
               &_NetworkConfiguration_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(NetworkConfiguration* other);
  friend void swap(NetworkConfiguration& a, NetworkConfiguration& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NetworkConfiguration* New() const final {
    return CreateMaybeMessage<NetworkConfiguration>(nullptr);
  }

  NetworkConfiguration* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<NetworkConfiguration>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const NetworkConfiguration& from);
  void MergeFrom(const NetworkConfiguration& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NetworkConfiguration* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .vega.ScalingFactors marginConfiguration = 9;
  bool has_marginconfiguration() const;
  void clear_marginconfiguration();
  static const int kMarginConfigurationFieldNumber = 9;
  const ::vega::ScalingFactors& marginconfiguration() const;
  ::vega::ScalingFactors* release_marginconfiguration();
  ::vega::ScalingFactors* mutable_marginconfiguration();
  void set_allocated_marginconfiguration(::vega::ScalingFactors* marginconfiguration);

  // .vega.FeeFactorsConfiguration feeFactorsConfiguration = 10;
  bool has_feefactorsconfiguration() const;
  void clear_feefactorsconfiguration();
  static const int kFeeFactorsConfigurationFieldNumber = 10;
  const ::vega::FeeFactorsConfiguration& feefactorsconfiguration() const;
  ::vega::FeeFactorsConfiguration* release_feefactorsconfiguration();
  ::vega::FeeFactorsConfiguration* mutable_feefactorsconfiguration();
  void set_allocated_feefactorsconfiguration(::vega::FeeFactorsConfiguration* feefactorsconfiguration);

  // int64 minCloseInSeconds = 1;
  void clear_mincloseinseconds();
  static const int kMinCloseInSecondsFieldNumber = 1;
  ::google::protobuf::int64 mincloseinseconds() const;
  void set_mincloseinseconds(::google::protobuf::int64 value);

  // int64 maxCloseInSeconds = 2;
  void clear_maxcloseinseconds();
  static const int kMaxCloseInSecondsFieldNumber = 2;
  ::google::protobuf::int64 maxcloseinseconds() const;
  void set_maxcloseinseconds(::google::protobuf::int64 value);

  // int64 minEnactInSeconds = 3;
  void clear_minenactinseconds();
  static const int kMinEnactInSecondsFieldNumber = 3;
  ::google::protobuf::int64 minenactinseconds() const;
  void set_minenactinseconds(::google::protobuf::int64 value);

  // int64 maxEnactInSeconds = 4;
  void clear_maxenactinseconds();
  static const int kMaxEnactInSecondsFieldNumber = 4;
  ::google::protobuf::int64 maxenactinseconds() const;
  void set_maxenactinseconds(::google::protobuf::int64 value);

  // float requiredParticipation = 5;
  void clear_requiredparticipation();
  static const int kRequiredParticipationFieldNumber = 5;
  float requiredparticipation() const;
  void set_requiredparticipation(float value);

  // float requiredMajority = 6;
  void clear_requiredmajority();
  static const int kRequiredMajorityFieldNumber = 6;
  float requiredmajority() const;
  void set_requiredmajority(float value);

  // float minProposerBalance = 7;
  void clear_minproposerbalance();
  static const int kMinProposerBalanceFieldNumber = 7;
  float minproposerbalance() const;
  void set_minproposerbalance(float value);

  // float minVoterBalance = 8;
  void clear_minvoterbalance();
  static const int kMinVoterBalanceFieldNumber = 8;
  float minvoterbalance() const;
  void set_minvoterbalance(float value);

  // @@protoc_insertion_point(class_scope:vega.NetworkConfiguration)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::vega::ScalingFactors* marginconfiguration_;
  ::vega::FeeFactorsConfiguration* feefactorsconfiguration_;
  ::google::protobuf::int64 mincloseinseconds_;
  ::google::protobuf::int64 maxcloseinseconds_;
  ::google::protobuf::int64 minenactinseconds_;
  ::google::protobuf::int64 maxenactinseconds_;
  float requiredparticipation_;
  float requiredmajority_;
  float minproposerbalance_;
  float minvoterbalance_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fgovernance_2eproto;
};
// -------------------------------------------------------------------

class FeeFactorsConfiguration :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vega.FeeFactorsConfiguration) */ {
 public:
  FeeFactorsConfiguration();
  virtual ~FeeFactorsConfiguration();

  FeeFactorsConfiguration(const FeeFactorsConfiguration& from);

  inline FeeFactorsConfiguration& operator=(const FeeFactorsConfiguration& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FeeFactorsConfiguration(FeeFactorsConfiguration&& from) noexcept
    : FeeFactorsConfiguration() {
    *this = ::std::move(from);
  }

  inline FeeFactorsConfiguration& operator=(FeeFactorsConfiguration&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const FeeFactorsConfiguration& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FeeFactorsConfiguration* internal_default_instance() {
    return reinterpret_cast<const FeeFactorsConfiguration*>(
               &_FeeFactorsConfiguration_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(FeeFactorsConfiguration* other);
  friend void swap(FeeFactorsConfiguration& a, FeeFactorsConfiguration& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FeeFactorsConfiguration* New() const final {
    return CreateMaybeMessage<FeeFactorsConfiguration>(nullptr);
  }

  FeeFactorsConfiguration* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FeeFactorsConfiguration>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FeeFactorsConfiguration& from);
  void MergeFrom(const FeeFactorsConfiguration& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FeeFactorsConfiguration* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string infrastructureFee = 1;
  void clear_infrastructurefee();
  static const int kInfrastructureFeeFieldNumber = 1;
  const ::std::string& infrastructurefee() const;
  void set_infrastructurefee(const ::std::string& value);
  #if LANG_CXX11
  void set_infrastructurefee(::std::string&& value);
  #endif
  void set_infrastructurefee(const char* value);
  void set_infrastructurefee(const char* value, size_t size);
  ::std::string* mutable_infrastructurefee();
  ::std::string* release_infrastructurefee();
  void set_allocated_infrastructurefee(::std::string* infrastructurefee);

  // string makerFee = 2;
  void clear_makerfee();
  static const int kMakerFeeFieldNumber = 2;
  const ::std::string& makerfee() const;
  void set_makerfee(const ::std::string& value);
  #if LANG_CXX11
  void set_makerfee(::std::string&& value);
  #endif
  void set_makerfee(const char* value);
  void set_makerfee(const char* value, size_t size);
  ::std::string* mutable_makerfee();
  ::std::string* release_makerfee();
  void set_allocated_makerfee(::std::string* makerfee);

  // string liquidityFee = 3;
  void clear_liquidityfee();
  static const int kLiquidityFeeFieldNumber = 3;
  const ::std::string& liquidityfee() const;
  void set_liquidityfee(const ::std::string& value);
  #if LANG_CXX11
  void set_liquidityfee(::std::string&& value);
  #endif
  void set_liquidityfee(const char* value);
  void set_liquidityfee(const char* value, size_t size);
  ::std::string* mutable_liquidityfee();
  ::std::string* release_liquidityfee();
  void set_allocated_liquidityfee(::std::string* liquidityfee);

  // @@protoc_insertion_point(class_scope:vega.FeeFactorsConfiguration)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr infrastructurefee_;
  ::google::protobuf::internal::ArenaStringPtr makerfee_;
  ::google::protobuf::internal::ArenaStringPtr liquidityfee_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fgovernance_2eproto;
};
// -------------------------------------------------------------------

class UpdateMarket :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vega.UpdateMarket) */ {
 public:
  UpdateMarket();
  virtual ~UpdateMarket();

  UpdateMarket(const UpdateMarket& from);

  inline UpdateMarket& operator=(const UpdateMarket& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UpdateMarket(UpdateMarket&& from) noexcept
    : UpdateMarket() {
    *this = ::std::move(from);
  }

  inline UpdateMarket& operator=(UpdateMarket&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const UpdateMarket& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UpdateMarket* internal_default_instance() {
    return reinterpret_cast<const UpdateMarket*>(
               &_UpdateMarket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(UpdateMarket* other);
  friend void swap(UpdateMarket& a, UpdateMarket& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UpdateMarket* New() const final {
    return CreateMaybeMessage<UpdateMarket>(nullptr);
  }

  UpdateMarket* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UpdateMarket>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UpdateMarket& from);
  void MergeFrom(const UpdateMarket& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateMarket* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:vega.UpdateMarket)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fgovernance_2eproto;
};
// -------------------------------------------------------------------

class FutureProduct :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vega.FutureProduct) */ {
 public:
  FutureProduct();
  virtual ~FutureProduct();

  FutureProduct(const FutureProduct& from);

  inline FutureProduct& operator=(const FutureProduct& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FutureProduct(FutureProduct&& from) noexcept
    : FutureProduct() {
    *this = ::std::move(from);
  }

  inline FutureProduct& operator=(FutureProduct&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const FutureProduct& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FutureProduct* internal_default_instance() {
    return reinterpret_cast<const FutureProduct*>(
               &_FutureProduct_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(FutureProduct* other);
  friend void swap(FutureProduct& a, FutureProduct& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FutureProduct* New() const final {
    return CreateMaybeMessage<FutureProduct>(nullptr);
  }

  FutureProduct* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FutureProduct>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FutureProduct& from);
  void MergeFrom(const FutureProduct& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FutureProduct* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string maturity = 1 [(.validator.field) = {
  void clear_maturity();
  static const int kMaturityFieldNumber = 1;
  const ::std::string& maturity() const;
  void set_maturity(const ::std::string& value);
  #if LANG_CXX11
  void set_maturity(::std::string&& value);
  #endif
  void set_maturity(const char* value);
  void set_maturity(const char* value, size_t size);
  ::std::string* mutable_maturity();
  ::std::string* release_maturity();
  void set_allocated_maturity(::std::string* maturity);

  // string asset = 2 [(.validator.field) = {
  void clear_asset();
  static const int kAssetFieldNumber = 2;
  const ::std::string& asset() const;
  void set_asset(const ::std::string& value);
  #if LANG_CXX11
  void set_asset(::std::string&& value);
  #endif
  void set_asset(const char* value);
  void set_asset(const char* value, size_t size);
  ::std::string* mutable_asset();
  ::std::string* release_asset();
  void set_allocated_asset(::std::string* asset);

  // @@protoc_insertion_point(class_scope:vega.FutureProduct)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr maturity_;
  ::google::protobuf::internal::ArenaStringPtr asset_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fgovernance_2eproto;
};
// -------------------------------------------------------------------

class InstrumentConfiguration :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vega.InstrumentConfiguration) */ {
 public:
  InstrumentConfiguration();
  virtual ~InstrumentConfiguration();

  InstrumentConfiguration(const InstrumentConfiguration& from);

  inline InstrumentConfiguration& operator=(const InstrumentConfiguration& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  InstrumentConfiguration(InstrumentConfiguration&& from) noexcept
    : InstrumentConfiguration() {
    *this = ::std::move(from);
  }

  inline InstrumentConfiguration& operator=(InstrumentConfiguration&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const InstrumentConfiguration& default_instance();

  enum ProductCase {
    kFuture = 100,
    PRODUCT_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const InstrumentConfiguration* internal_default_instance() {
    return reinterpret_cast<const InstrumentConfiguration*>(
               &_InstrumentConfiguration_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(InstrumentConfiguration* other);
  friend void swap(InstrumentConfiguration& a, InstrumentConfiguration& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline InstrumentConfiguration* New() const final {
    return CreateMaybeMessage<InstrumentConfiguration>(nullptr);
  }

  InstrumentConfiguration* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<InstrumentConfiguration>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const InstrumentConfiguration& from);
  void MergeFrom(const InstrumentConfiguration& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InstrumentConfiguration* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1 [(.validator.field) = {
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string code = 2 [(.validator.field) = {
  void clear_code();
  static const int kCodeFieldNumber = 2;
  const ::std::string& code() const;
  void set_code(const ::std::string& value);
  #if LANG_CXX11
  void set_code(::std::string&& value);
  #endif
  void set_code(const char* value);
  void set_code(const char* value, size_t size);
  ::std::string* mutable_code();
  ::std::string* release_code();
  void set_allocated_code(::std::string* code);

  // string baseName = 3 [(.validator.field) = {
  void clear_basename();
  static const int kBaseNameFieldNumber = 3;
  const ::std::string& basename() const;
  void set_basename(const ::std::string& value);
  #if LANG_CXX11
  void set_basename(::std::string&& value);
  #endif
  void set_basename(const char* value);
  void set_basename(const char* value, size_t size);
  ::std::string* mutable_basename();
  ::std::string* release_basename();
  void set_allocated_basename(::std::string* basename);

  // string quoteName = 4 [(.validator.field) = {
  void clear_quotename();
  static const int kQuoteNameFieldNumber = 4;
  const ::std::string& quotename() const;
  void set_quotename(const ::std::string& value);
  #if LANG_CXX11
  void set_quotename(::std::string&& value);
  #endif
  void set_quotename(const char* value);
  void set_quotename(const char* value, size_t size);
  ::std::string* mutable_quotename();
  ::std::string* release_quotename();
  void set_allocated_quotename(::std::string* quotename);

  // .vega.FutureProduct future = 100;
  bool has_future() const;
  void clear_future();
  static const int kFutureFieldNumber = 100;
  const ::vega::FutureProduct& future() const;
  ::vega::FutureProduct* release_future();
  ::vega::FutureProduct* mutable_future();
  void set_allocated_future(::vega::FutureProduct* future);

  void clear_product();
  ProductCase product_case() const;
  // @@protoc_insertion_point(class_scope:vega.InstrumentConfiguration)
 private:
  class HasBitSetters;
  void set_has_future();

  inline bool has_product() const;
  inline void clear_has_product();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr code_;
  ::google::protobuf::internal::ArenaStringPtr basename_;
  ::google::protobuf::internal::ArenaStringPtr quotename_;
  union ProductUnion {
    ProductUnion() {}
    ::vega::FutureProduct* future_;
  } product_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::TableStruct_proto_2fgovernance_2eproto;
};
// -------------------------------------------------------------------

class NewMarketConfiguration :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vega.NewMarketConfiguration) */ {
 public:
  NewMarketConfiguration();
  virtual ~NewMarketConfiguration();

  NewMarketConfiguration(const NewMarketConfiguration& from);

  inline NewMarketConfiguration& operator=(const NewMarketConfiguration& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NewMarketConfiguration(NewMarketConfiguration&& from) noexcept
    : NewMarketConfiguration() {
    *this = ::std::move(from);
  }

  inline NewMarketConfiguration& operator=(NewMarketConfiguration&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const NewMarketConfiguration& default_instance();

  enum RiskParametersCase {
    kSimple = 100,
    kLogNormal = 101,
    RISKPARAMETERS_NOT_SET = 0,
  };

  enum TradingModeCase {
    kContinuous = 200,
    kDiscrete = 201,
    TRADINGMODE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NewMarketConfiguration* internal_default_instance() {
    return reinterpret_cast<const NewMarketConfiguration*>(
               &_NewMarketConfiguration_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(NewMarketConfiguration* other);
  friend void swap(NewMarketConfiguration& a, NewMarketConfiguration& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NewMarketConfiguration* New() const final {
    return CreateMaybeMessage<NewMarketConfiguration>(nullptr);
  }

  NewMarketConfiguration* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<NewMarketConfiguration>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const NewMarketConfiguration& from);
  void MergeFrom(const NewMarketConfiguration& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NewMarketConfiguration* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string metadata = 3;
  int metadata_size() const;
  void clear_metadata();
  static const int kMetadataFieldNumber = 3;
  const ::std::string& metadata(int index) const;
  ::std::string* mutable_metadata(int index);
  void set_metadata(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_metadata(int index, ::std::string&& value);
  #endif
  void set_metadata(int index, const char* value);
  void set_metadata(int index, const char* value, size_t size);
  ::std::string* add_metadata();
  void add_metadata(const ::std::string& value);
  #if LANG_CXX11
  void add_metadata(::std::string&& value);
  #endif
  void add_metadata(const char* value);
  void add_metadata(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField<::std::string>& metadata() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* mutable_metadata();

  // .vega.InstrumentConfiguration instrument = 1 [(.validator.field) = {
  bool has_instrument() const;
  void clear_instrument();
  static const int kInstrumentFieldNumber = 1;
  const ::vega::InstrumentConfiguration& instrument() const;
  ::vega::InstrumentConfiguration* release_instrument();
  ::vega::InstrumentConfiguration* mutable_instrument();
  void set_allocated_instrument(::vega::InstrumentConfiguration* instrument);

  // uint64 decimalPlaces = 2 [(.validator.field) = {
  void clear_decimalplaces();
  static const int kDecimalPlacesFieldNumber = 2;
  ::google::protobuf::uint64 decimalplaces() const;
  void set_decimalplaces(::google::protobuf::uint64 value);

  // int64 openingAuctionDuration = 4;
  void clear_openingauctionduration();
  static const int kOpeningAuctionDurationFieldNumber = 4;
  ::google::protobuf::int64 openingauctionduration() const;
  void set_openingauctionduration(::google::protobuf::int64 value);

  // .vega.SimpleModelParams simple = 100;
  bool has_simple() const;
  void clear_simple();
  static const int kSimpleFieldNumber = 100;
  const ::vega::SimpleModelParams& simple() const;
  ::vega::SimpleModelParams* release_simple();
  ::vega::SimpleModelParams* mutable_simple();
  void set_allocated_simple(::vega::SimpleModelParams* simple);

  // .vega.LogNormalRiskModel logNormal = 101;
  bool has_lognormal() const;
  void clear_lognormal();
  static const int kLogNormalFieldNumber = 101;
  const ::vega::LogNormalRiskModel& lognormal() const;
  ::vega::LogNormalRiskModel* release_lognormal();
  ::vega::LogNormalRiskModel* mutable_lognormal();
  void set_allocated_lognormal(::vega::LogNormalRiskModel* lognormal);

  // .vega.ContinuousTrading continuous = 200;
  bool has_continuous() const;
  void clear_continuous();
  static const int kContinuousFieldNumber = 200;
  const ::vega::ContinuousTrading& continuous() const;
  ::vega::ContinuousTrading* release_continuous();
  ::vega::ContinuousTrading* mutable_continuous();
  void set_allocated_continuous(::vega::ContinuousTrading* continuous);

  // .vega.DiscreteTrading discrete = 201;
  bool has_discrete() const;
  void clear_discrete();
  static const int kDiscreteFieldNumber = 201;
  const ::vega::DiscreteTrading& discrete() const;
  ::vega::DiscreteTrading* release_discrete();
  ::vega::DiscreteTrading* mutable_discrete();
  void set_allocated_discrete(::vega::DiscreteTrading* discrete);

  void clear_riskParameters();
  RiskParametersCase riskParameters_case() const;
  void clear_tradingMode();
  TradingModeCase tradingMode_case() const;
  // @@protoc_insertion_point(class_scope:vega.NewMarketConfiguration)
 private:
  class HasBitSetters;
  void set_has_simple();
  void set_has_lognormal();
  void set_has_continuous();
  void set_has_discrete();

  inline bool has_riskParameters() const;
  inline void clear_has_riskParameters();

  inline bool has_tradingMode() const;
  inline void clear_has_tradingMode();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField<::std::string> metadata_;
  ::vega::InstrumentConfiguration* instrument_;
  ::google::protobuf::uint64 decimalplaces_;
  ::google::protobuf::int64 openingauctionduration_;
  union RiskParametersUnion {
    RiskParametersUnion() {}
    ::vega::SimpleModelParams* simple_;
    ::vega::LogNormalRiskModel* lognormal_;
  } riskParameters_;
  union TradingModeUnion {
    TradingModeUnion() {}
    ::vega::ContinuousTrading* continuous_;
    ::vega::DiscreteTrading* discrete_;
  } tradingMode_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[2];

  friend struct ::TableStruct_proto_2fgovernance_2eproto;
};
// -------------------------------------------------------------------

class NewMarket :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vega.NewMarket) */ {
 public:
  NewMarket();
  virtual ~NewMarket();

  NewMarket(const NewMarket& from);

  inline NewMarket& operator=(const NewMarket& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NewMarket(NewMarket&& from) noexcept
    : NewMarket() {
    *this = ::std::move(from);
  }

  inline NewMarket& operator=(NewMarket&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const NewMarket& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NewMarket* internal_default_instance() {
    return reinterpret_cast<const NewMarket*>(
               &_NewMarket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(NewMarket* other);
  friend void swap(NewMarket& a, NewMarket& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NewMarket* New() const final {
    return CreateMaybeMessage<NewMarket>(nullptr);
  }

  NewMarket* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<NewMarket>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const NewMarket& from);
  void MergeFrom(const NewMarket& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NewMarket* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .vega.NewMarketConfiguration changes = 1 [(.validator.field) = {
  bool has_changes() const;
  void clear_changes();
  static const int kChangesFieldNumber = 1;
  const ::vega::NewMarketConfiguration& changes() const;
  ::vega::NewMarketConfiguration* release_changes();
  ::vega::NewMarketConfiguration* mutable_changes();
  void set_allocated_changes(::vega::NewMarketConfiguration* changes);

  // @@protoc_insertion_point(class_scope:vega.NewMarket)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::vega::NewMarketConfiguration* changes_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fgovernance_2eproto;
};
// -------------------------------------------------------------------

class UpdateNetwork :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vega.UpdateNetwork) */ {
 public:
  UpdateNetwork();
  virtual ~UpdateNetwork();

  UpdateNetwork(const UpdateNetwork& from);

  inline UpdateNetwork& operator=(const UpdateNetwork& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UpdateNetwork(UpdateNetwork&& from) noexcept
    : UpdateNetwork() {
    *this = ::std::move(from);
  }

  inline UpdateNetwork& operator=(UpdateNetwork&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const UpdateNetwork& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UpdateNetwork* internal_default_instance() {
    return reinterpret_cast<const UpdateNetwork*>(
               &_UpdateNetwork_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(UpdateNetwork* other);
  friend void swap(UpdateNetwork& a, UpdateNetwork& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UpdateNetwork* New() const final {
    return CreateMaybeMessage<UpdateNetwork>(nullptr);
  }

  UpdateNetwork* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UpdateNetwork>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UpdateNetwork& from);
  void MergeFrom(const UpdateNetwork& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateNetwork* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .vega.NetworkConfiguration changes = 1 [(.validator.field) = {
  bool has_changes() const;
  void clear_changes();
  static const int kChangesFieldNumber = 1;
  const ::vega::NetworkConfiguration& changes() const;
  ::vega::NetworkConfiguration* release_changes();
  ::vega::NetworkConfiguration* mutable_changes();
  void set_allocated_changes(::vega::NetworkConfiguration* changes);

  // @@protoc_insertion_point(class_scope:vega.UpdateNetwork)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::vega::NetworkConfiguration* changes_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fgovernance_2eproto;
};
// -------------------------------------------------------------------

class NewAsset :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vega.NewAsset) */ {
 public:
  NewAsset();
  virtual ~NewAsset();

  NewAsset(const NewAsset& from);

  inline NewAsset& operator=(const NewAsset& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NewAsset(NewAsset&& from) noexcept
    : NewAsset() {
    *this = ::std::move(from);
  }

  inline NewAsset& operator=(NewAsset&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const NewAsset& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NewAsset* internal_default_instance() {
    return reinterpret_cast<const NewAsset*>(
               &_NewAsset_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(NewAsset* other);
  friend void swap(NewAsset& a, NewAsset& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NewAsset* New() const final {
    return CreateMaybeMessage<NewAsset>(nullptr);
  }

  NewAsset* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<NewAsset>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const NewAsset& from);
  void MergeFrom(const NewAsset& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NewAsset* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .vega.AssetSource changes = 1 [(.validator.field) = {
  bool has_changes() const;
  void clear_changes();
  static const int kChangesFieldNumber = 1;
  const ::vega::AssetSource& changes() const;
  ::vega::AssetSource* release_changes();
  ::vega::AssetSource* mutable_changes();
  void set_allocated_changes(::vega::AssetSource* changes);

  // @@protoc_insertion_point(class_scope:vega.NewAsset)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::vega::AssetSource* changes_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fgovernance_2eproto;
};
// -------------------------------------------------------------------

class ProposalTerms :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vega.ProposalTerms) */ {
 public:
  ProposalTerms();
  virtual ~ProposalTerms();

  ProposalTerms(const ProposalTerms& from);

  inline ProposalTerms& operator=(const ProposalTerms& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProposalTerms(ProposalTerms&& from) noexcept
    : ProposalTerms() {
    *this = ::std::move(from);
  }

  inline ProposalTerms& operator=(ProposalTerms&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ProposalTerms& default_instance();

  enum ChangeCase {
    kUpdateMarket = 101,
    kNewMarket = 102,
    kUpdateNetwork = 103,
    kNewAsset = 104,
    CHANGE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProposalTerms* internal_default_instance() {
    return reinterpret_cast<const ProposalTerms*>(
               &_ProposalTerms_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(ProposalTerms* other);
  friend void swap(ProposalTerms& a, ProposalTerms& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProposalTerms* New() const final {
    return CreateMaybeMessage<ProposalTerms>(nullptr);
  }

  ProposalTerms* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ProposalTerms>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ProposalTerms& from);
  void MergeFrom(const ProposalTerms& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProposalTerms* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int64 closingTimestamp = 1 [(.validator.field) = {
  void clear_closingtimestamp();
  static const int kClosingTimestampFieldNumber = 1;
  ::google::protobuf::int64 closingtimestamp() const;
  void set_closingtimestamp(::google::protobuf::int64 value);

  // int64 enactmentTimestamp = 2 [(.validator.field) = {
  void clear_enactmenttimestamp();
  static const int kEnactmentTimestampFieldNumber = 2;
  ::google::protobuf::int64 enactmenttimestamp() const;
  void set_enactmenttimestamp(::google::protobuf::int64 value);

  // int64 validationTimestamp = 3;
  void clear_validationtimestamp();
  static const int kValidationTimestampFieldNumber = 3;
  ::google::protobuf::int64 validationtimestamp() const;
  void set_validationtimestamp(::google::protobuf::int64 value);

  // .vega.UpdateMarket updateMarket = 101;
  bool has_updatemarket() const;
  void clear_updatemarket();
  static const int kUpdateMarketFieldNumber = 101;
  const ::vega::UpdateMarket& updatemarket() const;
  ::vega::UpdateMarket* release_updatemarket();
  ::vega::UpdateMarket* mutable_updatemarket();
  void set_allocated_updatemarket(::vega::UpdateMarket* updatemarket);

  // .vega.NewMarket newMarket = 102;
  bool has_newmarket() const;
  void clear_newmarket();
  static const int kNewMarketFieldNumber = 102;
  const ::vega::NewMarket& newmarket() const;
  ::vega::NewMarket* release_newmarket();
  ::vega::NewMarket* mutable_newmarket();
  void set_allocated_newmarket(::vega::NewMarket* newmarket);

  // .vega.UpdateNetwork updateNetwork = 103;
  bool has_updatenetwork() const;
  void clear_updatenetwork();
  static const int kUpdateNetworkFieldNumber = 103;
  const ::vega::UpdateNetwork& updatenetwork() const;
  ::vega::UpdateNetwork* release_updatenetwork();
  ::vega::UpdateNetwork* mutable_updatenetwork();
  void set_allocated_updatenetwork(::vega::UpdateNetwork* updatenetwork);

  // .vega.NewAsset newAsset = 104;
  bool has_newasset() const;
  void clear_newasset();
  static const int kNewAssetFieldNumber = 104;
  const ::vega::NewAsset& newasset() const;
  ::vega::NewAsset* release_newasset();
  ::vega::NewAsset* mutable_newasset();
  void set_allocated_newasset(::vega::NewAsset* newasset);

  void clear_change();
  ChangeCase change_case() const;
  // @@protoc_insertion_point(class_scope:vega.ProposalTerms)
 private:
  class HasBitSetters;
  void set_has_updatemarket();
  void set_has_newmarket();
  void set_has_updatenetwork();
  void set_has_newasset();

  inline bool has_change() const;
  inline void clear_has_change();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int64 closingtimestamp_;
  ::google::protobuf::int64 enactmenttimestamp_;
  ::google::protobuf::int64 validationtimestamp_;
  union ChangeUnion {
    ChangeUnion() {}
    ::vega::UpdateMarket* updatemarket_;
    ::vega::NewMarket* newmarket_;
    ::vega::UpdateNetwork* updatenetwork_;
    ::vega::NewAsset* newasset_;
  } change_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::TableStruct_proto_2fgovernance_2eproto;
};
// -------------------------------------------------------------------

class GovernanceData_YesPartyEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<GovernanceData_YesPartyEntry_DoNotUse, 
    ::std::string, ::vega::Vote,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
static bool _ParseMap(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  typedef ::google::protobuf::internal::MapEntry<GovernanceData_YesPartyEntry_DoNotUse, 
    ::std::string, ::vega::Vote,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  GovernanceData_YesPartyEntry_DoNotUse();
  GovernanceData_YesPartyEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const GovernanceData_YesPartyEntry_DoNotUse& other);
  static const GovernanceData_YesPartyEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const GovernanceData_YesPartyEntry_DoNotUse*>(&_GovernanceData_YesPartyEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class GovernanceData_NoPartyEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<GovernanceData_NoPartyEntry_DoNotUse, 
    ::std::string, ::vega::Vote,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
static bool _ParseMap(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  typedef ::google::protobuf::internal::MapEntry<GovernanceData_NoPartyEntry_DoNotUse, 
    ::std::string, ::vega::Vote,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  GovernanceData_NoPartyEntry_DoNotUse();
  GovernanceData_NoPartyEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const GovernanceData_NoPartyEntry_DoNotUse& other);
  static const GovernanceData_NoPartyEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const GovernanceData_NoPartyEntry_DoNotUse*>(&_GovernanceData_NoPartyEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class GovernanceData :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vega.GovernanceData) */ {
 public:
  GovernanceData();
  virtual ~GovernanceData();

  GovernanceData(const GovernanceData& from);

  inline GovernanceData& operator=(const GovernanceData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GovernanceData(GovernanceData&& from) noexcept
    : GovernanceData() {
    *this = ::std::move(from);
  }

  inline GovernanceData& operator=(GovernanceData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const GovernanceData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GovernanceData* internal_default_instance() {
    return reinterpret_cast<const GovernanceData*>(
               &_GovernanceData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(GovernanceData* other);
  friend void swap(GovernanceData& a, GovernanceData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GovernanceData* New() const final {
    return CreateMaybeMessage<GovernanceData>(nullptr);
  }

  GovernanceData* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GovernanceData>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GovernanceData& from);
  void MergeFrom(const GovernanceData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GovernanceData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // repeated .vega.Vote yes = 2;
  int yes_size() const;
  void clear_yes();
  static const int kYesFieldNumber = 2;
  ::vega::Vote* mutable_yes(int index);
  ::google::protobuf::RepeatedPtrField< ::vega::Vote >*
      mutable_yes();
  const ::vega::Vote& yes(int index) const;
  ::vega::Vote* add_yes();
  const ::google::protobuf::RepeatedPtrField< ::vega::Vote >&
      yes() const;

  // repeated .vega.Vote no = 3;
  int no_size() const;
  void clear_no();
  static const int kNoFieldNumber = 3;
  ::vega::Vote* mutable_no(int index);
  ::google::protobuf::RepeatedPtrField< ::vega::Vote >*
      mutable_no();
  const ::vega::Vote& no(int index) const;
  ::vega::Vote* add_no();
  const ::google::protobuf::RepeatedPtrField< ::vega::Vote >&
      no() const;

  // map<string, .vega.Vote> yesParty = 4;
  int yesparty_size() const;
  void clear_yesparty();
  static const int kYesPartyFieldNumber = 4;
  const ::google::protobuf::Map< ::std::string, ::vega::Vote >&
      yesparty() const;
  ::google::protobuf::Map< ::std::string, ::vega::Vote >*
      mutable_yesparty();

  // map<string, .vega.Vote> noParty = 5;
  int noparty_size() const;
  void clear_noparty();
  static const int kNoPartyFieldNumber = 5;
  const ::google::protobuf::Map< ::std::string, ::vega::Vote >&
      noparty() const;
  ::google::protobuf::Map< ::std::string, ::vega::Vote >*
      mutable_noparty();

  // .vega.Proposal proposal = 1;
  bool has_proposal() const;
  void clear_proposal();
  static const int kProposalFieldNumber = 1;
  const ::vega::Proposal& proposal() const;
  ::vega::Proposal* release_proposal();
  ::vega::Proposal* mutable_proposal();
  void set_allocated_proposal(::vega::Proposal* proposal);

  // @@protoc_insertion_point(class_scope:vega.GovernanceData)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::vega::Vote > yes_;
  ::google::protobuf::RepeatedPtrField< ::vega::Vote > no_;
  ::google::protobuf::internal::MapField<
      GovernanceData_YesPartyEntry_DoNotUse,
      ::std::string, ::vega::Vote,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > yesparty_;
  ::google::protobuf::internal::MapField<
      GovernanceData_NoPartyEntry_DoNotUse,
      ::std::string, ::vega::Vote,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > noparty_;
  ::vega::Proposal* proposal_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fgovernance_2eproto;
};
// -------------------------------------------------------------------

class Proposal :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vega.Proposal) */ {
 public:
  Proposal();
  virtual ~Proposal();

  Proposal(const Proposal& from);

  inline Proposal& operator=(const Proposal& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Proposal(Proposal&& from) noexcept
    : Proposal() {
    *this = ::std::move(from);
  }

  inline Proposal& operator=(Proposal&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Proposal& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Proposal* internal_default_instance() {
    return reinterpret_cast<const Proposal*>(
               &_Proposal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(Proposal* other);
  friend void swap(Proposal& a, Proposal& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Proposal* New() const final {
    return CreateMaybeMessage<Proposal>(nullptr);
  }

  Proposal* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Proposal>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Proposal& from);
  void MergeFrom(const Proposal& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Proposal* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Proposal_State State;
  static const State STATE_UNSPECIFIED =
    Proposal_State_STATE_UNSPECIFIED;
  static const State STATE_FAILED =
    Proposal_State_STATE_FAILED;
  static const State STATE_OPEN =
    Proposal_State_STATE_OPEN;
  static const State STATE_PASSED =
    Proposal_State_STATE_PASSED;
  static const State STATE_REJECTED =
    Proposal_State_STATE_REJECTED;
  static const State STATE_DECLINED =
    Proposal_State_STATE_DECLINED;
  static const State STATE_ENACTED =
    Proposal_State_STATE_ENACTED;
  static const State STATE_WAITING_FOR_NODE_VOTE =
    Proposal_State_STATE_WAITING_FOR_NODE_VOTE;
  static inline bool State_IsValid(int value) {
    return Proposal_State_IsValid(value);
  }
  static const State State_MIN =
    Proposal_State_State_MIN;
  static const State State_MAX =
    Proposal_State_State_MAX;
  static const int State_ARRAYSIZE =
    Proposal_State_State_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  State_descriptor() {
    return Proposal_State_descriptor();
  }
  static inline const ::std::string& State_Name(State value) {
    return Proposal_State_Name(value);
  }
  static inline bool State_Parse(const ::std::string& name,
      State* value) {
    return Proposal_State_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // string ID = 1;
  void clear_id();
  static const int kIDFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // string reference = 2;
  void clear_reference();
  static const int kReferenceFieldNumber = 2;
  const ::std::string& reference() const;
  void set_reference(const ::std::string& value);
  #if LANG_CXX11
  void set_reference(::std::string&& value);
  #endif
  void set_reference(const char* value);
  void set_reference(const char* value, size_t size);
  ::std::string* mutable_reference();
  ::std::string* release_reference();
  void set_allocated_reference(::std::string* reference);

  // string partyID = 3 [(.validator.field) = {
  void clear_partyid();
  static const int kPartyIDFieldNumber = 3;
  const ::std::string& partyid() const;
  void set_partyid(const ::std::string& value);
  #if LANG_CXX11
  void set_partyid(::std::string&& value);
  #endif
  void set_partyid(const char* value);
  void set_partyid(const char* value, size_t size);
  ::std::string* mutable_partyid();
  ::std::string* release_partyid();
  void set_allocated_partyid(::std::string* partyid);

  // .vega.ProposalTerms terms = 6 [(.validator.field) = {
  bool has_terms() const;
  void clear_terms();
  static const int kTermsFieldNumber = 6;
  const ::vega::ProposalTerms& terms() const;
  ::vega::ProposalTerms* release_terms();
  ::vega::ProposalTerms* mutable_terms();
  void set_allocated_terms(::vega::ProposalTerms* terms);

  // int64 timestamp = 5;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 5;
  ::google::protobuf::int64 timestamp() const;
  void set_timestamp(::google::protobuf::int64 value);

  // .vega.Proposal.State state = 4 [(.validator.field) = {
  void clear_state();
  static const int kStateFieldNumber = 4;
  ::vega::Proposal_State state() const;
  void set_state(::vega::Proposal_State value);

  // .vega.ProposalError reason = 7;
  void clear_reason();
  static const int kReasonFieldNumber = 7;
  ::vega::ProposalError reason() const;
  void set_reason(::vega::ProposalError value);

  // @@protoc_insertion_point(class_scope:vega.Proposal)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::internal::ArenaStringPtr reference_;
  ::google::protobuf::internal::ArenaStringPtr partyid_;
  ::vega::ProposalTerms* terms_;
  ::google::protobuf::int64 timestamp_;
  int state_;
  int reason_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fgovernance_2eproto;
};
// -------------------------------------------------------------------

class Vote :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vega.Vote) */ {
 public:
  Vote();
  virtual ~Vote();

  Vote(const Vote& from);

  inline Vote& operator=(const Vote& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Vote(Vote&& from) noexcept
    : Vote() {
    *this = ::std::move(from);
  }

  inline Vote& operator=(Vote&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Vote& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Vote* internal_default_instance() {
    return reinterpret_cast<const Vote*>(
               &_Vote_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(Vote* other);
  friend void swap(Vote& a, Vote& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Vote* New() const final {
    return CreateMaybeMessage<Vote>(nullptr);
  }

  Vote* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Vote>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Vote& from);
  void MergeFrom(const Vote& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vote* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Vote_Value Value;
  static const Value VALUE_UNSPECIFIED =
    Vote_Value_VALUE_UNSPECIFIED;
  static const Value VALUE_NO =
    Vote_Value_VALUE_NO;
  static const Value VALUE_YES =
    Vote_Value_VALUE_YES;
  static inline bool Value_IsValid(int value) {
    return Vote_Value_IsValid(value);
  }
  static const Value Value_MIN =
    Vote_Value_Value_MIN;
  static const Value Value_MAX =
    Vote_Value_Value_MAX;
  static const int Value_ARRAYSIZE =
    Vote_Value_Value_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Value_descriptor() {
    return Vote_Value_descriptor();
  }
  static inline const ::std::string& Value_Name(Value value) {
    return Vote_Value_Name(value);
  }
  static inline bool Value_Parse(const ::std::string& name,
      Value* value) {
    return Vote_Value_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // string partyID = 1 [(.validator.field) = {
  void clear_partyid();
  static const int kPartyIDFieldNumber = 1;
  const ::std::string& partyid() const;
  void set_partyid(const ::std::string& value);
  #if LANG_CXX11
  void set_partyid(::std::string&& value);
  #endif
  void set_partyid(const char* value);
  void set_partyid(const char* value, size_t size);
  ::std::string* mutable_partyid();
  ::std::string* release_partyid();
  void set_allocated_partyid(::std::string* partyid);

  // string proposalID = 3 [(.validator.field) = {
  void clear_proposalid();
  static const int kProposalIDFieldNumber = 3;
  const ::std::string& proposalid() const;
  void set_proposalid(const ::std::string& value);
  #if LANG_CXX11
  void set_proposalid(::std::string&& value);
  #endif
  void set_proposalid(const char* value);
  void set_proposalid(const char* value, size_t size);
  ::std::string* mutable_proposalid();
  ::std::string* release_proposalid();
  void set_allocated_proposalid(::std::string* proposalid);

  // int64 timestamp = 4;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 4;
  ::google::protobuf::int64 timestamp() const;
  void set_timestamp(::google::protobuf::int64 value);

  // .vega.Vote.Value value = 2 [(.validator.field) = {
  void clear_value();
  static const int kValueFieldNumber = 2;
  ::vega::Vote_Value value() const;
  void set_value(::vega::Vote_Value value);

  // @@protoc_insertion_point(class_scope:vega.Vote)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr partyid_;
  ::google::protobuf::internal::ArenaStringPtr proposalid_;
  ::google::protobuf::int64 timestamp_;
  int value_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fgovernance_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// NetworkConfiguration

// int64 minCloseInSeconds = 1;
inline void NetworkConfiguration::clear_mincloseinseconds() {
  mincloseinseconds_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 NetworkConfiguration::mincloseinseconds() const {
  // @@protoc_insertion_point(field_get:vega.NetworkConfiguration.minCloseInSeconds)
  return mincloseinseconds_;
}
inline void NetworkConfiguration::set_mincloseinseconds(::google::protobuf::int64 value) {

  mincloseinseconds_ = value;
  // @@protoc_insertion_point(field_set:vega.NetworkConfiguration.minCloseInSeconds)
}

// int64 maxCloseInSeconds = 2;
inline void NetworkConfiguration::clear_maxcloseinseconds() {
  maxcloseinseconds_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 NetworkConfiguration::maxcloseinseconds() const {
  // @@protoc_insertion_point(field_get:vega.NetworkConfiguration.maxCloseInSeconds)
  return maxcloseinseconds_;
}
inline void NetworkConfiguration::set_maxcloseinseconds(::google::protobuf::int64 value) {

  maxcloseinseconds_ = value;
  // @@protoc_insertion_point(field_set:vega.NetworkConfiguration.maxCloseInSeconds)
}

// int64 minEnactInSeconds = 3;
inline void NetworkConfiguration::clear_minenactinseconds() {
  minenactinseconds_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 NetworkConfiguration::minenactinseconds() const {
  // @@protoc_insertion_point(field_get:vega.NetworkConfiguration.minEnactInSeconds)
  return minenactinseconds_;
}
inline void NetworkConfiguration::set_minenactinseconds(::google::protobuf::int64 value) {

  minenactinseconds_ = value;
  // @@protoc_insertion_point(field_set:vega.NetworkConfiguration.minEnactInSeconds)
}

// int64 maxEnactInSeconds = 4;
inline void NetworkConfiguration::clear_maxenactinseconds() {
  maxenactinseconds_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 NetworkConfiguration::maxenactinseconds() const {
  // @@protoc_insertion_point(field_get:vega.NetworkConfiguration.maxEnactInSeconds)
  return maxenactinseconds_;
}
inline void NetworkConfiguration::set_maxenactinseconds(::google::protobuf::int64 value) {

  maxenactinseconds_ = value;
  // @@protoc_insertion_point(field_set:vega.NetworkConfiguration.maxEnactInSeconds)
}

// float requiredParticipation = 5;
inline void NetworkConfiguration::clear_requiredparticipation() {
  requiredparticipation_ = 0;
}
inline float NetworkConfiguration::requiredparticipation() const {
  // @@protoc_insertion_point(field_get:vega.NetworkConfiguration.requiredParticipation)
  return requiredparticipation_;
}
inline void NetworkConfiguration::set_requiredparticipation(float value) {

  requiredparticipation_ = value;
  // @@protoc_insertion_point(field_set:vega.NetworkConfiguration.requiredParticipation)
}

// float requiredMajority = 6;
inline void NetworkConfiguration::clear_requiredmajority() {
  requiredmajority_ = 0;
}
inline float NetworkConfiguration::requiredmajority() const {
  // @@protoc_insertion_point(field_get:vega.NetworkConfiguration.requiredMajority)
  return requiredmajority_;
}
inline void NetworkConfiguration::set_requiredmajority(float value) {

  requiredmajority_ = value;
  // @@protoc_insertion_point(field_set:vega.NetworkConfiguration.requiredMajority)
}

// float minProposerBalance = 7;
inline void NetworkConfiguration::clear_minproposerbalance() {
  minproposerbalance_ = 0;
}
inline float NetworkConfiguration::minproposerbalance() const {
  // @@protoc_insertion_point(field_get:vega.NetworkConfiguration.minProposerBalance)
  return minproposerbalance_;
}
inline void NetworkConfiguration::set_minproposerbalance(float value) {

  minproposerbalance_ = value;
  // @@protoc_insertion_point(field_set:vega.NetworkConfiguration.minProposerBalance)
}

// float minVoterBalance = 8;
inline void NetworkConfiguration::clear_minvoterbalance() {
  minvoterbalance_ = 0;
}
inline float NetworkConfiguration::minvoterbalance() const {
  // @@protoc_insertion_point(field_get:vega.NetworkConfiguration.minVoterBalance)
  return minvoterbalance_;
}
inline void NetworkConfiguration::set_minvoterbalance(float value) {

  minvoterbalance_ = value;
  // @@protoc_insertion_point(field_set:vega.NetworkConfiguration.minVoterBalance)
}

// .vega.ScalingFactors marginConfiguration = 9;
inline bool NetworkConfiguration::has_marginconfiguration() const {
  return this != internal_default_instance() && marginconfiguration_ != nullptr;
}
inline const ::vega::ScalingFactors& NetworkConfiguration::marginconfiguration() const {
  const ::vega::ScalingFactors* p = marginconfiguration_;
  // @@protoc_insertion_point(field_get:vega.NetworkConfiguration.marginConfiguration)
  return p != nullptr ? *p : *reinterpret_cast<const ::vega::ScalingFactors*>(
      &::vega::_ScalingFactors_default_instance_);
}
inline ::vega::ScalingFactors* NetworkConfiguration::release_marginconfiguration() {
  // @@protoc_insertion_point(field_release:vega.NetworkConfiguration.marginConfiguration)

  ::vega::ScalingFactors* temp = marginconfiguration_;
  marginconfiguration_ = nullptr;
  return temp;
}
inline ::vega::ScalingFactors* NetworkConfiguration::mutable_marginconfiguration() {

  if (marginconfiguration_ == nullptr) {
    auto* p = CreateMaybeMessage<::vega::ScalingFactors>(GetArenaNoVirtual());
    marginconfiguration_ = p;
  }
  // @@protoc_insertion_point(field_mutable:vega.NetworkConfiguration.marginConfiguration)
  return marginconfiguration_;
}
inline void NetworkConfiguration::set_allocated_marginconfiguration(::vega::ScalingFactors* marginconfiguration) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(marginconfiguration_);
  }
  if (marginconfiguration) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      marginconfiguration = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, marginconfiguration, submessage_arena);
    }

  } else {

  }
  marginconfiguration_ = marginconfiguration;
  // @@protoc_insertion_point(field_set_allocated:vega.NetworkConfiguration.marginConfiguration)
}

// .vega.FeeFactorsConfiguration feeFactorsConfiguration = 10;
inline bool NetworkConfiguration::has_feefactorsconfiguration() const {
  return this != internal_default_instance() && feefactorsconfiguration_ != nullptr;
}
inline void NetworkConfiguration::clear_feefactorsconfiguration() {
  if (GetArenaNoVirtual() == nullptr && feefactorsconfiguration_ != nullptr) {
    delete feefactorsconfiguration_;
  }
  feefactorsconfiguration_ = nullptr;
}
inline const ::vega::FeeFactorsConfiguration& NetworkConfiguration::feefactorsconfiguration() const {
  const ::vega::FeeFactorsConfiguration* p = feefactorsconfiguration_;
  // @@protoc_insertion_point(field_get:vega.NetworkConfiguration.feeFactorsConfiguration)
  return p != nullptr ? *p : *reinterpret_cast<const ::vega::FeeFactorsConfiguration*>(
      &::vega::_FeeFactorsConfiguration_default_instance_);
}
inline ::vega::FeeFactorsConfiguration* NetworkConfiguration::release_feefactorsconfiguration() {
  // @@protoc_insertion_point(field_release:vega.NetworkConfiguration.feeFactorsConfiguration)

  ::vega::FeeFactorsConfiguration* temp = feefactorsconfiguration_;
  feefactorsconfiguration_ = nullptr;
  return temp;
}
inline ::vega::FeeFactorsConfiguration* NetworkConfiguration::mutable_feefactorsconfiguration() {

  if (feefactorsconfiguration_ == nullptr) {
    auto* p = CreateMaybeMessage<::vega::FeeFactorsConfiguration>(GetArenaNoVirtual());
    feefactorsconfiguration_ = p;
  }
  // @@protoc_insertion_point(field_mutable:vega.NetworkConfiguration.feeFactorsConfiguration)
  return feefactorsconfiguration_;
}
inline void NetworkConfiguration::set_allocated_feefactorsconfiguration(::vega::FeeFactorsConfiguration* feefactorsconfiguration) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete feefactorsconfiguration_;
  }
  if (feefactorsconfiguration) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      feefactorsconfiguration = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, feefactorsconfiguration, submessage_arena);
    }

  } else {

  }
  feefactorsconfiguration_ = feefactorsconfiguration;
  // @@protoc_insertion_point(field_set_allocated:vega.NetworkConfiguration.feeFactorsConfiguration)
}

// -------------------------------------------------------------------

// FeeFactorsConfiguration

// string infrastructureFee = 1;
inline void FeeFactorsConfiguration::clear_infrastructurefee() {
  infrastructurefee_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& FeeFactorsConfiguration::infrastructurefee() const {
  // @@protoc_insertion_point(field_get:vega.FeeFactorsConfiguration.infrastructureFee)
  return infrastructurefee_.GetNoArena();
}
inline void FeeFactorsConfiguration::set_infrastructurefee(const ::std::string& value) {

  infrastructurefee_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vega.FeeFactorsConfiguration.infrastructureFee)
}
#if LANG_CXX11
inline void FeeFactorsConfiguration::set_infrastructurefee(::std::string&& value) {

  infrastructurefee_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vega.FeeFactorsConfiguration.infrastructureFee)
}
#endif
inline void FeeFactorsConfiguration::set_infrastructurefee(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  infrastructurefee_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vega.FeeFactorsConfiguration.infrastructureFee)
}
inline void FeeFactorsConfiguration::set_infrastructurefee(const char* value, size_t size) {

  infrastructurefee_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vega.FeeFactorsConfiguration.infrastructureFee)
}
inline ::std::string* FeeFactorsConfiguration::mutable_infrastructurefee() {

  // @@protoc_insertion_point(field_mutable:vega.FeeFactorsConfiguration.infrastructureFee)
  return infrastructurefee_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FeeFactorsConfiguration::release_infrastructurefee() {
  // @@protoc_insertion_point(field_release:vega.FeeFactorsConfiguration.infrastructureFee)

  return infrastructurefee_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FeeFactorsConfiguration::set_allocated_infrastructurefee(::std::string* infrastructurefee) {
  if (infrastructurefee != nullptr) {

  } else {

  }
  infrastructurefee_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), infrastructurefee);
  // @@protoc_insertion_point(field_set_allocated:vega.FeeFactorsConfiguration.infrastructureFee)
}

// string makerFee = 2;
inline void FeeFactorsConfiguration::clear_makerfee() {
  makerfee_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& FeeFactorsConfiguration::makerfee() const {
  // @@protoc_insertion_point(field_get:vega.FeeFactorsConfiguration.makerFee)
  return makerfee_.GetNoArena();
}
inline void FeeFactorsConfiguration::set_makerfee(const ::std::string& value) {

  makerfee_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vega.FeeFactorsConfiguration.makerFee)
}
#if LANG_CXX11
inline void FeeFactorsConfiguration::set_makerfee(::std::string&& value) {

  makerfee_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vega.FeeFactorsConfiguration.makerFee)
}
#endif
inline void FeeFactorsConfiguration::set_makerfee(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  makerfee_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vega.FeeFactorsConfiguration.makerFee)
}
inline void FeeFactorsConfiguration::set_makerfee(const char* value, size_t size) {

  makerfee_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vega.FeeFactorsConfiguration.makerFee)
}
inline ::std::string* FeeFactorsConfiguration::mutable_makerfee() {

  // @@protoc_insertion_point(field_mutable:vega.FeeFactorsConfiguration.makerFee)
  return makerfee_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FeeFactorsConfiguration::release_makerfee() {
  // @@protoc_insertion_point(field_release:vega.FeeFactorsConfiguration.makerFee)

  return makerfee_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FeeFactorsConfiguration::set_allocated_makerfee(::std::string* makerfee) {
  if (makerfee != nullptr) {

  } else {

  }
  makerfee_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), makerfee);
  // @@protoc_insertion_point(field_set_allocated:vega.FeeFactorsConfiguration.makerFee)
}

// string liquidityFee = 3;
inline void FeeFactorsConfiguration::clear_liquidityfee() {
  liquidityfee_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& FeeFactorsConfiguration::liquidityfee() const {
  // @@protoc_insertion_point(field_get:vega.FeeFactorsConfiguration.liquidityFee)
  return liquidityfee_.GetNoArena();
}
inline void FeeFactorsConfiguration::set_liquidityfee(const ::std::string& value) {

  liquidityfee_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vega.FeeFactorsConfiguration.liquidityFee)
}
#if LANG_CXX11
inline void FeeFactorsConfiguration::set_liquidityfee(::std::string&& value) {

  liquidityfee_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vega.FeeFactorsConfiguration.liquidityFee)
}
#endif
inline void FeeFactorsConfiguration::set_liquidityfee(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  liquidityfee_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vega.FeeFactorsConfiguration.liquidityFee)
}
inline void FeeFactorsConfiguration::set_liquidityfee(const char* value, size_t size) {

  liquidityfee_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vega.FeeFactorsConfiguration.liquidityFee)
}
inline ::std::string* FeeFactorsConfiguration::mutable_liquidityfee() {

  // @@protoc_insertion_point(field_mutable:vega.FeeFactorsConfiguration.liquidityFee)
  return liquidityfee_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FeeFactorsConfiguration::release_liquidityfee() {
  // @@protoc_insertion_point(field_release:vega.FeeFactorsConfiguration.liquidityFee)

  return liquidityfee_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FeeFactorsConfiguration::set_allocated_liquidityfee(::std::string* liquidityfee) {
  if (liquidityfee != nullptr) {

  } else {

  }
  liquidityfee_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), liquidityfee);
  // @@protoc_insertion_point(field_set_allocated:vega.FeeFactorsConfiguration.liquidityFee)
}

// -------------------------------------------------------------------

// UpdateMarket

// -------------------------------------------------------------------

// FutureProduct

// string maturity = 1 [(.validator.field) = {
inline void FutureProduct::clear_maturity() {
  maturity_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& FutureProduct::maturity() const {
  // @@protoc_insertion_point(field_get:vega.FutureProduct.maturity)
  return maturity_.GetNoArena();
}
inline void FutureProduct::set_maturity(const ::std::string& value) {

  maturity_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vega.FutureProduct.maturity)
}
#if LANG_CXX11
inline void FutureProduct::set_maturity(::std::string&& value) {

  maturity_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vega.FutureProduct.maturity)
}
#endif
inline void FutureProduct::set_maturity(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  maturity_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vega.FutureProduct.maturity)
}
inline void FutureProduct::set_maturity(const char* value, size_t size) {

  maturity_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vega.FutureProduct.maturity)
}
inline ::std::string* FutureProduct::mutable_maturity() {

  // @@protoc_insertion_point(field_mutable:vega.FutureProduct.maturity)
  return maturity_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FutureProduct::release_maturity() {
  // @@protoc_insertion_point(field_release:vega.FutureProduct.maturity)

  return maturity_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FutureProduct::set_allocated_maturity(::std::string* maturity) {
  if (maturity != nullptr) {

  } else {

  }
  maturity_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), maturity);
  // @@protoc_insertion_point(field_set_allocated:vega.FutureProduct.maturity)
}

// string asset = 2 [(.validator.field) = {
inline void FutureProduct::clear_asset() {
  asset_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& FutureProduct::asset() const {
  // @@protoc_insertion_point(field_get:vega.FutureProduct.asset)
  return asset_.GetNoArena();
}
inline void FutureProduct::set_asset(const ::std::string& value) {

  asset_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vega.FutureProduct.asset)
}
#if LANG_CXX11
inline void FutureProduct::set_asset(::std::string&& value) {

  asset_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vega.FutureProduct.asset)
}
#endif
inline void FutureProduct::set_asset(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  asset_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vega.FutureProduct.asset)
}
inline void FutureProduct::set_asset(const char* value, size_t size) {

  asset_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vega.FutureProduct.asset)
}
inline ::std::string* FutureProduct::mutable_asset() {

  // @@protoc_insertion_point(field_mutable:vega.FutureProduct.asset)
  return asset_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FutureProduct::release_asset() {
  // @@protoc_insertion_point(field_release:vega.FutureProduct.asset)

  return asset_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FutureProduct::set_allocated_asset(::std::string* asset) {
  if (asset != nullptr) {

  } else {

  }
  asset_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), asset);
  // @@protoc_insertion_point(field_set_allocated:vega.FutureProduct.asset)
}

// -------------------------------------------------------------------

// InstrumentConfiguration

// string name = 1 [(.validator.field) = {
inline void InstrumentConfiguration::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& InstrumentConfiguration::name() const {
  // @@protoc_insertion_point(field_get:vega.InstrumentConfiguration.name)
  return name_.GetNoArena();
}
inline void InstrumentConfiguration::set_name(const ::std::string& value) {

  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vega.InstrumentConfiguration.name)
}
#if LANG_CXX11
inline void InstrumentConfiguration::set_name(::std::string&& value) {

  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vega.InstrumentConfiguration.name)
}
#endif
inline void InstrumentConfiguration::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vega.InstrumentConfiguration.name)
}
inline void InstrumentConfiguration::set_name(const char* value, size_t size) {

  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vega.InstrumentConfiguration.name)
}
inline ::std::string* InstrumentConfiguration::mutable_name() {

  // @@protoc_insertion_point(field_mutable:vega.InstrumentConfiguration.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* InstrumentConfiguration::release_name() {
  // @@protoc_insertion_point(field_release:vega.InstrumentConfiguration.name)

  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InstrumentConfiguration::set_allocated_name(::std::string* name) {
  if (name != nullptr) {

  } else {

  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:vega.InstrumentConfiguration.name)
}

// string code = 2 [(.validator.field) = {
inline void InstrumentConfiguration::clear_code() {
  code_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& InstrumentConfiguration::code() const {
  // @@protoc_insertion_point(field_get:vega.InstrumentConfiguration.code)
  return code_.GetNoArena();
}
inline void InstrumentConfiguration::set_code(const ::std::string& value) {

  code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vega.InstrumentConfiguration.code)
}
#if LANG_CXX11
inline void InstrumentConfiguration::set_code(::std::string&& value) {

  code_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vega.InstrumentConfiguration.code)
}
#endif
inline void InstrumentConfiguration::set_code(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vega.InstrumentConfiguration.code)
}
inline void InstrumentConfiguration::set_code(const char* value, size_t size) {

  code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vega.InstrumentConfiguration.code)
}
inline ::std::string* InstrumentConfiguration::mutable_code() {

  // @@protoc_insertion_point(field_mutable:vega.InstrumentConfiguration.code)
  return code_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* InstrumentConfiguration::release_code() {
  // @@protoc_insertion_point(field_release:vega.InstrumentConfiguration.code)

  return code_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InstrumentConfiguration::set_allocated_code(::std::string* code) {
  if (code != nullptr) {

  } else {

  }
  code_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), code);
  // @@protoc_insertion_point(field_set_allocated:vega.InstrumentConfiguration.code)
}

// string baseName = 3 [(.validator.field) = {
inline void InstrumentConfiguration::clear_basename() {
  basename_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& InstrumentConfiguration::basename() const {
  // @@protoc_insertion_point(field_get:vega.InstrumentConfiguration.baseName)
  return basename_.GetNoArena();
}
inline void InstrumentConfiguration::set_basename(const ::std::string& value) {

  basename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vega.InstrumentConfiguration.baseName)
}
#if LANG_CXX11
inline void InstrumentConfiguration::set_basename(::std::string&& value) {

  basename_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vega.InstrumentConfiguration.baseName)
}
#endif
inline void InstrumentConfiguration::set_basename(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  basename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vega.InstrumentConfiguration.baseName)
}
inline void InstrumentConfiguration::set_basename(const char* value, size_t size) {

  basename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vega.InstrumentConfiguration.baseName)
}
inline ::std::string* InstrumentConfiguration::mutable_basename() {

  // @@protoc_insertion_point(field_mutable:vega.InstrumentConfiguration.baseName)
  return basename_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* InstrumentConfiguration::release_basename() {
  // @@protoc_insertion_point(field_release:vega.InstrumentConfiguration.baseName)

  return basename_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InstrumentConfiguration::set_allocated_basename(::std::string* basename) {
  if (basename != nullptr) {

  } else {

  }
  basename_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), basename);
  // @@protoc_insertion_point(field_set_allocated:vega.InstrumentConfiguration.baseName)
}

// string quoteName = 4 [(.validator.field) = {
inline void InstrumentConfiguration::clear_quotename() {
  quotename_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& InstrumentConfiguration::quotename() const {
  // @@protoc_insertion_point(field_get:vega.InstrumentConfiguration.quoteName)
  return quotename_.GetNoArena();
}
inline void InstrumentConfiguration::set_quotename(const ::std::string& value) {

  quotename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vega.InstrumentConfiguration.quoteName)
}
#if LANG_CXX11
inline void InstrumentConfiguration::set_quotename(::std::string&& value) {

  quotename_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vega.InstrumentConfiguration.quoteName)
}
#endif
inline void InstrumentConfiguration::set_quotename(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  quotename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vega.InstrumentConfiguration.quoteName)
}
inline void InstrumentConfiguration::set_quotename(const char* value, size_t size) {

  quotename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vega.InstrumentConfiguration.quoteName)
}
inline ::std::string* InstrumentConfiguration::mutable_quotename() {

  // @@protoc_insertion_point(field_mutable:vega.InstrumentConfiguration.quoteName)
  return quotename_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* InstrumentConfiguration::release_quotename() {
  // @@protoc_insertion_point(field_release:vega.InstrumentConfiguration.quoteName)

  return quotename_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InstrumentConfiguration::set_allocated_quotename(::std::string* quotename) {
  if (quotename != nullptr) {

  } else {

  }
  quotename_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), quotename);
  // @@protoc_insertion_point(field_set_allocated:vega.InstrumentConfiguration.quoteName)
}

// .vega.FutureProduct future = 100;
inline bool InstrumentConfiguration::has_future() const {
  return product_case() == kFuture;
}
inline void InstrumentConfiguration::set_has_future() {
  _oneof_case_[0] = kFuture;
}
inline void InstrumentConfiguration::clear_future() {
  if (has_future()) {
    delete product_.future_;
    clear_has_product();
  }
}
inline ::vega::FutureProduct* InstrumentConfiguration::release_future() {
  // @@protoc_insertion_point(field_release:vega.InstrumentConfiguration.future)
  if (has_future()) {
    clear_has_product();
      ::vega::FutureProduct* temp = product_.future_;
    product_.future_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vega::FutureProduct& InstrumentConfiguration::future() const {
  // @@protoc_insertion_point(field_get:vega.InstrumentConfiguration.future)
  return has_future()
      ? *product_.future_
      : *reinterpret_cast< ::vega::FutureProduct*>(&::vega::_FutureProduct_default_instance_);
}
inline ::vega::FutureProduct* InstrumentConfiguration::mutable_future() {
  if (!has_future()) {
    clear_product();
    set_has_future();
    product_.future_ = CreateMaybeMessage< ::vega::FutureProduct >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:vega.InstrumentConfiguration.future)
  return product_.future_;
}

inline bool InstrumentConfiguration::has_product() const {
  return product_case() != PRODUCT_NOT_SET;
}
inline void InstrumentConfiguration::clear_has_product() {
  _oneof_case_[0] = PRODUCT_NOT_SET;
}
inline InstrumentConfiguration::ProductCase InstrumentConfiguration::product_case() const {
  return InstrumentConfiguration::ProductCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// NewMarketConfiguration

// .vega.InstrumentConfiguration instrument = 1 [(.validator.field) = {
inline bool NewMarketConfiguration::has_instrument() const {
  return this != internal_default_instance() && instrument_ != nullptr;
}
inline void NewMarketConfiguration::clear_instrument() {
  if (GetArenaNoVirtual() == nullptr && instrument_ != nullptr) {
    delete instrument_;
  }
  instrument_ = nullptr;
}
inline const ::vega::InstrumentConfiguration& NewMarketConfiguration::instrument() const {
  const ::vega::InstrumentConfiguration* p = instrument_;
  // @@protoc_insertion_point(field_get:vega.NewMarketConfiguration.instrument)
  return p != nullptr ? *p : *reinterpret_cast<const ::vega::InstrumentConfiguration*>(
      &::vega::_InstrumentConfiguration_default_instance_);
}
inline ::vega::InstrumentConfiguration* NewMarketConfiguration::release_instrument() {
  // @@protoc_insertion_point(field_release:vega.NewMarketConfiguration.instrument)

  ::vega::InstrumentConfiguration* temp = instrument_;
  instrument_ = nullptr;
  return temp;
}
inline ::vega::InstrumentConfiguration* NewMarketConfiguration::mutable_instrument() {

  if (instrument_ == nullptr) {
    auto* p = CreateMaybeMessage<::vega::InstrumentConfiguration>(GetArenaNoVirtual());
    instrument_ = p;
  }
  // @@protoc_insertion_point(field_mutable:vega.NewMarketConfiguration.instrument)
  return instrument_;
}
inline void NewMarketConfiguration::set_allocated_instrument(::vega::InstrumentConfiguration* instrument) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete instrument_;
  }
  if (instrument) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      instrument = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, instrument, submessage_arena);
    }

  } else {

  }
  instrument_ = instrument;
  // @@protoc_insertion_point(field_set_allocated:vega.NewMarketConfiguration.instrument)
}

// uint64 decimalPlaces = 2 [(.validator.field) = {
inline void NewMarketConfiguration::clear_decimalplaces() {
  decimalplaces_ = PROTOBUF_ULONGLONG(0);
}
inline ::google::protobuf::uint64 NewMarketConfiguration::decimalplaces() const {
  // @@protoc_insertion_point(field_get:vega.NewMarketConfiguration.decimalPlaces)
  return decimalplaces_;
}
inline void NewMarketConfiguration::set_decimalplaces(::google::protobuf::uint64 value) {

  decimalplaces_ = value;
  // @@protoc_insertion_point(field_set:vega.NewMarketConfiguration.decimalPlaces)
}

// repeated string metadata = 3;
inline int NewMarketConfiguration::metadata_size() const {
  return metadata_.size();
}
inline void NewMarketConfiguration::clear_metadata() {
  metadata_.Clear();
}
inline const ::std::string& NewMarketConfiguration::metadata(int index) const {
  // @@protoc_insertion_point(field_get:vega.NewMarketConfiguration.metadata)
  return metadata_.Get(index);
}
inline ::std::string* NewMarketConfiguration::mutable_metadata(int index) {
  // @@protoc_insertion_point(field_mutable:vega.NewMarketConfiguration.metadata)
  return metadata_.Mutable(index);
}
inline void NewMarketConfiguration::set_metadata(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:vega.NewMarketConfiguration.metadata)
  metadata_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void NewMarketConfiguration::set_metadata(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:vega.NewMarketConfiguration.metadata)
  metadata_.Mutable(index)->assign(std::move(value));
}
#endif
inline void NewMarketConfiguration::set_metadata(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  metadata_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:vega.NewMarketConfiguration.metadata)
}
inline void NewMarketConfiguration::set_metadata(int index, const char* value, size_t size) {
  metadata_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:vega.NewMarketConfiguration.metadata)
}
inline ::std::string* NewMarketConfiguration::add_metadata() {
  // @@protoc_insertion_point(field_add_mutable:vega.NewMarketConfiguration.metadata)
  return metadata_.Add();
}
inline void NewMarketConfiguration::add_metadata(const ::std::string& value) {
  metadata_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:vega.NewMarketConfiguration.metadata)
}
#if LANG_CXX11
inline void NewMarketConfiguration::add_metadata(::std::string&& value) {
  metadata_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:vega.NewMarketConfiguration.metadata)
}
#endif
inline void NewMarketConfiguration::add_metadata(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  metadata_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:vega.NewMarketConfiguration.metadata)
}
inline void NewMarketConfiguration::add_metadata(const char* value, size_t size) {
  metadata_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:vega.NewMarketConfiguration.metadata)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
NewMarketConfiguration::metadata() const {
  // @@protoc_insertion_point(field_list:vega.NewMarketConfiguration.metadata)
  return metadata_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>*
NewMarketConfiguration::mutable_metadata() {
  // @@protoc_insertion_point(field_mutable_list:vega.NewMarketConfiguration.metadata)
  return &metadata_;
}

// int64 openingAuctionDuration = 4;
inline void NewMarketConfiguration::clear_openingauctionduration() {
  openingauctionduration_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 NewMarketConfiguration::openingauctionduration() const {
  // @@protoc_insertion_point(field_get:vega.NewMarketConfiguration.openingAuctionDuration)
  return openingauctionduration_;
}
inline void NewMarketConfiguration::set_openingauctionduration(::google::protobuf::int64 value) {

  openingauctionduration_ = value;
  // @@protoc_insertion_point(field_set:vega.NewMarketConfiguration.openingAuctionDuration)
}

// .vega.SimpleModelParams simple = 100;
inline bool NewMarketConfiguration::has_simple() const {
  return riskParameters_case() == kSimple;
}
inline void NewMarketConfiguration::set_has_simple() {
  _oneof_case_[0] = kSimple;
}
inline ::vega::SimpleModelParams* NewMarketConfiguration::release_simple() {
  // @@protoc_insertion_point(field_release:vega.NewMarketConfiguration.simple)
  if (has_simple()) {
    clear_has_riskParameters();
      ::vega::SimpleModelParams* temp = riskParameters_.simple_;
    riskParameters_.simple_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vega::SimpleModelParams& NewMarketConfiguration::simple() const {
  // @@protoc_insertion_point(field_get:vega.NewMarketConfiguration.simple)
  return has_simple()
      ? *riskParameters_.simple_
      : *reinterpret_cast< ::vega::SimpleModelParams*>(&::vega::_SimpleModelParams_default_instance_);
}
inline ::vega::SimpleModelParams* NewMarketConfiguration::mutable_simple() {
  if (!has_simple()) {
    clear_riskParameters();
    set_has_simple();
    riskParameters_.simple_ = CreateMaybeMessage< ::vega::SimpleModelParams >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:vega.NewMarketConfiguration.simple)
  return riskParameters_.simple_;
}

// .vega.LogNormalRiskModel logNormal = 101;
inline bool NewMarketConfiguration::has_lognormal() const {
  return riskParameters_case() == kLogNormal;
}
inline void NewMarketConfiguration::set_has_lognormal() {
  _oneof_case_[0] = kLogNormal;
}
inline ::vega::LogNormalRiskModel* NewMarketConfiguration::release_lognormal() {
  // @@protoc_insertion_point(field_release:vega.NewMarketConfiguration.logNormal)
  if (has_lognormal()) {
    clear_has_riskParameters();
      ::vega::LogNormalRiskModel* temp = riskParameters_.lognormal_;
    riskParameters_.lognormal_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vega::LogNormalRiskModel& NewMarketConfiguration::lognormal() const {
  // @@protoc_insertion_point(field_get:vega.NewMarketConfiguration.logNormal)
  return has_lognormal()
      ? *riskParameters_.lognormal_
      : *reinterpret_cast< ::vega::LogNormalRiskModel*>(&::vega::_LogNormalRiskModel_default_instance_);
}
inline ::vega::LogNormalRiskModel* NewMarketConfiguration::mutable_lognormal() {
  if (!has_lognormal()) {
    clear_riskParameters();
    set_has_lognormal();
    riskParameters_.lognormal_ = CreateMaybeMessage< ::vega::LogNormalRiskModel >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:vega.NewMarketConfiguration.logNormal)
  return riskParameters_.lognormal_;
}

// .vega.ContinuousTrading continuous = 200;
inline bool NewMarketConfiguration::has_continuous() const {
  return tradingMode_case() == kContinuous;
}
inline void NewMarketConfiguration::set_has_continuous() {
  _oneof_case_[1] = kContinuous;
}
inline ::vega::ContinuousTrading* NewMarketConfiguration::release_continuous() {
  // @@protoc_insertion_point(field_release:vega.NewMarketConfiguration.continuous)
  if (has_continuous()) {
    clear_has_tradingMode();
      ::vega::ContinuousTrading* temp = tradingMode_.continuous_;
    tradingMode_.continuous_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vega::ContinuousTrading& NewMarketConfiguration::continuous() const {
  // @@protoc_insertion_point(field_get:vega.NewMarketConfiguration.continuous)
  return has_continuous()
      ? *tradingMode_.continuous_
      : *reinterpret_cast< ::vega::ContinuousTrading*>(&::vega::_ContinuousTrading_default_instance_);
}
inline ::vega::ContinuousTrading* NewMarketConfiguration::mutable_continuous() {
  if (!has_continuous()) {
    clear_tradingMode();
    set_has_continuous();
    tradingMode_.continuous_ = CreateMaybeMessage< ::vega::ContinuousTrading >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:vega.NewMarketConfiguration.continuous)
  return tradingMode_.continuous_;
}

// .vega.DiscreteTrading discrete = 201;
inline bool NewMarketConfiguration::has_discrete() const {
  return tradingMode_case() == kDiscrete;
}
inline void NewMarketConfiguration::set_has_discrete() {
  _oneof_case_[1] = kDiscrete;
}
inline ::vega::DiscreteTrading* NewMarketConfiguration::release_discrete() {
  // @@protoc_insertion_point(field_release:vega.NewMarketConfiguration.discrete)
  if (has_discrete()) {
    clear_has_tradingMode();
      ::vega::DiscreteTrading* temp = tradingMode_.discrete_;
    tradingMode_.discrete_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vega::DiscreteTrading& NewMarketConfiguration::discrete() const {
  // @@protoc_insertion_point(field_get:vega.NewMarketConfiguration.discrete)
  return has_discrete()
      ? *tradingMode_.discrete_
      : *reinterpret_cast< ::vega::DiscreteTrading*>(&::vega::_DiscreteTrading_default_instance_);
}
inline ::vega::DiscreteTrading* NewMarketConfiguration::mutable_discrete() {
  if (!has_discrete()) {
    clear_tradingMode();
    set_has_discrete();
    tradingMode_.discrete_ = CreateMaybeMessage< ::vega::DiscreteTrading >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:vega.NewMarketConfiguration.discrete)
  return tradingMode_.discrete_;
}

inline bool NewMarketConfiguration::has_riskParameters() const {
  return riskParameters_case() != RISKPARAMETERS_NOT_SET;
}
inline void NewMarketConfiguration::clear_has_riskParameters() {
  _oneof_case_[0] = RISKPARAMETERS_NOT_SET;
}
inline bool NewMarketConfiguration::has_tradingMode() const {
  return tradingMode_case() != TRADINGMODE_NOT_SET;
}
inline void NewMarketConfiguration::clear_has_tradingMode() {
  _oneof_case_[1] = TRADINGMODE_NOT_SET;
}
inline NewMarketConfiguration::RiskParametersCase NewMarketConfiguration::riskParameters_case() const {
  return NewMarketConfiguration::RiskParametersCase(_oneof_case_[0]);
}
inline NewMarketConfiguration::TradingModeCase NewMarketConfiguration::tradingMode_case() const {
  return NewMarketConfiguration::TradingModeCase(_oneof_case_[1]);
}
// -------------------------------------------------------------------

// NewMarket

// .vega.NewMarketConfiguration changes = 1 [(.validator.field) = {
inline bool NewMarket::has_changes() const {
  return this != internal_default_instance() && changes_ != nullptr;
}
inline void NewMarket::clear_changes() {
  if (GetArenaNoVirtual() == nullptr && changes_ != nullptr) {
    delete changes_;
  }
  changes_ = nullptr;
}
inline const ::vega::NewMarketConfiguration& NewMarket::changes() const {
  const ::vega::NewMarketConfiguration* p = changes_;
  // @@protoc_insertion_point(field_get:vega.NewMarket.changes)
  return p != nullptr ? *p : *reinterpret_cast<const ::vega::NewMarketConfiguration*>(
      &::vega::_NewMarketConfiguration_default_instance_);
}
inline ::vega::NewMarketConfiguration* NewMarket::release_changes() {
  // @@protoc_insertion_point(field_release:vega.NewMarket.changes)

  ::vega::NewMarketConfiguration* temp = changes_;
  changes_ = nullptr;
  return temp;
}
inline ::vega::NewMarketConfiguration* NewMarket::mutable_changes() {

  if (changes_ == nullptr) {
    auto* p = CreateMaybeMessage<::vega::NewMarketConfiguration>(GetArenaNoVirtual());
    changes_ = p;
  }
  // @@protoc_insertion_point(field_mutable:vega.NewMarket.changes)
  return changes_;
}
inline void NewMarket::set_allocated_changes(::vega::NewMarketConfiguration* changes) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete changes_;
  }
  if (changes) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      changes = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, changes, submessage_arena);
    }

  } else {

  }
  changes_ = changes;
  // @@protoc_insertion_point(field_set_allocated:vega.NewMarket.changes)
}

// -------------------------------------------------------------------

// UpdateNetwork

// .vega.NetworkConfiguration changes = 1 [(.validator.field) = {
inline bool UpdateNetwork::has_changes() const {
  return this != internal_default_instance() && changes_ != nullptr;
}
inline void UpdateNetwork::clear_changes() {
  if (GetArenaNoVirtual() == nullptr && changes_ != nullptr) {
    delete changes_;
  }
  changes_ = nullptr;
}
inline const ::vega::NetworkConfiguration& UpdateNetwork::changes() const {
  const ::vega::NetworkConfiguration* p = changes_;
  // @@protoc_insertion_point(field_get:vega.UpdateNetwork.changes)
  return p != nullptr ? *p : *reinterpret_cast<const ::vega::NetworkConfiguration*>(
      &::vega::_NetworkConfiguration_default_instance_);
}
inline ::vega::NetworkConfiguration* UpdateNetwork::release_changes() {
  // @@protoc_insertion_point(field_release:vega.UpdateNetwork.changes)

  ::vega::NetworkConfiguration* temp = changes_;
  changes_ = nullptr;
  return temp;
}
inline ::vega::NetworkConfiguration* UpdateNetwork::mutable_changes() {

  if (changes_ == nullptr) {
    auto* p = CreateMaybeMessage<::vega::NetworkConfiguration>(GetArenaNoVirtual());
    changes_ = p;
  }
  // @@protoc_insertion_point(field_mutable:vega.UpdateNetwork.changes)
  return changes_;
}
inline void UpdateNetwork::set_allocated_changes(::vega::NetworkConfiguration* changes) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete changes_;
  }
  if (changes) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      changes = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, changes, submessage_arena);
    }

  } else {

  }
  changes_ = changes;
  // @@protoc_insertion_point(field_set_allocated:vega.UpdateNetwork.changes)
}

// -------------------------------------------------------------------

// NewAsset

// .vega.AssetSource changes = 1 [(.validator.field) = {
inline bool NewAsset::has_changes() const {
  return this != internal_default_instance() && changes_ != nullptr;
}
inline const ::vega::AssetSource& NewAsset::changes() const {
  const ::vega::AssetSource* p = changes_;
  // @@protoc_insertion_point(field_get:vega.NewAsset.changes)
  return p != nullptr ? *p : *reinterpret_cast<const ::vega::AssetSource*>(
      &::vega::_AssetSource_default_instance_);
}
inline ::vega::AssetSource* NewAsset::release_changes() {
  // @@protoc_insertion_point(field_release:vega.NewAsset.changes)

  ::vega::AssetSource* temp = changes_;
  changes_ = nullptr;
  return temp;
}
inline ::vega::AssetSource* NewAsset::mutable_changes() {

  if (changes_ == nullptr) {
    auto* p = CreateMaybeMessage<::vega::AssetSource>(GetArenaNoVirtual());
    changes_ = p;
  }
  // @@protoc_insertion_point(field_mutable:vega.NewAsset.changes)
  return changes_;
}
inline void NewAsset::set_allocated_changes(::vega::AssetSource* changes) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(changes_);
  }
  if (changes) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      changes = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, changes, submessage_arena);
    }

  } else {

  }
  changes_ = changes;
  // @@protoc_insertion_point(field_set_allocated:vega.NewAsset.changes)
}

// -------------------------------------------------------------------

// ProposalTerms

// int64 closingTimestamp = 1 [(.validator.field) = {
inline void ProposalTerms::clear_closingtimestamp() {
  closingtimestamp_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 ProposalTerms::closingtimestamp() const {
  // @@protoc_insertion_point(field_get:vega.ProposalTerms.closingTimestamp)
  return closingtimestamp_;
}
inline void ProposalTerms::set_closingtimestamp(::google::protobuf::int64 value) {

  closingtimestamp_ = value;
  // @@protoc_insertion_point(field_set:vega.ProposalTerms.closingTimestamp)
}

// int64 enactmentTimestamp = 2 [(.validator.field) = {
inline void ProposalTerms::clear_enactmenttimestamp() {
  enactmenttimestamp_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 ProposalTerms::enactmenttimestamp() const {
  // @@protoc_insertion_point(field_get:vega.ProposalTerms.enactmentTimestamp)
  return enactmenttimestamp_;
}
inline void ProposalTerms::set_enactmenttimestamp(::google::protobuf::int64 value) {

  enactmenttimestamp_ = value;
  // @@protoc_insertion_point(field_set:vega.ProposalTerms.enactmentTimestamp)
}

// int64 validationTimestamp = 3;
inline void ProposalTerms::clear_validationtimestamp() {
  validationtimestamp_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 ProposalTerms::validationtimestamp() const {
  // @@protoc_insertion_point(field_get:vega.ProposalTerms.validationTimestamp)
  return validationtimestamp_;
}
inline void ProposalTerms::set_validationtimestamp(::google::protobuf::int64 value) {

  validationtimestamp_ = value;
  // @@protoc_insertion_point(field_set:vega.ProposalTerms.validationTimestamp)
}

// .vega.UpdateMarket updateMarket = 101;
inline bool ProposalTerms::has_updatemarket() const {
  return change_case() == kUpdateMarket;
}
inline void ProposalTerms::set_has_updatemarket() {
  _oneof_case_[0] = kUpdateMarket;
}
inline void ProposalTerms::clear_updatemarket() {
  if (has_updatemarket()) {
    delete change_.updatemarket_;
    clear_has_change();
  }
}
inline ::vega::UpdateMarket* ProposalTerms::release_updatemarket() {
  // @@protoc_insertion_point(field_release:vega.ProposalTerms.updateMarket)
  if (has_updatemarket()) {
    clear_has_change();
      ::vega::UpdateMarket* temp = change_.updatemarket_;
    change_.updatemarket_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vega::UpdateMarket& ProposalTerms::updatemarket() const {
  // @@protoc_insertion_point(field_get:vega.ProposalTerms.updateMarket)
  return has_updatemarket()
      ? *change_.updatemarket_
      : *reinterpret_cast< ::vega::UpdateMarket*>(&::vega::_UpdateMarket_default_instance_);
}
inline ::vega::UpdateMarket* ProposalTerms::mutable_updatemarket() {
  if (!has_updatemarket()) {
    clear_change();
    set_has_updatemarket();
    change_.updatemarket_ = CreateMaybeMessage< ::vega::UpdateMarket >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:vega.ProposalTerms.updateMarket)
  return change_.updatemarket_;
}

// .vega.NewMarket newMarket = 102;
inline bool ProposalTerms::has_newmarket() const {
  return change_case() == kNewMarket;
}
inline void ProposalTerms::set_has_newmarket() {
  _oneof_case_[0] = kNewMarket;
}
inline void ProposalTerms::clear_newmarket() {
  if (has_newmarket()) {
    delete change_.newmarket_;
    clear_has_change();
  }
}
inline ::vega::NewMarket* ProposalTerms::release_newmarket() {
  // @@protoc_insertion_point(field_release:vega.ProposalTerms.newMarket)
  if (has_newmarket()) {
    clear_has_change();
      ::vega::NewMarket* temp = change_.newmarket_;
    change_.newmarket_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vega::NewMarket& ProposalTerms::newmarket() const {
  // @@protoc_insertion_point(field_get:vega.ProposalTerms.newMarket)
  return has_newmarket()
      ? *change_.newmarket_
      : *reinterpret_cast< ::vega::NewMarket*>(&::vega::_NewMarket_default_instance_);
}
inline ::vega::NewMarket* ProposalTerms::mutable_newmarket() {
  if (!has_newmarket()) {
    clear_change();
    set_has_newmarket();
    change_.newmarket_ = CreateMaybeMessage< ::vega::NewMarket >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:vega.ProposalTerms.newMarket)
  return change_.newmarket_;
}

// .vega.UpdateNetwork updateNetwork = 103;
inline bool ProposalTerms::has_updatenetwork() const {
  return change_case() == kUpdateNetwork;
}
inline void ProposalTerms::set_has_updatenetwork() {
  _oneof_case_[0] = kUpdateNetwork;
}
inline void ProposalTerms::clear_updatenetwork() {
  if (has_updatenetwork()) {
    delete change_.updatenetwork_;
    clear_has_change();
  }
}
inline ::vega::UpdateNetwork* ProposalTerms::release_updatenetwork() {
  // @@protoc_insertion_point(field_release:vega.ProposalTerms.updateNetwork)
  if (has_updatenetwork()) {
    clear_has_change();
      ::vega::UpdateNetwork* temp = change_.updatenetwork_;
    change_.updatenetwork_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vega::UpdateNetwork& ProposalTerms::updatenetwork() const {
  // @@protoc_insertion_point(field_get:vega.ProposalTerms.updateNetwork)
  return has_updatenetwork()
      ? *change_.updatenetwork_
      : *reinterpret_cast< ::vega::UpdateNetwork*>(&::vega::_UpdateNetwork_default_instance_);
}
inline ::vega::UpdateNetwork* ProposalTerms::mutable_updatenetwork() {
  if (!has_updatenetwork()) {
    clear_change();
    set_has_updatenetwork();
    change_.updatenetwork_ = CreateMaybeMessage< ::vega::UpdateNetwork >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:vega.ProposalTerms.updateNetwork)
  return change_.updatenetwork_;
}

// .vega.NewAsset newAsset = 104;
inline bool ProposalTerms::has_newasset() const {
  return change_case() == kNewAsset;
}
inline void ProposalTerms::set_has_newasset() {
  _oneof_case_[0] = kNewAsset;
}
inline void ProposalTerms::clear_newasset() {
  if (has_newasset()) {
    delete change_.newasset_;
    clear_has_change();
  }
}
inline ::vega::NewAsset* ProposalTerms::release_newasset() {
  // @@protoc_insertion_point(field_release:vega.ProposalTerms.newAsset)
  if (has_newasset()) {
    clear_has_change();
      ::vega::NewAsset* temp = change_.newasset_;
    change_.newasset_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vega::NewAsset& ProposalTerms::newasset() const {
  // @@protoc_insertion_point(field_get:vega.ProposalTerms.newAsset)
  return has_newasset()
      ? *change_.newasset_
      : *reinterpret_cast< ::vega::NewAsset*>(&::vega::_NewAsset_default_instance_);
}
inline ::vega::NewAsset* ProposalTerms::mutable_newasset() {
  if (!has_newasset()) {
    clear_change();
    set_has_newasset();
    change_.newasset_ = CreateMaybeMessage< ::vega::NewAsset >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:vega.ProposalTerms.newAsset)
  return change_.newasset_;
}

inline bool ProposalTerms::has_change() const {
  return change_case() != CHANGE_NOT_SET;
}
inline void ProposalTerms::clear_has_change() {
  _oneof_case_[0] = CHANGE_NOT_SET;
}
inline ProposalTerms::ChangeCase ProposalTerms::change_case() const {
  return ProposalTerms::ChangeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// GovernanceData

// .vega.Proposal proposal = 1;
inline bool GovernanceData::has_proposal() const {
  return this != internal_default_instance() && proposal_ != nullptr;
}
inline void GovernanceData::clear_proposal() {
  if (GetArenaNoVirtual() == nullptr && proposal_ != nullptr) {
    delete proposal_;
  }
  proposal_ = nullptr;
}
inline const ::vega::Proposal& GovernanceData::proposal() const {
  const ::vega::Proposal* p = proposal_;
  // @@protoc_insertion_point(field_get:vega.GovernanceData.proposal)
  return p != nullptr ? *p : *reinterpret_cast<const ::vega::Proposal*>(
      &::vega::_Proposal_default_instance_);
}
inline ::vega::Proposal* GovernanceData::release_proposal() {
  // @@protoc_insertion_point(field_release:vega.GovernanceData.proposal)

  ::vega::Proposal* temp = proposal_;
  proposal_ = nullptr;
  return temp;
}
inline ::vega::Proposal* GovernanceData::mutable_proposal() {

  if (proposal_ == nullptr) {
    auto* p = CreateMaybeMessage<::vega::Proposal>(GetArenaNoVirtual());
    proposal_ = p;
  }
  // @@protoc_insertion_point(field_mutable:vega.GovernanceData.proposal)
  return proposal_;
}
inline void GovernanceData::set_allocated_proposal(::vega::Proposal* proposal) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete proposal_;
  }
  if (proposal) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      proposal = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, proposal, submessage_arena);
    }

  } else {

  }
  proposal_ = proposal;
  // @@protoc_insertion_point(field_set_allocated:vega.GovernanceData.proposal)
}

// repeated .vega.Vote yes = 2;
inline int GovernanceData::yes_size() const {
  return yes_.size();
}
inline void GovernanceData::clear_yes() {
  yes_.Clear();
}
inline ::vega::Vote* GovernanceData::mutable_yes(int index) {
  // @@protoc_insertion_point(field_mutable:vega.GovernanceData.yes)
  return yes_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::vega::Vote >*
GovernanceData::mutable_yes() {
  // @@protoc_insertion_point(field_mutable_list:vega.GovernanceData.yes)
  return &yes_;
}
inline const ::vega::Vote& GovernanceData::yes(int index) const {
  // @@protoc_insertion_point(field_get:vega.GovernanceData.yes)
  return yes_.Get(index);
}
inline ::vega::Vote* GovernanceData::add_yes() {
  // @@protoc_insertion_point(field_add:vega.GovernanceData.yes)
  return yes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vega::Vote >&
GovernanceData::yes() const {
  // @@protoc_insertion_point(field_list:vega.GovernanceData.yes)
  return yes_;
}

// repeated .vega.Vote no = 3;
inline int GovernanceData::no_size() const {
  return no_.size();
}
inline void GovernanceData::clear_no() {
  no_.Clear();
}
inline ::vega::Vote* GovernanceData::mutable_no(int index) {
  // @@protoc_insertion_point(field_mutable:vega.GovernanceData.no)
  return no_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::vega::Vote >*
GovernanceData::mutable_no() {
  // @@protoc_insertion_point(field_mutable_list:vega.GovernanceData.no)
  return &no_;
}
inline const ::vega::Vote& GovernanceData::no(int index) const {
  // @@protoc_insertion_point(field_get:vega.GovernanceData.no)
  return no_.Get(index);
}
inline ::vega::Vote* GovernanceData::add_no() {
  // @@protoc_insertion_point(field_add:vega.GovernanceData.no)
  return no_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vega::Vote >&
GovernanceData::no() const {
  // @@protoc_insertion_point(field_list:vega.GovernanceData.no)
  return no_;
}

// map<string, .vega.Vote> yesParty = 4;
inline int GovernanceData::yesparty_size() const {
  return yesparty_.size();
}
inline void GovernanceData::clear_yesparty() {
  yesparty_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::vega::Vote >&
GovernanceData::yesparty() const {
  // @@protoc_insertion_point(field_map:vega.GovernanceData.yesParty)
  return yesparty_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::vega::Vote >*
GovernanceData::mutable_yesparty() {
  // @@protoc_insertion_point(field_mutable_map:vega.GovernanceData.yesParty)
  return yesparty_.MutableMap();
}

// map<string, .vega.Vote> noParty = 5;
inline int GovernanceData::noparty_size() const {
  return noparty_.size();
}
inline void GovernanceData::clear_noparty() {
  noparty_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::vega::Vote >&
GovernanceData::noparty() const {
  // @@protoc_insertion_point(field_map:vega.GovernanceData.noParty)
  return noparty_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::vega::Vote >*
GovernanceData::mutable_noparty() {
  // @@protoc_insertion_point(field_mutable_map:vega.GovernanceData.noParty)
  return noparty_.MutableMap();
}

// -------------------------------------------------------------------

// Proposal

// string ID = 1;
inline void Proposal::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Proposal::id() const {
  // @@protoc_insertion_point(field_get:vega.Proposal.ID)
  return id_.GetNoArena();
}
inline void Proposal::set_id(const ::std::string& value) {

  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vega.Proposal.ID)
}
#if LANG_CXX11
inline void Proposal::set_id(::std::string&& value) {

  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vega.Proposal.ID)
}
#endif
inline void Proposal::set_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vega.Proposal.ID)
}
inline void Proposal::set_id(const char* value, size_t size) {

  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vega.Proposal.ID)
}
inline ::std::string* Proposal::mutable_id() {

  // @@protoc_insertion_point(field_mutable:vega.Proposal.ID)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Proposal::release_id() {
  // @@protoc_insertion_point(field_release:vega.Proposal.ID)

  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Proposal::set_allocated_id(::std::string* id) {
  if (id != nullptr) {

  } else {

  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:vega.Proposal.ID)
}

// string reference = 2;
inline void Proposal::clear_reference() {
  reference_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Proposal::reference() const {
  // @@protoc_insertion_point(field_get:vega.Proposal.reference)
  return reference_.GetNoArena();
}
inline void Proposal::set_reference(const ::std::string& value) {

  reference_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vega.Proposal.reference)
}
#if LANG_CXX11
inline void Proposal::set_reference(::std::string&& value) {

  reference_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vega.Proposal.reference)
}
#endif
inline void Proposal::set_reference(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  reference_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vega.Proposal.reference)
}
inline void Proposal::set_reference(const char* value, size_t size) {

  reference_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vega.Proposal.reference)
}
inline ::std::string* Proposal::mutable_reference() {

  // @@protoc_insertion_point(field_mutable:vega.Proposal.reference)
  return reference_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Proposal::release_reference() {
  // @@protoc_insertion_point(field_release:vega.Proposal.reference)

  return reference_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Proposal::set_allocated_reference(::std::string* reference) {
  if (reference != nullptr) {

  } else {

  }
  reference_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), reference);
  // @@protoc_insertion_point(field_set_allocated:vega.Proposal.reference)
}

// string partyID = 3 [(.validator.field) = {
inline void Proposal::clear_partyid() {
  partyid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Proposal::partyid() const {
  // @@protoc_insertion_point(field_get:vega.Proposal.partyID)
  return partyid_.GetNoArena();
}
inline void Proposal::set_partyid(const ::std::string& value) {

  partyid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vega.Proposal.partyID)
}
#if LANG_CXX11
inline void Proposal::set_partyid(::std::string&& value) {

  partyid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vega.Proposal.partyID)
}
#endif
inline void Proposal::set_partyid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  partyid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vega.Proposal.partyID)
}
inline void Proposal::set_partyid(const char* value, size_t size) {

  partyid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vega.Proposal.partyID)
}
inline ::std::string* Proposal::mutable_partyid() {

  // @@protoc_insertion_point(field_mutable:vega.Proposal.partyID)
  return partyid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Proposal::release_partyid() {
  // @@protoc_insertion_point(field_release:vega.Proposal.partyID)

  return partyid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Proposal::set_allocated_partyid(::std::string* partyid) {
  if (partyid != nullptr) {

  } else {

  }
  partyid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), partyid);
  // @@protoc_insertion_point(field_set_allocated:vega.Proposal.partyID)
}

// .vega.Proposal.State state = 4 [(.validator.field) = {
inline void Proposal::clear_state() {
  state_ = 0;
}
inline ::vega::Proposal_State Proposal::state() const {
  // @@protoc_insertion_point(field_get:vega.Proposal.state)
  return static_cast< ::vega::Proposal_State >(state_);
}
inline void Proposal::set_state(::vega::Proposal_State value) {

  state_ = value;
  // @@protoc_insertion_point(field_set:vega.Proposal.state)
}

// int64 timestamp = 5;
inline void Proposal::clear_timestamp() {
  timestamp_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 Proposal::timestamp() const {
  // @@protoc_insertion_point(field_get:vega.Proposal.timestamp)
  return timestamp_;
}
inline void Proposal::set_timestamp(::google::protobuf::int64 value) {

  timestamp_ = value;
  // @@protoc_insertion_point(field_set:vega.Proposal.timestamp)
}

// .vega.ProposalTerms terms = 6 [(.validator.field) = {
inline bool Proposal::has_terms() const {
  return this != internal_default_instance() && terms_ != nullptr;
}
inline void Proposal::clear_terms() {
  if (GetArenaNoVirtual() == nullptr && terms_ != nullptr) {
    delete terms_;
  }
  terms_ = nullptr;
}
inline const ::vega::ProposalTerms& Proposal::terms() const {
  const ::vega::ProposalTerms* p = terms_;
  // @@protoc_insertion_point(field_get:vega.Proposal.terms)
  return p != nullptr ? *p : *reinterpret_cast<const ::vega::ProposalTerms*>(
      &::vega::_ProposalTerms_default_instance_);
}
inline ::vega::ProposalTerms* Proposal::release_terms() {
  // @@protoc_insertion_point(field_release:vega.Proposal.terms)

  ::vega::ProposalTerms* temp = terms_;
  terms_ = nullptr;
  return temp;
}
inline ::vega::ProposalTerms* Proposal::mutable_terms() {

  if (terms_ == nullptr) {
    auto* p = CreateMaybeMessage<::vega::ProposalTerms>(GetArenaNoVirtual());
    terms_ = p;
  }
  // @@protoc_insertion_point(field_mutable:vega.Proposal.terms)
  return terms_;
}
inline void Proposal::set_allocated_terms(::vega::ProposalTerms* terms) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete terms_;
  }
  if (terms) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      terms = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, terms, submessage_arena);
    }

  } else {

  }
  terms_ = terms;
  // @@protoc_insertion_point(field_set_allocated:vega.Proposal.terms)
}

// .vega.ProposalError reason = 7;
inline void Proposal::clear_reason() {
  reason_ = 0;
}
inline ::vega::ProposalError Proposal::reason() const {
  // @@protoc_insertion_point(field_get:vega.Proposal.reason)
  return static_cast< ::vega::ProposalError >(reason_);
}
inline void Proposal::set_reason(::vega::ProposalError value) {

  reason_ = value;
  // @@protoc_insertion_point(field_set:vega.Proposal.reason)
}

// -------------------------------------------------------------------

// Vote

// string partyID = 1 [(.validator.field) = {
inline void Vote::clear_partyid() {
  partyid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Vote::partyid() const {
  // @@protoc_insertion_point(field_get:vega.Vote.partyID)
  return partyid_.GetNoArena();
}
inline void Vote::set_partyid(const ::std::string& value) {

  partyid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vega.Vote.partyID)
}
#if LANG_CXX11
inline void Vote::set_partyid(::std::string&& value) {

  partyid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vega.Vote.partyID)
}
#endif
inline void Vote::set_partyid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  partyid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vega.Vote.partyID)
}
inline void Vote::set_partyid(const char* value, size_t size) {

  partyid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vega.Vote.partyID)
}
inline ::std::string* Vote::mutable_partyid() {

  // @@protoc_insertion_point(field_mutable:vega.Vote.partyID)
  return partyid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Vote::release_partyid() {
  // @@protoc_insertion_point(field_release:vega.Vote.partyID)

  return partyid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Vote::set_allocated_partyid(::std::string* partyid) {
  if (partyid != nullptr) {

  } else {

  }
  partyid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), partyid);
  // @@protoc_insertion_point(field_set_allocated:vega.Vote.partyID)
}

// .vega.Vote.Value value = 2 [(.validator.field) = {
inline void Vote::clear_value() {
  value_ = 0;
}
inline ::vega::Vote_Value Vote::value() const {
  // @@protoc_insertion_point(field_get:vega.Vote.value)
  return static_cast< ::vega::Vote_Value >(value_);
}
inline void Vote::set_value(::vega::Vote_Value value) {

  value_ = value;
  // @@protoc_insertion_point(field_set:vega.Vote.value)
}

// string proposalID = 3 [(.validator.field) = {
inline void Vote::clear_proposalid() {
  proposalid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Vote::proposalid() const {
  // @@protoc_insertion_point(field_get:vega.Vote.proposalID)
  return proposalid_.GetNoArena();
}
inline void Vote::set_proposalid(const ::std::string& value) {

  proposalid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vega.Vote.proposalID)
}
#if LANG_CXX11
inline void Vote::set_proposalid(::std::string&& value) {

  proposalid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vega.Vote.proposalID)
}
#endif
inline void Vote::set_proposalid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  proposalid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vega.Vote.proposalID)
}
inline void Vote::set_proposalid(const char* value, size_t size) {

  proposalid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vega.Vote.proposalID)
}
inline ::std::string* Vote::mutable_proposalid() {

  // @@protoc_insertion_point(field_mutable:vega.Vote.proposalID)
  return proposalid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Vote::release_proposalid() {
  // @@protoc_insertion_point(field_release:vega.Vote.proposalID)

  return proposalid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Vote::set_allocated_proposalid(::std::string* proposalid) {
  if (proposalid != nullptr) {

  } else {

  }
  proposalid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), proposalid);
  // @@protoc_insertion_point(field_set_allocated:vega.Vote.proposalID)
}

// int64 timestamp = 4;
inline void Vote::clear_timestamp() {
  timestamp_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 Vote::timestamp() const {
  // @@protoc_insertion_point(field_get:vega.Vote.timestamp)
  return timestamp_;
}
inline void Vote::set_timestamp(::google::protobuf::int64 value) {

  timestamp_ = value;
  // @@protoc_insertion_point(field_set:vega.Vote.timestamp)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace vega

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::vega::Proposal_State> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::vega::Proposal_State>() {
  return ::vega::Proposal_State_descriptor();
}
template <> struct is_proto_enum< ::vega::Vote_Value> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::vega::Vote_Value>() {
  return ::vega::Vote_Value_descriptor();
}
template <> struct is_proto_enum< ::vega::ProposalError> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::vega::ProposalError>() {
  return ::vega::ProposalError_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // PROTOBUF_INCLUDED_proto_2fgovernance_2eproto

// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: proto/governance.proto

#ifndef PROTOBUF_INCLUDED_proto_2fgovernance_2eproto
#define PROTOBUF_INCLUDED_proto_2fgovernance_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3007000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3007001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "github.com/mwitkow/go-proto-validators/validator.pb.h"
#include "proto/markets.pb.h"
#include "proto/assets.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_proto_2fgovernance_2eproto

// Internal implementation detail -- do not use these members.
struct TableStruct_proto_2fgovernance_2eproto {
  static const ::google::protobuf::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::ParseTable schema[9]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors_proto_2fgovernance_2eproto();
namespace vega {
class GovernanceData;
class GovernanceDataDefaultTypeInternal;
extern GovernanceDataDefaultTypeInternal _GovernanceData_default_instance_;
class NetworkConfiguration;
class NetworkConfigurationDefaultTypeInternal;
extern NetworkConfigurationDefaultTypeInternal _NetworkConfiguration_default_instance_;
class NewAsset;
class NewAssetDefaultTypeInternal;
extern NewAssetDefaultTypeInternal _NewAsset_default_instance_;
class NewMarket;
class NewMarketDefaultTypeInternal;
extern NewMarketDefaultTypeInternal _NewMarket_default_instance_;
class Proposal;
class ProposalDefaultTypeInternal;
extern ProposalDefaultTypeInternal _Proposal_default_instance_;
class ProposalTerms;
class ProposalTermsDefaultTypeInternal;
extern ProposalTermsDefaultTypeInternal _ProposalTerms_default_instance_;
class UpdateMarket;
class UpdateMarketDefaultTypeInternal;
extern UpdateMarketDefaultTypeInternal _UpdateMarket_default_instance_;
class UpdateNetwork;
class UpdateNetworkDefaultTypeInternal;
extern UpdateNetworkDefaultTypeInternal _UpdateNetwork_default_instance_;
class Vote;
class VoteDefaultTypeInternal;
extern VoteDefaultTypeInternal _Vote_default_instance_;
}  // namespace vega
namespace google {
namespace protobuf {
template<> ::vega::GovernanceData* Arena::CreateMaybeMessage<::vega::GovernanceData>(Arena*);
template<> ::vega::NetworkConfiguration* Arena::CreateMaybeMessage<::vega::NetworkConfiguration>(Arena*);
template<> ::vega::NewAsset* Arena::CreateMaybeMessage<::vega::NewAsset>(Arena*);
template<> ::vega::NewMarket* Arena::CreateMaybeMessage<::vega::NewMarket>(Arena*);
template<> ::vega::Proposal* Arena::CreateMaybeMessage<::vega::Proposal>(Arena*);
template<> ::vega::ProposalTerms* Arena::CreateMaybeMessage<::vega::ProposalTerms>(Arena*);
template<> ::vega::UpdateMarket* Arena::CreateMaybeMessage<::vega::UpdateMarket>(Arena*);
template<> ::vega::UpdateNetwork* Arena::CreateMaybeMessage<::vega::UpdateNetwork>(Arena*);
template<> ::vega::Vote* Arena::CreateMaybeMessage<::vega::Vote>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace vega {

enum Proposal_State {
  Proposal_State_STATE_UNSPECIFIED = 0,
  Proposal_State_STATE_FAILED = 1,
  Proposal_State_STATE_OPEN = 2,
  Proposal_State_STATE_PASSED = 3,
  Proposal_State_STATE_REJECTED = 4,
  Proposal_State_STATE_DECLINED = 5,
  Proposal_State_STATE_ENACTED = 6,
  Proposal_State_Proposal_State_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::min(),
  Proposal_State_Proposal_State_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::max()
};
bool Proposal_State_IsValid(int value);
const Proposal_State Proposal_State_State_MIN = Proposal_State_STATE_UNSPECIFIED;
const Proposal_State Proposal_State_State_MAX = Proposal_State_STATE_ENACTED;
const int Proposal_State_State_ARRAYSIZE = Proposal_State_State_MAX + 1;

const ::google::protobuf::EnumDescriptor* Proposal_State_descriptor();
inline const ::std::string& Proposal_State_Name(Proposal_State value) {
  return ::google::protobuf::internal::NameOfEnum(
    Proposal_State_descriptor(), value);
}
inline bool Proposal_State_Parse(
    const ::std::string& name, Proposal_State* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Proposal_State>(
    Proposal_State_descriptor(), name, value);
}
enum Vote_Value {
  Vote_Value_VALUE_UNSPECIFIED = 0,
  Vote_Value_VALUE_NO = 1,
  Vote_Value_VALUE_YES = 2,
  Vote_Value_Vote_Value_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::min(),
  Vote_Value_Vote_Value_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::max()
};
bool Vote_Value_IsValid(int value);
const Vote_Value Vote_Value_Value_MIN = Vote_Value_VALUE_UNSPECIFIED;
const Vote_Value Vote_Value_Value_MAX = Vote_Value_VALUE_YES;
const int Vote_Value_Value_ARRAYSIZE = Vote_Value_Value_MAX + 1;

const ::google::protobuf::EnumDescriptor* Vote_Value_descriptor();
inline const ::std::string& Vote_Value_Name(Vote_Value value) {
  return ::google::protobuf::internal::NameOfEnum(
    Vote_Value_descriptor(), value);
}
inline bool Vote_Value_Parse(
    const ::std::string& name, Vote_Value* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Vote_Value>(
    Vote_Value_descriptor(), name, value);
}
// ===================================================================

class NetworkConfiguration :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vega.NetworkConfiguration) */ {
 public:
  NetworkConfiguration();
  virtual ~NetworkConfiguration();

  NetworkConfiguration(const NetworkConfiguration& from);

  inline NetworkConfiguration& operator=(const NetworkConfiguration& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NetworkConfiguration(NetworkConfiguration&& from) noexcept
    : NetworkConfiguration() {
    *this = ::std::move(from);
  }

  inline NetworkConfiguration& operator=(NetworkConfiguration&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const NetworkConfiguration& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NetworkConfiguration* internal_default_instance() {
    return reinterpret_cast<const NetworkConfiguration*>(
               &_NetworkConfiguration_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(NetworkConfiguration* other);
  friend void swap(NetworkConfiguration& a, NetworkConfiguration& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NetworkConfiguration* New() const final {
    return CreateMaybeMessage<NetworkConfiguration>(nullptr);
  }

  NetworkConfiguration* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<NetworkConfiguration>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const NetworkConfiguration& from);
  void MergeFrom(const NetworkConfiguration& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NetworkConfiguration* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int64 minCloseInSeconds = 1;
  void clear_mincloseinseconds();
  static const int kMinCloseInSecondsFieldNumber = 1;
  ::google::protobuf::int64 mincloseinseconds() const;
  void set_mincloseinseconds(::google::protobuf::int64 value);

  // int64 maxCloseInSeconds = 2;
  void clear_maxcloseinseconds();
  static const int kMaxCloseInSecondsFieldNumber = 2;
  ::google::protobuf::int64 maxcloseinseconds() const;
  void set_maxcloseinseconds(::google::protobuf::int64 value);

  // int64 minEnactInSeconds = 3;
  void clear_minenactinseconds();
  static const int kMinEnactInSecondsFieldNumber = 3;
  ::google::protobuf::int64 minenactinseconds() const;
  void set_minenactinseconds(::google::protobuf::int64 value);

  // int64 maxEnactInSeconds = 4;
  void clear_maxenactinseconds();
  static const int kMaxEnactInSecondsFieldNumber = 4;
  ::google::protobuf::int64 maxenactinseconds() const;
  void set_maxenactinseconds(::google::protobuf::int64 value);

  // float requiredParticipation = 5;
  void clear_requiredparticipation();
  static const int kRequiredParticipationFieldNumber = 5;
  float requiredparticipation() const;
  void set_requiredparticipation(float value);

  // float requiredMajority = 6;
  void clear_requiredmajority();
  static const int kRequiredMajorityFieldNumber = 6;
  float requiredmajority() const;
  void set_requiredmajority(float value);

  // float minProposerBalance = 7;
  void clear_minproposerbalance();
  static const int kMinProposerBalanceFieldNumber = 7;
  float minproposerbalance() const;
  void set_minproposerbalance(float value);

  // float minVoterBalance = 8;
  void clear_minvoterbalance();
  static const int kMinVoterBalanceFieldNumber = 8;
  float minvoterbalance() const;
  void set_minvoterbalance(float value);

  // @@protoc_insertion_point(class_scope:vega.NetworkConfiguration)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int64 mincloseinseconds_;
  ::google::protobuf::int64 maxcloseinseconds_;
  ::google::protobuf::int64 minenactinseconds_;
  ::google::protobuf::int64 maxenactinseconds_;
  float requiredparticipation_;
  float requiredmajority_;
  float minproposerbalance_;
  float minvoterbalance_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fgovernance_2eproto;
};
// -------------------------------------------------------------------

class UpdateMarket :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vega.UpdateMarket) */ {
 public:
  UpdateMarket();
  virtual ~UpdateMarket();

  UpdateMarket(const UpdateMarket& from);

  inline UpdateMarket& operator=(const UpdateMarket& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UpdateMarket(UpdateMarket&& from) noexcept
    : UpdateMarket() {
    *this = ::std::move(from);
  }

  inline UpdateMarket& operator=(UpdateMarket&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const UpdateMarket& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UpdateMarket* internal_default_instance() {
    return reinterpret_cast<const UpdateMarket*>(
               &_UpdateMarket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(UpdateMarket* other);
  friend void swap(UpdateMarket& a, UpdateMarket& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UpdateMarket* New() const final {
    return CreateMaybeMessage<UpdateMarket>(nullptr);
  }

  UpdateMarket* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UpdateMarket>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UpdateMarket& from);
  void MergeFrom(const UpdateMarket& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateMarket* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:vega.UpdateMarket)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fgovernance_2eproto;
};
// -------------------------------------------------------------------

class NewMarket :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vega.NewMarket) */ {
 public:
  NewMarket();
  virtual ~NewMarket();

  NewMarket(const NewMarket& from);

  inline NewMarket& operator=(const NewMarket& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NewMarket(NewMarket&& from) noexcept
    : NewMarket() {
    *this = ::std::move(from);
  }

  inline NewMarket& operator=(NewMarket&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const NewMarket& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NewMarket* internal_default_instance() {
    return reinterpret_cast<const NewMarket*>(
               &_NewMarket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(NewMarket* other);
  friend void swap(NewMarket& a, NewMarket& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NewMarket* New() const final {
    return CreateMaybeMessage<NewMarket>(nullptr);
  }

  NewMarket* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<NewMarket>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const NewMarket& from);
  void MergeFrom(const NewMarket& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NewMarket* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .vega.Market changes = 1 [(.validator.field) = {
  bool has_changes() const;
  void clear_changes();
  static const int kChangesFieldNumber = 1;
  const ::vega::Market& changes() const;
  ::vega::Market* release_changes();
  ::vega::Market* mutable_changes();
  void set_allocated_changes(::vega::Market* changes);

  // @@protoc_insertion_point(class_scope:vega.NewMarket)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::vega::Market* changes_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fgovernance_2eproto;
};
// -------------------------------------------------------------------

class UpdateNetwork :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vega.UpdateNetwork) */ {
 public:
  UpdateNetwork();
  virtual ~UpdateNetwork();

  UpdateNetwork(const UpdateNetwork& from);

  inline UpdateNetwork& operator=(const UpdateNetwork& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UpdateNetwork(UpdateNetwork&& from) noexcept
    : UpdateNetwork() {
    *this = ::std::move(from);
  }

  inline UpdateNetwork& operator=(UpdateNetwork&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const UpdateNetwork& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UpdateNetwork* internal_default_instance() {
    return reinterpret_cast<const UpdateNetwork*>(
               &_UpdateNetwork_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(UpdateNetwork* other);
  friend void swap(UpdateNetwork& a, UpdateNetwork& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UpdateNetwork* New() const final {
    return CreateMaybeMessage<UpdateNetwork>(nullptr);
  }

  UpdateNetwork* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UpdateNetwork>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UpdateNetwork& from);
  void MergeFrom(const UpdateNetwork& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateNetwork* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .vega.NetworkConfiguration changes = 1 [(.validator.field) = {
  bool has_changes() const;
  void clear_changes();
  static const int kChangesFieldNumber = 1;
  const ::vega::NetworkConfiguration& changes() const;
  ::vega::NetworkConfiguration* release_changes();
  ::vega::NetworkConfiguration* mutable_changes();
  void set_allocated_changes(::vega::NetworkConfiguration* changes);

  // @@protoc_insertion_point(class_scope:vega.UpdateNetwork)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::vega::NetworkConfiguration* changes_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fgovernance_2eproto;
};
// -------------------------------------------------------------------

class NewAsset :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vega.NewAsset) */ {
 public:
  NewAsset();
  virtual ~NewAsset();

  NewAsset(const NewAsset& from);

  inline NewAsset& operator=(const NewAsset& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NewAsset(NewAsset&& from) noexcept
    : NewAsset() {
    *this = ::std::move(from);
  }

  inline NewAsset& operator=(NewAsset&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const NewAsset& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NewAsset* internal_default_instance() {
    return reinterpret_cast<const NewAsset*>(
               &_NewAsset_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(NewAsset* other);
  friend void swap(NewAsset& a, NewAsset& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NewAsset* New() const final {
    return CreateMaybeMessage<NewAsset>(nullptr);
  }

  NewAsset* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<NewAsset>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const NewAsset& from);
  void MergeFrom(const NewAsset& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NewAsset* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .vega.AssetSource changes = 1 [(.validator.field) = {
  bool has_changes() const;
  void clear_changes();
  static const int kChangesFieldNumber = 1;
  const ::vega::AssetSource& changes() const;
  ::vega::AssetSource* release_changes();
  ::vega::AssetSource* mutable_changes();
  void set_allocated_changes(::vega::AssetSource* changes);

  // @@protoc_insertion_point(class_scope:vega.NewAsset)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::vega::AssetSource* changes_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fgovernance_2eproto;
};
// -------------------------------------------------------------------

class ProposalTerms :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vega.ProposalTerms) */ {
 public:
  ProposalTerms();
  virtual ~ProposalTerms();

  ProposalTerms(const ProposalTerms& from);

  inline ProposalTerms& operator=(const ProposalTerms& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProposalTerms(ProposalTerms&& from) noexcept
    : ProposalTerms() {
    *this = ::std::move(from);
  }

  inline ProposalTerms& operator=(ProposalTerms&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ProposalTerms& default_instance();

  enum ChangeCase {
    kUpdateMarket = 101,
    kNewMarket = 102,
    kUpdateNetwork = 103,
    kNewAsset = 104,
    CHANGE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProposalTerms* internal_default_instance() {
    return reinterpret_cast<const ProposalTerms*>(
               &_ProposalTerms_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(ProposalTerms* other);
  friend void swap(ProposalTerms& a, ProposalTerms& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProposalTerms* New() const final {
    return CreateMaybeMessage<ProposalTerms>(nullptr);
  }

  ProposalTerms* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ProposalTerms>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ProposalTerms& from);
  void MergeFrom(const ProposalTerms& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProposalTerms* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int64 closingTimestamp = 1 [(.validator.field) = {
  void clear_closingtimestamp();
  static const int kClosingTimestampFieldNumber = 1;
  ::google::protobuf::int64 closingtimestamp() const;
  void set_closingtimestamp(::google::protobuf::int64 value);

  // int64 enactmentTimestamp = 2 [(.validator.field) = {
  void clear_enactmenttimestamp();
  static const int kEnactmentTimestampFieldNumber = 2;
  ::google::protobuf::int64 enactmenttimestamp() const;
  void set_enactmenttimestamp(::google::protobuf::int64 value);

  // int64 validationTimestamp = 5;
  void clear_validationtimestamp();
  static const int kValidationTimestampFieldNumber = 5;
  ::google::protobuf::int64 validationtimestamp() const;
  void set_validationtimestamp(::google::protobuf::int64 value);

  // .vega.UpdateMarket updateMarket = 101;
  bool has_updatemarket() const;
  void clear_updatemarket();
  static const int kUpdateMarketFieldNumber = 101;
  const ::vega::UpdateMarket& updatemarket() const;
  ::vega::UpdateMarket* release_updatemarket();
  ::vega::UpdateMarket* mutable_updatemarket();
  void set_allocated_updatemarket(::vega::UpdateMarket* updatemarket);

  // .vega.NewMarket newMarket = 102;
  bool has_newmarket() const;
  void clear_newmarket();
  static const int kNewMarketFieldNumber = 102;
  const ::vega::NewMarket& newmarket() const;
  ::vega::NewMarket* release_newmarket();
  ::vega::NewMarket* mutable_newmarket();
  void set_allocated_newmarket(::vega::NewMarket* newmarket);

  // .vega.UpdateNetwork updateNetwork = 103;
  bool has_updatenetwork() const;
  void clear_updatenetwork();
  static const int kUpdateNetworkFieldNumber = 103;
  const ::vega::UpdateNetwork& updatenetwork() const;
  ::vega::UpdateNetwork* release_updatenetwork();
  ::vega::UpdateNetwork* mutable_updatenetwork();
  void set_allocated_updatenetwork(::vega::UpdateNetwork* updatenetwork);

  // .vega.NewAsset newAsset = 104;
  bool has_newasset() const;
  void clear_newasset();
  static const int kNewAssetFieldNumber = 104;
  const ::vega::NewAsset& newasset() const;
  ::vega::NewAsset* release_newasset();
  ::vega::NewAsset* mutable_newasset();
  void set_allocated_newasset(::vega::NewAsset* newasset);

  void clear_change();
  ChangeCase change_case() const;
  // @@protoc_insertion_point(class_scope:vega.ProposalTerms)
 private:
  class HasBitSetters;
  void set_has_updatemarket();
  void set_has_newmarket();
  void set_has_updatenetwork();
  void set_has_newasset();

  inline bool has_change() const;
  inline void clear_has_change();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int64 closingtimestamp_;
  ::google::protobuf::int64 enactmenttimestamp_;
  ::google::protobuf::int64 validationtimestamp_;
  union ChangeUnion {
    ChangeUnion() {}
    ::vega::UpdateMarket* updatemarket_;
    ::vega::NewMarket* newmarket_;
    ::vega::UpdateNetwork* updatenetwork_;
    ::vega::NewAsset* newasset_;
  } change_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::TableStruct_proto_2fgovernance_2eproto;
};
// -------------------------------------------------------------------

class GovernanceData :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vega.GovernanceData) */ {
 public:
  GovernanceData();
  virtual ~GovernanceData();

  GovernanceData(const GovernanceData& from);

  inline GovernanceData& operator=(const GovernanceData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GovernanceData(GovernanceData&& from) noexcept
    : GovernanceData() {
    *this = ::std::move(from);
  }

  inline GovernanceData& operator=(GovernanceData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const GovernanceData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GovernanceData* internal_default_instance() {
    return reinterpret_cast<const GovernanceData*>(
               &_GovernanceData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(GovernanceData* other);
  friend void swap(GovernanceData& a, GovernanceData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GovernanceData* New() const final {
    return CreateMaybeMessage<GovernanceData>(nullptr);
  }

  GovernanceData* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GovernanceData>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GovernanceData& from);
  void MergeFrom(const GovernanceData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GovernanceData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .vega.Vote yes = 2;
  int yes_size() const;
  void clear_yes();
  static const int kYesFieldNumber = 2;
  ::vega::Vote* mutable_yes(int index);
  ::google::protobuf::RepeatedPtrField< ::vega::Vote >*
      mutable_yes();
  const ::vega::Vote& yes(int index) const;
  ::vega::Vote* add_yes();
  const ::google::protobuf::RepeatedPtrField< ::vega::Vote >&
      yes() const;

  // repeated .vega.Vote no = 3;
  int no_size() const;
  void clear_no();
  static const int kNoFieldNumber = 3;
  ::vega::Vote* mutable_no(int index);
  ::google::protobuf::RepeatedPtrField< ::vega::Vote >*
      mutable_no();
  const ::vega::Vote& no(int index) const;
  ::vega::Vote* add_no();
  const ::google::protobuf::RepeatedPtrField< ::vega::Vote >&
      no() const;

  // .vega.Proposal proposal = 1;
  bool has_proposal() const;
  void clear_proposal();
  static const int kProposalFieldNumber = 1;
  const ::vega::Proposal& proposal() const;
  ::vega::Proposal* release_proposal();
  ::vega::Proposal* mutable_proposal();
  void set_allocated_proposal(::vega::Proposal* proposal);

  // @@protoc_insertion_point(class_scope:vega.GovernanceData)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::vega::Vote > yes_;
  ::google::protobuf::RepeatedPtrField< ::vega::Vote > no_;
  ::vega::Proposal* proposal_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fgovernance_2eproto;
};
// -------------------------------------------------------------------

class Proposal :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vega.Proposal) */ {
 public:
  Proposal();
  virtual ~Proposal();

  Proposal(const Proposal& from);

  inline Proposal& operator=(const Proposal& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Proposal(Proposal&& from) noexcept
    : Proposal() {
    *this = ::std::move(from);
  }

  inline Proposal& operator=(Proposal&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Proposal& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Proposal* internal_default_instance() {
    return reinterpret_cast<const Proposal*>(
               &_Proposal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(Proposal* other);
  friend void swap(Proposal& a, Proposal& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Proposal* New() const final {
    return CreateMaybeMessage<Proposal>(nullptr);
  }

  Proposal* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Proposal>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Proposal& from);
  void MergeFrom(const Proposal& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Proposal* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Proposal_State State;
  static const State STATE_UNSPECIFIED =
    Proposal_State_STATE_UNSPECIFIED;
  static const State STATE_FAILED =
    Proposal_State_STATE_FAILED;
  static const State STATE_OPEN =
    Proposal_State_STATE_OPEN;
  static const State STATE_PASSED =
    Proposal_State_STATE_PASSED;
  static const State STATE_REJECTED =
    Proposal_State_STATE_REJECTED;
  static const State STATE_DECLINED =
    Proposal_State_STATE_DECLINED;
  static const State STATE_ENACTED =
    Proposal_State_STATE_ENACTED;
  static inline bool State_IsValid(int value) {
    return Proposal_State_IsValid(value);
  }
  static const State State_MIN =
    Proposal_State_State_MIN;
  static const State State_MAX =
    Proposal_State_State_MAX;
  static const int State_ARRAYSIZE =
    Proposal_State_State_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  State_descriptor() {
    return Proposal_State_descriptor();
  }
  static inline const ::std::string& State_Name(State value) {
    return Proposal_State_Name(value);
  }
  static inline bool State_Parse(const ::std::string& name,
      State* value) {
    return Proposal_State_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // string ID = 1;
  void clear_id();
  static const int kIDFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // string reference = 2;
  void clear_reference();
  static const int kReferenceFieldNumber = 2;
  const ::std::string& reference() const;
  void set_reference(const ::std::string& value);
  #if LANG_CXX11
  void set_reference(::std::string&& value);
  #endif
  void set_reference(const char* value);
  void set_reference(const char* value, size_t size);
  ::std::string* mutable_reference();
  ::std::string* release_reference();
  void set_allocated_reference(::std::string* reference);

  // string partyID = 3 [(.validator.field) = {
  void clear_partyid();
  static const int kPartyIDFieldNumber = 3;
  const ::std::string& partyid() const;
  void set_partyid(const ::std::string& value);
  #if LANG_CXX11
  void set_partyid(::std::string&& value);
  #endif
  void set_partyid(const char* value);
  void set_partyid(const char* value, size_t size);
  ::std::string* mutable_partyid();
  ::std::string* release_partyid();
  void set_allocated_partyid(::std::string* partyid);

  // .vega.ProposalTerms terms = 6 [(.validator.field) = {
  bool has_terms() const;
  void clear_terms();
  static const int kTermsFieldNumber = 6;
  const ::vega::ProposalTerms& terms() const;
  ::vega::ProposalTerms* release_terms();
  ::vega::ProposalTerms* mutable_terms();
  void set_allocated_terms(::vega::ProposalTerms* terms);

  // int64 timestamp = 5;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 5;
  ::google::protobuf::int64 timestamp() const;
  void set_timestamp(::google::protobuf::int64 value);

  // .vega.Proposal.State state = 4 [(.validator.field) = {
  void clear_state();
  static const int kStateFieldNumber = 4;
  ::vega::Proposal_State state() const;
  void set_state(::vega::Proposal_State value);

  // @@protoc_insertion_point(class_scope:vega.Proposal)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::internal::ArenaStringPtr reference_;
  ::google::protobuf::internal::ArenaStringPtr partyid_;
  ::vega::ProposalTerms* terms_;
  ::google::protobuf::int64 timestamp_;
  int state_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fgovernance_2eproto;
};
// -------------------------------------------------------------------

class Vote :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vega.Vote) */ {
 public:
  Vote();
  virtual ~Vote();

  Vote(const Vote& from);

  inline Vote& operator=(const Vote& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Vote(Vote&& from) noexcept
    : Vote() {
    *this = ::std::move(from);
  }

  inline Vote& operator=(Vote&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Vote& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Vote* internal_default_instance() {
    return reinterpret_cast<const Vote*>(
               &_Vote_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(Vote* other);
  friend void swap(Vote& a, Vote& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Vote* New() const final {
    return CreateMaybeMessage<Vote>(nullptr);
  }

  Vote* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Vote>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Vote& from);
  void MergeFrom(const Vote& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vote* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Vote_Value Value;
  static const Value VALUE_UNSPECIFIED =
    Vote_Value_VALUE_UNSPECIFIED;
  static const Value VALUE_NO =
    Vote_Value_VALUE_NO;
  static const Value VALUE_YES =
    Vote_Value_VALUE_YES;
  static inline bool Value_IsValid(int value) {
    return Vote_Value_IsValid(value);
  }
  static const Value Value_MIN =
    Vote_Value_Value_MIN;
  static const Value Value_MAX =
    Vote_Value_Value_MAX;
  static const int Value_ARRAYSIZE =
    Vote_Value_Value_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Value_descriptor() {
    return Vote_Value_descriptor();
  }
  static inline const ::std::string& Value_Name(Value value) {
    return Vote_Value_Name(value);
  }
  static inline bool Value_Parse(const ::std::string& name,
      Value* value) {
    return Vote_Value_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // string partyID = 1 [(.validator.field) = {
  void clear_partyid();
  static const int kPartyIDFieldNumber = 1;
  const ::std::string& partyid() const;
  void set_partyid(const ::std::string& value);
  #if LANG_CXX11
  void set_partyid(::std::string&& value);
  #endif
  void set_partyid(const char* value);
  void set_partyid(const char* value, size_t size);
  ::std::string* mutable_partyid();
  ::std::string* release_partyid();
  void set_allocated_partyid(::std::string* partyid);

  // string proposalID = 3 [(.validator.field) = {
  void clear_proposalid();
  static const int kProposalIDFieldNumber = 3;
  const ::std::string& proposalid() const;
  void set_proposalid(const ::std::string& value);
  #if LANG_CXX11
  void set_proposalid(::std::string&& value);
  #endif
  void set_proposalid(const char* value);
  void set_proposalid(const char* value, size_t size);
  ::std::string* mutable_proposalid();
  ::std::string* release_proposalid();
  void set_allocated_proposalid(::std::string* proposalid);

  // int64 timestamp = 4;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 4;
  ::google::protobuf::int64 timestamp() const;
  void set_timestamp(::google::protobuf::int64 value);

  // .vega.Vote.Value value = 2 [(.validator.field) = {
  void clear_value();
  static const int kValueFieldNumber = 2;
  ::vega::Vote_Value value() const;
  void set_value(::vega::Vote_Value value);

  // @@protoc_insertion_point(class_scope:vega.Vote)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr partyid_;
  ::google::protobuf::internal::ArenaStringPtr proposalid_;
  ::google::protobuf::int64 timestamp_;
  int value_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fgovernance_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// NetworkConfiguration

// int64 minCloseInSeconds = 1;
inline void NetworkConfiguration::clear_mincloseinseconds() {
  mincloseinseconds_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 NetworkConfiguration::mincloseinseconds() const {
  // @@protoc_insertion_point(field_get:vega.NetworkConfiguration.minCloseInSeconds)
  return mincloseinseconds_;
}
inline void NetworkConfiguration::set_mincloseinseconds(::google::protobuf::int64 value) {
  
  mincloseinseconds_ = value;
  // @@protoc_insertion_point(field_set:vega.NetworkConfiguration.minCloseInSeconds)
}

// int64 maxCloseInSeconds = 2;
inline void NetworkConfiguration::clear_maxcloseinseconds() {
  maxcloseinseconds_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 NetworkConfiguration::maxcloseinseconds() const {
  // @@protoc_insertion_point(field_get:vega.NetworkConfiguration.maxCloseInSeconds)
  return maxcloseinseconds_;
}
inline void NetworkConfiguration::set_maxcloseinseconds(::google::protobuf::int64 value) {
  
  maxcloseinseconds_ = value;
  // @@protoc_insertion_point(field_set:vega.NetworkConfiguration.maxCloseInSeconds)
}

// int64 minEnactInSeconds = 3;
inline void NetworkConfiguration::clear_minenactinseconds() {
  minenactinseconds_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 NetworkConfiguration::minenactinseconds() const {
  // @@protoc_insertion_point(field_get:vega.NetworkConfiguration.minEnactInSeconds)
  return minenactinseconds_;
}
inline void NetworkConfiguration::set_minenactinseconds(::google::protobuf::int64 value) {
  
  minenactinseconds_ = value;
  // @@protoc_insertion_point(field_set:vega.NetworkConfiguration.minEnactInSeconds)
}

// int64 maxEnactInSeconds = 4;
inline void NetworkConfiguration::clear_maxenactinseconds() {
  maxenactinseconds_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 NetworkConfiguration::maxenactinseconds() const {
  // @@protoc_insertion_point(field_get:vega.NetworkConfiguration.maxEnactInSeconds)
  return maxenactinseconds_;
}
inline void NetworkConfiguration::set_maxenactinseconds(::google::protobuf::int64 value) {
  
  maxenactinseconds_ = value;
  // @@protoc_insertion_point(field_set:vega.NetworkConfiguration.maxEnactInSeconds)
}

// float requiredParticipation = 5;
inline void NetworkConfiguration::clear_requiredparticipation() {
  requiredparticipation_ = 0;
}
inline float NetworkConfiguration::requiredparticipation() const {
  // @@protoc_insertion_point(field_get:vega.NetworkConfiguration.requiredParticipation)
  return requiredparticipation_;
}
inline void NetworkConfiguration::set_requiredparticipation(float value) {
  
  requiredparticipation_ = value;
  // @@protoc_insertion_point(field_set:vega.NetworkConfiguration.requiredParticipation)
}

// float requiredMajority = 6;
inline void NetworkConfiguration::clear_requiredmajority() {
  requiredmajority_ = 0;
}
inline float NetworkConfiguration::requiredmajority() const {
  // @@protoc_insertion_point(field_get:vega.NetworkConfiguration.requiredMajority)
  return requiredmajority_;
}
inline void NetworkConfiguration::set_requiredmajority(float value) {
  
  requiredmajority_ = value;
  // @@protoc_insertion_point(field_set:vega.NetworkConfiguration.requiredMajority)
}

// float minProposerBalance = 7;
inline void NetworkConfiguration::clear_minproposerbalance() {
  minproposerbalance_ = 0;
}
inline float NetworkConfiguration::minproposerbalance() const {
  // @@protoc_insertion_point(field_get:vega.NetworkConfiguration.minProposerBalance)
  return minproposerbalance_;
}
inline void NetworkConfiguration::set_minproposerbalance(float value) {
  
  minproposerbalance_ = value;
  // @@protoc_insertion_point(field_set:vega.NetworkConfiguration.minProposerBalance)
}

// float minVoterBalance = 8;
inline void NetworkConfiguration::clear_minvoterbalance() {
  minvoterbalance_ = 0;
}
inline float NetworkConfiguration::minvoterbalance() const {
  // @@protoc_insertion_point(field_get:vega.NetworkConfiguration.minVoterBalance)
  return minvoterbalance_;
}
inline void NetworkConfiguration::set_minvoterbalance(float value) {
  
  minvoterbalance_ = value;
  // @@protoc_insertion_point(field_set:vega.NetworkConfiguration.minVoterBalance)
}

// -------------------------------------------------------------------

// UpdateMarket

// -------------------------------------------------------------------

// NewMarket

// .vega.Market changes = 1 [(.validator.field) = {
inline bool NewMarket::has_changes() const {
  return this != internal_default_instance() && changes_ != nullptr;
}
inline const ::vega::Market& NewMarket::changes() const {
  const ::vega::Market* p = changes_;
  // @@protoc_insertion_point(field_get:vega.NewMarket.changes)
  return p != nullptr ? *p : *reinterpret_cast<const ::vega::Market*>(
      &::vega::_Market_default_instance_);
}
inline ::vega::Market* NewMarket::release_changes() {
  // @@protoc_insertion_point(field_release:vega.NewMarket.changes)
  
  ::vega::Market* temp = changes_;
  changes_ = nullptr;
  return temp;
}
inline ::vega::Market* NewMarket::mutable_changes() {
  
  if (changes_ == nullptr) {
    auto* p = CreateMaybeMessage<::vega::Market>(GetArenaNoVirtual());
    changes_ = p;
  }
  // @@protoc_insertion_point(field_mutable:vega.NewMarket.changes)
  return changes_;
}
inline void NewMarket::set_allocated_changes(::vega::Market* changes) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(changes_);
  }
  if (changes) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      changes = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, changes, submessage_arena);
    }
    
  } else {
    
  }
  changes_ = changes;
  // @@protoc_insertion_point(field_set_allocated:vega.NewMarket.changes)
}

// -------------------------------------------------------------------

// UpdateNetwork

// .vega.NetworkConfiguration changes = 1 [(.validator.field) = {
inline bool UpdateNetwork::has_changes() const {
  return this != internal_default_instance() && changes_ != nullptr;
}
inline void UpdateNetwork::clear_changes() {
  if (GetArenaNoVirtual() == nullptr && changes_ != nullptr) {
    delete changes_;
  }
  changes_ = nullptr;
}
inline const ::vega::NetworkConfiguration& UpdateNetwork::changes() const {
  const ::vega::NetworkConfiguration* p = changes_;
  // @@protoc_insertion_point(field_get:vega.UpdateNetwork.changes)
  return p != nullptr ? *p : *reinterpret_cast<const ::vega::NetworkConfiguration*>(
      &::vega::_NetworkConfiguration_default_instance_);
}
inline ::vega::NetworkConfiguration* UpdateNetwork::release_changes() {
  // @@protoc_insertion_point(field_release:vega.UpdateNetwork.changes)
  
  ::vega::NetworkConfiguration* temp = changes_;
  changes_ = nullptr;
  return temp;
}
inline ::vega::NetworkConfiguration* UpdateNetwork::mutable_changes() {
  
  if (changes_ == nullptr) {
    auto* p = CreateMaybeMessage<::vega::NetworkConfiguration>(GetArenaNoVirtual());
    changes_ = p;
  }
  // @@protoc_insertion_point(field_mutable:vega.UpdateNetwork.changes)
  return changes_;
}
inline void UpdateNetwork::set_allocated_changes(::vega::NetworkConfiguration* changes) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete changes_;
  }
  if (changes) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      changes = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, changes, submessage_arena);
    }
    
  } else {
    
  }
  changes_ = changes;
  // @@protoc_insertion_point(field_set_allocated:vega.UpdateNetwork.changes)
}

// -------------------------------------------------------------------

// NewAsset

// .vega.AssetSource changes = 1 [(.validator.field) = {
inline bool NewAsset::has_changes() const {
  return this != internal_default_instance() && changes_ != nullptr;
}
inline const ::vega::AssetSource& NewAsset::changes() const {
  const ::vega::AssetSource* p = changes_;
  // @@protoc_insertion_point(field_get:vega.NewAsset.changes)
  return p != nullptr ? *p : *reinterpret_cast<const ::vega::AssetSource*>(
      &::vega::_AssetSource_default_instance_);
}
inline ::vega::AssetSource* NewAsset::release_changes() {
  // @@protoc_insertion_point(field_release:vega.NewAsset.changes)
  
  ::vega::AssetSource* temp = changes_;
  changes_ = nullptr;
  return temp;
}
inline ::vega::AssetSource* NewAsset::mutable_changes() {
  
  if (changes_ == nullptr) {
    auto* p = CreateMaybeMessage<::vega::AssetSource>(GetArenaNoVirtual());
    changes_ = p;
  }
  // @@protoc_insertion_point(field_mutable:vega.NewAsset.changes)
  return changes_;
}
inline void NewAsset::set_allocated_changes(::vega::AssetSource* changes) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(changes_);
  }
  if (changes) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      changes = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, changes, submessage_arena);
    }
    
  } else {
    
  }
  changes_ = changes;
  // @@protoc_insertion_point(field_set_allocated:vega.NewAsset.changes)
}

// -------------------------------------------------------------------

// ProposalTerms

// int64 closingTimestamp = 1 [(.validator.field) = {
inline void ProposalTerms::clear_closingtimestamp() {
  closingtimestamp_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 ProposalTerms::closingtimestamp() const {
  // @@protoc_insertion_point(field_get:vega.ProposalTerms.closingTimestamp)
  return closingtimestamp_;
}
inline void ProposalTerms::set_closingtimestamp(::google::protobuf::int64 value) {
  
  closingtimestamp_ = value;
  // @@protoc_insertion_point(field_set:vega.ProposalTerms.closingTimestamp)
}

// int64 enactmentTimestamp = 2 [(.validator.field) = {
inline void ProposalTerms::clear_enactmenttimestamp() {
  enactmenttimestamp_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 ProposalTerms::enactmenttimestamp() const {
  // @@protoc_insertion_point(field_get:vega.ProposalTerms.enactmentTimestamp)
  return enactmenttimestamp_;
}
inline void ProposalTerms::set_enactmenttimestamp(::google::protobuf::int64 value) {
  
  enactmenttimestamp_ = value;
  // @@protoc_insertion_point(field_set:vega.ProposalTerms.enactmentTimestamp)
}

// int64 validationTimestamp = 5;
inline void ProposalTerms::clear_validationtimestamp() {
  validationtimestamp_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 ProposalTerms::validationtimestamp() const {
  // @@protoc_insertion_point(field_get:vega.ProposalTerms.validationTimestamp)
  return validationtimestamp_;
}
inline void ProposalTerms::set_validationtimestamp(::google::protobuf::int64 value) {
  
  validationtimestamp_ = value;
  // @@protoc_insertion_point(field_set:vega.ProposalTerms.validationTimestamp)
}

// .vega.UpdateMarket updateMarket = 101;
inline bool ProposalTerms::has_updatemarket() const {
  return change_case() == kUpdateMarket;
}
inline void ProposalTerms::set_has_updatemarket() {
  _oneof_case_[0] = kUpdateMarket;
}
inline void ProposalTerms::clear_updatemarket() {
  if (has_updatemarket()) {
    delete change_.updatemarket_;
    clear_has_change();
  }
}
inline ::vega::UpdateMarket* ProposalTerms::release_updatemarket() {
  // @@protoc_insertion_point(field_release:vega.ProposalTerms.updateMarket)
  if (has_updatemarket()) {
    clear_has_change();
      ::vega::UpdateMarket* temp = change_.updatemarket_;
    change_.updatemarket_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vega::UpdateMarket& ProposalTerms::updatemarket() const {
  // @@protoc_insertion_point(field_get:vega.ProposalTerms.updateMarket)
  return has_updatemarket()
      ? *change_.updatemarket_
      : *reinterpret_cast< ::vega::UpdateMarket*>(&::vega::_UpdateMarket_default_instance_);
}
inline ::vega::UpdateMarket* ProposalTerms::mutable_updatemarket() {
  if (!has_updatemarket()) {
    clear_change();
    set_has_updatemarket();
    change_.updatemarket_ = CreateMaybeMessage< ::vega::UpdateMarket >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:vega.ProposalTerms.updateMarket)
  return change_.updatemarket_;
}

// .vega.NewMarket newMarket = 102;
inline bool ProposalTerms::has_newmarket() const {
  return change_case() == kNewMarket;
}
inline void ProposalTerms::set_has_newmarket() {
  _oneof_case_[0] = kNewMarket;
}
inline void ProposalTerms::clear_newmarket() {
  if (has_newmarket()) {
    delete change_.newmarket_;
    clear_has_change();
  }
}
inline ::vega::NewMarket* ProposalTerms::release_newmarket() {
  // @@protoc_insertion_point(field_release:vega.ProposalTerms.newMarket)
  if (has_newmarket()) {
    clear_has_change();
      ::vega::NewMarket* temp = change_.newmarket_;
    change_.newmarket_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vega::NewMarket& ProposalTerms::newmarket() const {
  // @@protoc_insertion_point(field_get:vega.ProposalTerms.newMarket)
  return has_newmarket()
      ? *change_.newmarket_
      : *reinterpret_cast< ::vega::NewMarket*>(&::vega::_NewMarket_default_instance_);
}
inline ::vega::NewMarket* ProposalTerms::mutable_newmarket() {
  if (!has_newmarket()) {
    clear_change();
    set_has_newmarket();
    change_.newmarket_ = CreateMaybeMessage< ::vega::NewMarket >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:vega.ProposalTerms.newMarket)
  return change_.newmarket_;
}

// .vega.UpdateNetwork updateNetwork = 103;
inline bool ProposalTerms::has_updatenetwork() const {
  return change_case() == kUpdateNetwork;
}
inline void ProposalTerms::set_has_updatenetwork() {
  _oneof_case_[0] = kUpdateNetwork;
}
inline void ProposalTerms::clear_updatenetwork() {
  if (has_updatenetwork()) {
    delete change_.updatenetwork_;
    clear_has_change();
  }
}
inline ::vega::UpdateNetwork* ProposalTerms::release_updatenetwork() {
  // @@protoc_insertion_point(field_release:vega.ProposalTerms.updateNetwork)
  if (has_updatenetwork()) {
    clear_has_change();
      ::vega::UpdateNetwork* temp = change_.updatenetwork_;
    change_.updatenetwork_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vega::UpdateNetwork& ProposalTerms::updatenetwork() const {
  // @@protoc_insertion_point(field_get:vega.ProposalTerms.updateNetwork)
  return has_updatenetwork()
      ? *change_.updatenetwork_
      : *reinterpret_cast< ::vega::UpdateNetwork*>(&::vega::_UpdateNetwork_default_instance_);
}
inline ::vega::UpdateNetwork* ProposalTerms::mutable_updatenetwork() {
  if (!has_updatenetwork()) {
    clear_change();
    set_has_updatenetwork();
    change_.updatenetwork_ = CreateMaybeMessage< ::vega::UpdateNetwork >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:vega.ProposalTerms.updateNetwork)
  return change_.updatenetwork_;
}

// .vega.NewAsset newAsset = 104;
inline bool ProposalTerms::has_newasset() const {
  return change_case() == kNewAsset;
}
inline void ProposalTerms::set_has_newasset() {
  _oneof_case_[0] = kNewAsset;
}
inline void ProposalTerms::clear_newasset() {
  if (has_newasset()) {
    delete change_.newasset_;
    clear_has_change();
  }
}
inline ::vega::NewAsset* ProposalTerms::release_newasset() {
  // @@protoc_insertion_point(field_release:vega.ProposalTerms.newAsset)
  if (has_newasset()) {
    clear_has_change();
      ::vega::NewAsset* temp = change_.newasset_;
    change_.newasset_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vega::NewAsset& ProposalTerms::newasset() const {
  // @@protoc_insertion_point(field_get:vega.ProposalTerms.newAsset)
  return has_newasset()
      ? *change_.newasset_
      : *reinterpret_cast< ::vega::NewAsset*>(&::vega::_NewAsset_default_instance_);
}
inline ::vega::NewAsset* ProposalTerms::mutable_newasset() {
  if (!has_newasset()) {
    clear_change();
    set_has_newasset();
    change_.newasset_ = CreateMaybeMessage< ::vega::NewAsset >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:vega.ProposalTerms.newAsset)
  return change_.newasset_;
}

inline bool ProposalTerms::has_change() const {
  return change_case() != CHANGE_NOT_SET;
}
inline void ProposalTerms::clear_has_change() {
  _oneof_case_[0] = CHANGE_NOT_SET;
}
inline ProposalTerms::ChangeCase ProposalTerms::change_case() const {
  return ProposalTerms::ChangeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// GovernanceData

// .vega.Proposal proposal = 1;
inline bool GovernanceData::has_proposal() const {
  return this != internal_default_instance() && proposal_ != nullptr;
}
inline void GovernanceData::clear_proposal() {
  if (GetArenaNoVirtual() == nullptr && proposal_ != nullptr) {
    delete proposal_;
  }
  proposal_ = nullptr;
}
inline const ::vega::Proposal& GovernanceData::proposal() const {
  const ::vega::Proposal* p = proposal_;
  // @@protoc_insertion_point(field_get:vega.GovernanceData.proposal)
  return p != nullptr ? *p : *reinterpret_cast<const ::vega::Proposal*>(
      &::vega::_Proposal_default_instance_);
}
inline ::vega::Proposal* GovernanceData::release_proposal() {
  // @@protoc_insertion_point(field_release:vega.GovernanceData.proposal)
  
  ::vega::Proposal* temp = proposal_;
  proposal_ = nullptr;
  return temp;
}
inline ::vega::Proposal* GovernanceData::mutable_proposal() {
  
  if (proposal_ == nullptr) {
    auto* p = CreateMaybeMessage<::vega::Proposal>(GetArenaNoVirtual());
    proposal_ = p;
  }
  // @@protoc_insertion_point(field_mutable:vega.GovernanceData.proposal)
  return proposal_;
}
inline void GovernanceData::set_allocated_proposal(::vega::Proposal* proposal) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete proposal_;
  }
  if (proposal) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      proposal = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, proposal, submessage_arena);
    }
    
  } else {
    
  }
  proposal_ = proposal;
  // @@protoc_insertion_point(field_set_allocated:vega.GovernanceData.proposal)
}

// repeated .vega.Vote yes = 2;
inline int GovernanceData::yes_size() const {
  return yes_.size();
}
inline void GovernanceData::clear_yes() {
  yes_.Clear();
}
inline ::vega::Vote* GovernanceData::mutable_yes(int index) {
  // @@protoc_insertion_point(field_mutable:vega.GovernanceData.yes)
  return yes_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::vega::Vote >*
GovernanceData::mutable_yes() {
  // @@protoc_insertion_point(field_mutable_list:vega.GovernanceData.yes)
  return &yes_;
}
inline const ::vega::Vote& GovernanceData::yes(int index) const {
  // @@protoc_insertion_point(field_get:vega.GovernanceData.yes)
  return yes_.Get(index);
}
inline ::vega::Vote* GovernanceData::add_yes() {
  // @@protoc_insertion_point(field_add:vega.GovernanceData.yes)
  return yes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vega::Vote >&
GovernanceData::yes() const {
  // @@protoc_insertion_point(field_list:vega.GovernanceData.yes)
  return yes_;
}

// repeated .vega.Vote no = 3;
inline int GovernanceData::no_size() const {
  return no_.size();
}
inline void GovernanceData::clear_no() {
  no_.Clear();
}
inline ::vega::Vote* GovernanceData::mutable_no(int index) {
  // @@protoc_insertion_point(field_mutable:vega.GovernanceData.no)
  return no_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::vega::Vote >*
GovernanceData::mutable_no() {
  // @@protoc_insertion_point(field_mutable_list:vega.GovernanceData.no)
  return &no_;
}
inline const ::vega::Vote& GovernanceData::no(int index) const {
  // @@protoc_insertion_point(field_get:vega.GovernanceData.no)
  return no_.Get(index);
}
inline ::vega::Vote* GovernanceData::add_no() {
  // @@protoc_insertion_point(field_add:vega.GovernanceData.no)
  return no_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vega::Vote >&
GovernanceData::no() const {
  // @@protoc_insertion_point(field_list:vega.GovernanceData.no)
  return no_;
}

// -------------------------------------------------------------------

// Proposal

// string ID = 1;
inline void Proposal::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Proposal::id() const {
  // @@protoc_insertion_point(field_get:vega.Proposal.ID)
  return id_.GetNoArena();
}
inline void Proposal::set_id(const ::std::string& value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vega.Proposal.ID)
}
#if LANG_CXX11
inline void Proposal::set_id(::std::string&& value) {
  
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vega.Proposal.ID)
}
#endif
inline void Proposal::set_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vega.Proposal.ID)
}
inline void Proposal::set_id(const char* value, size_t size) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vega.Proposal.ID)
}
inline ::std::string* Proposal::mutable_id() {
  
  // @@protoc_insertion_point(field_mutable:vega.Proposal.ID)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Proposal::release_id() {
  // @@protoc_insertion_point(field_release:vega.Proposal.ID)
  
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Proposal::set_allocated_id(::std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:vega.Proposal.ID)
}

// string reference = 2;
inline void Proposal::clear_reference() {
  reference_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Proposal::reference() const {
  // @@protoc_insertion_point(field_get:vega.Proposal.reference)
  return reference_.GetNoArena();
}
inline void Proposal::set_reference(const ::std::string& value) {
  
  reference_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vega.Proposal.reference)
}
#if LANG_CXX11
inline void Proposal::set_reference(::std::string&& value) {
  
  reference_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vega.Proposal.reference)
}
#endif
inline void Proposal::set_reference(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  reference_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vega.Proposal.reference)
}
inline void Proposal::set_reference(const char* value, size_t size) {
  
  reference_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vega.Proposal.reference)
}
inline ::std::string* Proposal::mutable_reference() {
  
  // @@protoc_insertion_point(field_mutable:vega.Proposal.reference)
  return reference_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Proposal::release_reference() {
  // @@protoc_insertion_point(field_release:vega.Proposal.reference)
  
  return reference_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Proposal::set_allocated_reference(::std::string* reference) {
  if (reference != nullptr) {
    
  } else {
    
  }
  reference_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), reference);
  // @@protoc_insertion_point(field_set_allocated:vega.Proposal.reference)
}

// string partyID = 3 [(.validator.field) = {
inline void Proposal::clear_partyid() {
  partyid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Proposal::partyid() const {
  // @@protoc_insertion_point(field_get:vega.Proposal.partyID)
  return partyid_.GetNoArena();
}
inline void Proposal::set_partyid(const ::std::string& value) {
  
  partyid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vega.Proposal.partyID)
}
#if LANG_CXX11
inline void Proposal::set_partyid(::std::string&& value) {
  
  partyid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vega.Proposal.partyID)
}
#endif
inline void Proposal::set_partyid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  partyid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vega.Proposal.partyID)
}
inline void Proposal::set_partyid(const char* value, size_t size) {
  
  partyid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vega.Proposal.partyID)
}
inline ::std::string* Proposal::mutable_partyid() {
  
  // @@protoc_insertion_point(field_mutable:vega.Proposal.partyID)
  return partyid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Proposal::release_partyid() {
  // @@protoc_insertion_point(field_release:vega.Proposal.partyID)
  
  return partyid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Proposal::set_allocated_partyid(::std::string* partyid) {
  if (partyid != nullptr) {
    
  } else {
    
  }
  partyid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), partyid);
  // @@protoc_insertion_point(field_set_allocated:vega.Proposal.partyID)
}

// .vega.Proposal.State state = 4 [(.validator.field) = {
inline void Proposal::clear_state() {
  state_ = 0;
}
inline ::vega::Proposal_State Proposal::state() const {
  // @@protoc_insertion_point(field_get:vega.Proposal.state)
  return static_cast< ::vega::Proposal_State >(state_);
}
inline void Proposal::set_state(::vega::Proposal_State value) {
  
  state_ = value;
  // @@protoc_insertion_point(field_set:vega.Proposal.state)
}

// int64 timestamp = 5;
inline void Proposal::clear_timestamp() {
  timestamp_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 Proposal::timestamp() const {
  // @@protoc_insertion_point(field_get:vega.Proposal.timestamp)
  return timestamp_;
}
inline void Proposal::set_timestamp(::google::protobuf::int64 value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:vega.Proposal.timestamp)
}

// .vega.ProposalTerms terms = 6 [(.validator.field) = {
inline bool Proposal::has_terms() const {
  return this != internal_default_instance() && terms_ != nullptr;
}
inline void Proposal::clear_terms() {
  if (GetArenaNoVirtual() == nullptr && terms_ != nullptr) {
    delete terms_;
  }
  terms_ = nullptr;
}
inline const ::vega::ProposalTerms& Proposal::terms() const {
  const ::vega::ProposalTerms* p = terms_;
  // @@protoc_insertion_point(field_get:vega.Proposal.terms)
  return p != nullptr ? *p : *reinterpret_cast<const ::vega::ProposalTerms*>(
      &::vega::_ProposalTerms_default_instance_);
}
inline ::vega::ProposalTerms* Proposal::release_terms() {
  // @@protoc_insertion_point(field_release:vega.Proposal.terms)
  
  ::vega::ProposalTerms* temp = terms_;
  terms_ = nullptr;
  return temp;
}
inline ::vega::ProposalTerms* Proposal::mutable_terms() {
  
  if (terms_ == nullptr) {
    auto* p = CreateMaybeMessage<::vega::ProposalTerms>(GetArenaNoVirtual());
    terms_ = p;
  }
  // @@protoc_insertion_point(field_mutable:vega.Proposal.terms)
  return terms_;
}
inline void Proposal::set_allocated_terms(::vega::ProposalTerms* terms) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete terms_;
  }
  if (terms) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      terms = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, terms, submessage_arena);
    }
    
  } else {
    
  }
  terms_ = terms;
  // @@protoc_insertion_point(field_set_allocated:vega.Proposal.terms)
}

// -------------------------------------------------------------------

// Vote

// string partyID = 1 [(.validator.field) = {
inline void Vote::clear_partyid() {
  partyid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Vote::partyid() const {
  // @@protoc_insertion_point(field_get:vega.Vote.partyID)
  return partyid_.GetNoArena();
}
inline void Vote::set_partyid(const ::std::string& value) {
  
  partyid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vega.Vote.partyID)
}
#if LANG_CXX11
inline void Vote::set_partyid(::std::string&& value) {
  
  partyid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vega.Vote.partyID)
}
#endif
inline void Vote::set_partyid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  partyid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vega.Vote.partyID)
}
inline void Vote::set_partyid(const char* value, size_t size) {
  
  partyid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vega.Vote.partyID)
}
inline ::std::string* Vote::mutable_partyid() {
  
  // @@protoc_insertion_point(field_mutable:vega.Vote.partyID)
  return partyid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Vote::release_partyid() {
  // @@protoc_insertion_point(field_release:vega.Vote.partyID)
  
  return partyid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Vote::set_allocated_partyid(::std::string* partyid) {
  if (partyid != nullptr) {
    
  } else {
    
  }
  partyid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), partyid);
  // @@protoc_insertion_point(field_set_allocated:vega.Vote.partyID)
}

// .vega.Vote.Value value = 2 [(.validator.field) = {
inline void Vote::clear_value() {
  value_ = 0;
}
inline ::vega::Vote_Value Vote::value() const {
  // @@protoc_insertion_point(field_get:vega.Vote.value)
  return static_cast< ::vega::Vote_Value >(value_);
}
inline void Vote::set_value(::vega::Vote_Value value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:vega.Vote.value)
}

// string proposalID = 3 [(.validator.field) = {
inline void Vote::clear_proposalid() {
  proposalid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Vote::proposalid() const {
  // @@protoc_insertion_point(field_get:vega.Vote.proposalID)
  return proposalid_.GetNoArena();
}
inline void Vote::set_proposalid(const ::std::string& value) {
  
  proposalid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vega.Vote.proposalID)
}
#if LANG_CXX11
inline void Vote::set_proposalid(::std::string&& value) {
  
  proposalid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vega.Vote.proposalID)
}
#endif
inline void Vote::set_proposalid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  proposalid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vega.Vote.proposalID)
}
inline void Vote::set_proposalid(const char* value, size_t size) {
  
  proposalid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vega.Vote.proposalID)
}
inline ::std::string* Vote::mutable_proposalid() {
  
  // @@protoc_insertion_point(field_mutable:vega.Vote.proposalID)
  return proposalid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Vote::release_proposalid() {
  // @@protoc_insertion_point(field_release:vega.Vote.proposalID)
  
  return proposalid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Vote::set_allocated_proposalid(::std::string* proposalid) {
  if (proposalid != nullptr) {
    
  } else {
    
  }
  proposalid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), proposalid);
  // @@protoc_insertion_point(field_set_allocated:vega.Vote.proposalID)
}

// int64 timestamp = 4;
inline void Vote::clear_timestamp() {
  timestamp_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 Vote::timestamp() const {
  // @@protoc_insertion_point(field_get:vega.Vote.timestamp)
  return timestamp_;
}
inline void Vote::set_timestamp(::google::protobuf::int64 value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:vega.Vote.timestamp)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace vega

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::vega::Proposal_State> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::vega::Proposal_State>() {
  return ::vega::Proposal_State_descriptor();
}
template <> struct is_proto_enum< ::vega::Vote_Value> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::vega::Vote_Value>() {
  return ::vega::Vote_Value_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // PROTOBUF_INCLUDED_proto_2fgovernance_2eproto

// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: governance.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_governance_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_governance_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3014000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3014000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "github.com/mwitkow/go-proto-validators/validator.pb.h"
#include "markets.pb.h"
#include "vega.pb.h"
#include "assets.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_governance_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_governance_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[14]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_governance_2eproto;
namespace vega {
class FutureProduct;
class FutureProductDefaultTypeInternal;
extern FutureProductDefaultTypeInternal _FutureProduct_default_instance_;
class GovernanceData;
class GovernanceDataDefaultTypeInternal;
extern GovernanceDataDefaultTypeInternal _GovernanceData_default_instance_;
class GovernanceData_NoPartyEntry_DoNotUse;
class GovernanceData_NoPartyEntry_DoNotUseDefaultTypeInternal;
extern GovernanceData_NoPartyEntry_DoNotUseDefaultTypeInternal _GovernanceData_NoPartyEntry_DoNotUse_default_instance_;
class GovernanceData_YesPartyEntry_DoNotUse;
class GovernanceData_YesPartyEntry_DoNotUseDefaultTypeInternal;
extern GovernanceData_YesPartyEntry_DoNotUseDefaultTypeInternal _GovernanceData_YesPartyEntry_DoNotUse_default_instance_;
class InstrumentConfiguration;
class InstrumentConfigurationDefaultTypeInternal;
extern InstrumentConfigurationDefaultTypeInternal _InstrumentConfiguration_default_instance_;
class NewAsset;
class NewAssetDefaultTypeInternal;
extern NewAssetDefaultTypeInternal _NewAsset_default_instance_;
class NewMarket;
class NewMarketDefaultTypeInternal;
extern NewMarketDefaultTypeInternal _NewMarket_default_instance_;
class NewMarketCommitment;
class NewMarketCommitmentDefaultTypeInternal;
extern NewMarketCommitmentDefaultTypeInternal _NewMarketCommitment_default_instance_;
class NewMarketConfiguration;
class NewMarketConfigurationDefaultTypeInternal;
extern NewMarketConfigurationDefaultTypeInternal _NewMarketConfiguration_default_instance_;
class Proposal;
class ProposalDefaultTypeInternal;
extern ProposalDefaultTypeInternal _Proposal_default_instance_;
class ProposalTerms;
class ProposalTermsDefaultTypeInternal;
extern ProposalTermsDefaultTypeInternal _ProposalTerms_default_instance_;
class UpdateMarket;
class UpdateMarketDefaultTypeInternal;
extern UpdateMarketDefaultTypeInternal _UpdateMarket_default_instance_;
class UpdateNetworkParameter;
class UpdateNetworkParameterDefaultTypeInternal;
extern UpdateNetworkParameterDefaultTypeInternal _UpdateNetworkParameter_default_instance_;
class Vote;
class VoteDefaultTypeInternal;
extern VoteDefaultTypeInternal _Vote_default_instance_;
}  // namespace vega
PROTOBUF_NAMESPACE_OPEN
template<> ::vega::FutureProduct* Arena::CreateMaybeMessage<::vega::FutureProduct>(Arena*);
template<> ::vega::GovernanceData* Arena::CreateMaybeMessage<::vega::GovernanceData>(Arena*);
template<> ::vega::GovernanceData_NoPartyEntry_DoNotUse* Arena::CreateMaybeMessage<::vega::GovernanceData_NoPartyEntry_DoNotUse>(Arena*);
template<> ::vega::GovernanceData_YesPartyEntry_DoNotUse* Arena::CreateMaybeMessage<::vega::GovernanceData_YesPartyEntry_DoNotUse>(Arena*);
template<> ::vega::InstrumentConfiguration* Arena::CreateMaybeMessage<::vega::InstrumentConfiguration>(Arena*);
template<> ::vega::NewAsset* Arena::CreateMaybeMessage<::vega::NewAsset>(Arena*);
template<> ::vega::NewMarket* Arena::CreateMaybeMessage<::vega::NewMarket>(Arena*);
template<> ::vega::NewMarketCommitment* Arena::CreateMaybeMessage<::vega::NewMarketCommitment>(Arena*);
template<> ::vega::NewMarketConfiguration* Arena::CreateMaybeMessage<::vega::NewMarketConfiguration>(Arena*);
template<> ::vega::Proposal* Arena::CreateMaybeMessage<::vega::Proposal>(Arena*);
template<> ::vega::ProposalTerms* Arena::CreateMaybeMessage<::vega::ProposalTerms>(Arena*);
template<> ::vega::UpdateMarket* Arena::CreateMaybeMessage<::vega::UpdateMarket>(Arena*);
template<> ::vega::UpdateNetworkParameter* Arena::CreateMaybeMessage<::vega::UpdateNetworkParameter>(Arena*);
template<> ::vega::Vote* Arena::CreateMaybeMessage<::vega::Vote>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace vega {

enum Proposal_State : int {
  Proposal_State_STATE_UNSPECIFIED = 0,
  Proposal_State_STATE_FAILED = 1,
  Proposal_State_STATE_OPEN = 2,
  Proposal_State_STATE_PASSED = 3,
  Proposal_State_STATE_REJECTED = 4,
  Proposal_State_STATE_DECLINED = 5,
  Proposal_State_STATE_ENACTED = 6,
  Proposal_State_STATE_WAITING_FOR_NODE_VOTE = 7,
  Proposal_State_Proposal_State_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Proposal_State_Proposal_State_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Proposal_State_IsValid(int value);
constexpr Proposal_State Proposal_State_State_MIN = Proposal_State_STATE_UNSPECIFIED;
constexpr Proposal_State Proposal_State_State_MAX = Proposal_State_STATE_WAITING_FOR_NODE_VOTE;
constexpr int Proposal_State_State_ARRAYSIZE = Proposal_State_State_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Proposal_State_descriptor();
template<typename T>
inline const std::string& Proposal_State_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Proposal_State>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Proposal_State_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Proposal_State_descriptor(), enum_t_value);
}
inline bool Proposal_State_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Proposal_State* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Proposal_State>(
    Proposal_State_descriptor(), name, value);
}
enum Vote_Value : int {
  Vote_Value_VALUE_UNSPECIFIED = 0,
  Vote_Value_VALUE_NO = 1,
  Vote_Value_VALUE_YES = 2,
  Vote_Value_Vote_Value_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Vote_Value_Vote_Value_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Vote_Value_IsValid(int value);
constexpr Vote_Value Vote_Value_Value_MIN = Vote_Value_VALUE_UNSPECIFIED;
constexpr Vote_Value Vote_Value_Value_MAX = Vote_Value_VALUE_YES;
constexpr int Vote_Value_Value_ARRAYSIZE = Vote_Value_Value_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Vote_Value_descriptor();
template<typename T>
inline const std::string& Vote_Value_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Vote_Value>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Vote_Value_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Vote_Value_descriptor(), enum_t_value);
}
inline bool Vote_Value_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Vote_Value* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Vote_Value>(
    Vote_Value_descriptor(), name, value);
}
enum ProposalError : int {
  PROPOSAL_ERROR_UNSPECIFIED = 0,
  PROPOSAL_ERROR_CLOSE_TIME_TOO_SOON = 1,
  PROPOSAL_ERROR_CLOSE_TIME_TOO_LATE = 2,
  PROPOSAL_ERROR_ENACT_TIME_TOO_SOON = 3,
  PROPOSAL_ERROR_ENACT_TIME_TOO_LATE = 4,
  PROPOSAL_ERROR_INSUFFICIENT_TOKENS = 5,
  PROPOSAL_ERROR_INVALID_INSTRUMENT_SECURITY = 6,
  PROPOSAL_ERROR_NO_PRODUCT = 7,
  PROPOSAL_ERROR_UNSUPPORTED_PRODUCT = 8,
  PROPOSAL_ERROR_INVALID_FUTURE_PRODUCT_TIMESTAMP = 9,
  PROPOSAL_ERROR_PRODUCT_MATURITY_IS_PASSED = 10,
  PROPOSAL_ERROR_NO_TRADING_MODE = 11,
  PROPOSAL_ERROR_UNSUPPORTED_TRADING_MODE = 12,
  PROPOSAL_ERROR_NODE_VALIDATION_FAILED = 13,
  PROPOSAL_ERROR_MISSING_BUILTIN_ASSET_FIELD = 14,
  PROPOSAL_ERROR_MISSING_ERC20_CONTRACT_ADDRESS = 15,
  PROPOSAL_ERROR_INVALID_ASSET = 16,
  PROPOSAL_ERROR_INCOMPATIBLE_TIMESTAMPS = 17,
  PROPOSAL_ERROR_NO_RISK_PARAMETERS = 18,
  PROPOSAL_ERROR_NETWORK_PARAMETER_INVALID_KEY = 19,
  PROPOSAL_ERROR_NETWORK_PARAMETER_INVALID_VALUE = 20,
  PROPOSAL_ERROR_NETWORK_PARAMETER_VALIDATION_FAILED = 21,
  PROPOSAL_ERROR_OPENING_AUCTION_DURATION_TOO_SMALL = 22,
  PROPOSAL_ERROR_OPENING_AUCTION_DURATION_TOO_LARGE = 23,
  PROPOSAL_ERROR_MARKET_MISSING_LIQUIDITY_COMMITMENT = 24,
  PROPOSAL_ERROR_COULD_NOT_INSTANTIATE_MARKET = 25,
  ProposalError_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ProposalError_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ProposalError_IsValid(int value);
constexpr ProposalError ProposalError_MIN = PROPOSAL_ERROR_UNSPECIFIED;
constexpr ProposalError ProposalError_MAX = PROPOSAL_ERROR_COULD_NOT_INSTANTIATE_MARKET;
constexpr int ProposalError_ARRAYSIZE = ProposalError_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ProposalError_descriptor();
template<typename T>
inline const std::string& ProposalError_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ProposalError>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ProposalError_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ProposalError_descriptor(), enum_t_value);
}
inline bool ProposalError_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ProposalError* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ProposalError>(
    ProposalError_descriptor(), name, value);
}
// ===================================================================

class FutureProduct PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vega.FutureProduct) */ {
 public:
  inline FutureProduct() : FutureProduct(nullptr) {}
  virtual ~FutureProduct();

  FutureProduct(const FutureProduct& from);
  FutureProduct(FutureProduct&& from) noexcept
    : FutureProduct() {
    *this = ::std::move(from);
  }

  inline FutureProduct& operator=(const FutureProduct& from) {
    CopyFrom(from);
    return *this;
  }
  inline FutureProduct& operator=(FutureProduct&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const FutureProduct& default_instance();

  static inline const FutureProduct* internal_default_instance() {
    return reinterpret_cast<const FutureProduct*>(
               &_FutureProduct_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(FutureProduct& a, FutureProduct& b) {
    a.Swap(&b);
  }
  inline void Swap(FutureProduct* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FutureProduct* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FutureProduct* New() const final {
    return CreateMaybeMessage<FutureProduct>(nullptr);
  }

  FutureProduct* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FutureProduct>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const FutureProduct& from);
  void MergeFrom(const FutureProduct& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FutureProduct* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vega.FutureProduct";
  }
  protected:
  explicit FutureProduct(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_governance_2eproto);
    return ::descriptor_table_governance_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMaturityFieldNumber = 1,
    kSettlementAssetFieldNumber = 2,
    kQuoteNameFieldNumber = 3,
  };
  // string maturity = 1 [json_name = "maturity", (.validator.field) = {
  void clear_maturity();
  const std::string& maturity() const;
  void set_maturity(const std::string& value);
  void set_maturity(std::string&& value);
  void set_maturity(const char* value);
  void set_maturity(const char* value, size_t size);
  std::string* mutable_maturity();
  std::string* release_maturity();
  void set_allocated_maturity(std::string* maturity);
  private:
  const std::string& _internal_maturity() const;
  void _internal_set_maturity(const std::string& value);
  std::string* _internal_mutable_maturity();
  public:

  // string settlementAsset = 2 [json_name = "settlementAsset", (.validator.field) = {
  void clear_settlementasset();
  const std::string& settlementasset() const;
  void set_settlementasset(const std::string& value);
  void set_settlementasset(std::string&& value);
  void set_settlementasset(const char* value);
  void set_settlementasset(const char* value, size_t size);
  std::string* mutable_settlementasset();
  std::string* release_settlementasset();
  void set_allocated_settlementasset(std::string* settlementasset);
  private:
  const std::string& _internal_settlementasset() const;
  void _internal_set_settlementasset(const std::string& value);
  std::string* _internal_mutable_settlementasset();
  public:

  // string quoteName = 3 [json_name = "quoteName", (.validator.field) = {
  void clear_quotename();
  const std::string& quotename() const;
  void set_quotename(const std::string& value);
  void set_quotename(std::string&& value);
  void set_quotename(const char* value);
  void set_quotename(const char* value, size_t size);
  std::string* mutable_quotename();
  std::string* release_quotename();
  void set_allocated_quotename(std::string* quotename);
  private:
  const std::string& _internal_quotename() const;
  void _internal_set_quotename(const std::string& value);
  std::string* _internal_mutable_quotename();
  public:

  // @@protoc_insertion_point(class_scope:vega.FutureProduct)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr maturity_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr settlementasset_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr quotename_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_governance_2eproto;
};
// -------------------------------------------------------------------

class InstrumentConfiguration PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vega.InstrumentConfiguration) */ {
 public:
  inline InstrumentConfiguration() : InstrumentConfiguration(nullptr) {}
  virtual ~InstrumentConfiguration();

  InstrumentConfiguration(const InstrumentConfiguration& from);
  InstrumentConfiguration(InstrumentConfiguration&& from) noexcept
    : InstrumentConfiguration() {
    *this = ::std::move(from);
  }

  inline InstrumentConfiguration& operator=(const InstrumentConfiguration& from) {
    CopyFrom(from);
    return *this;
  }
  inline InstrumentConfiguration& operator=(InstrumentConfiguration&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const InstrumentConfiguration& default_instance();

  enum ProductCase {
    kFuture = 100,
    PRODUCT_NOT_SET = 0,
  };

  static inline const InstrumentConfiguration* internal_default_instance() {
    return reinterpret_cast<const InstrumentConfiguration*>(
               &_InstrumentConfiguration_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(InstrumentConfiguration& a, InstrumentConfiguration& b) {
    a.Swap(&b);
  }
  inline void Swap(InstrumentConfiguration* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InstrumentConfiguration* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline InstrumentConfiguration* New() const final {
    return CreateMaybeMessage<InstrumentConfiguration>(nullptr);
  }

  InstrumentConfiguration* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<InstrumentConfiguration>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const InstrumentConfiguration& from);
  void MergeFrom(const InstrumentConfiguration& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InstrumentConfiguration* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vega.InstrumentConfiguration";
  }
  protected:
  explicit InstrumentConfiguration(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_governance_2eproto);
    return ::descriptor_table_governance_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kCodeFieldNumber = 2,
    kFutureFieldNumber = 100,
  };
  // string name = 1 [json_name = "name", (.validator.field) = {
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string code = 2 [json_name = "code", (.validator.field) = {
  void clear_code();
  const std::string& code() const;
  void set_code(const std::string& value);
  void set_code(std::string&& value);
  void set_code(const char* value);
  void set_code(const char* value, size_t size);
  std::string* mutable_code();
  std::string* release_code();
  void set_allocated_code(std::string* code);
  private:
  const std::string& _internal_code() const;
  void _internal_set_code(const std::string& value);
  std::string* _internal_mutable_code();
  public:

  // .vega.FutureProduct future = 100 [json_name = "future"];
  bool has_future() const;
  private:
  bool _internal_has_future() const;
  public:
  void clear_future();
  const ::vega::FutureProduct& future() const;
  ::vega::FutureProduct* release_future();
  ::vega::FutureProduct* mutable_future();
  void set_allocated_future(::vega::FutureProduct* future);
  private:
  const ::vega::FutureProduct& _internal_future() const;
  ::vega::FutureProduct* _internal_mutable_future();
  public:
  void unsafe_arena_set_allocated_future(
      ::vega::FutureProduct* future);
  ::vega::FutureProduct* unsafe_arena_release_future();

  void clear_product();
  ProductCase product_case() const;
  // @@protoc_insertion_point(class_scope:vega.InstrumentConfiguration)
 private:
  class _Internal;
  void set_has_future();

  inline bool has_product() const;
  inline void clear_has_product();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr code_;
  union ProductUnion {
    ProductUnion() {}
    ::vega::FutureProduct* future_;
  } product_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_governance_2eproto;
};
// -------------------------------------------------------------------

class NewMarketConfiguration PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vega.NewMarketConfiguration) */ {
 public:
  inline NewMarketConfiguration() : NewMarketConfiguration(nullptr) {}
  virtual ~NewMarketConfiguration();

  NewMarketConfiguration(const NewMarketConfiguration& from);
  NewMarketConfiguration(NewMarketConfiguration&& from) noexcept
    : NewMarketConfiguration() {
    *this = ::std::move(from);
  }

  inline NewMarketConfiguration& operator=(const NewMarketConfiguration& from) {
    CopyFrom(from);
    return *this;
  }
  inline NewMarketConfiguration& operator=(NewMarketConfiguration&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const NewMarketConfiguration& default_instance();

  enum RiskParametersCase {
    kSimple = 100,
    kLogNormal = 101,
    RISKPARAMETERS_NOT_SET = 0,
  };

  enum TradingModeCase {
    kContinuous = 200,
    kDiscrete = 201,
    TRADINGMODE_NOT_SET = 0,
  };

  static inline const NewMarketConfiguration* internal_default_instance() {
    return reinterpret_cast<const NewMarketConfiguration*>(
               &_NewMarketConfiguration_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(NewMarketConfiguration& a, NewMarketConfiguration& b) {
    a.Swap(&b);
  }
  inline void Swap(NewMarketConfiguration* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NewMarketConfiguration* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NewMarketConfiguration* New() const final {
    return CreateMaybeMessage<NewMarketConfiguration>(nullptr);
  }

  NewMarketConfiguration* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NewMarketConfiguration>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const NewMarketConfiguration& from);
  void MergeFrom(const NewMarketConfiguration& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NewMarketConfiguration* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vega.NewMarketConfiguration";
  }
  protected:
  explicit NewMarketConfiguration(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_governance_2eproto);
    return ::descriptor_table_governance_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMetadataFieldNumber = 3,
    kInstrumentFieldNumber = 1,
    kPriceMonitoringParametersFieldNumber = 4,
    kDecimalPlacesFieldNumber = 2,
    kSimpleFieldNumber = 100,
    kLogNormalFieldNumber = 101,
    kContinuousFieldNumber = 200,
    kDiscreteFieldNumber = 201,
  };
  // repeated string metadata = 3 [json_name = "metadata"];
  int metadata_size() const;
  private:
  int _internal_metadata_size() const;
  public:
  void clear_metadata();
  const std::string& metadata(int index) const;
  std::string* mutable_metadata(int index);
  void set_metadata(int index, const std::string& value);
  void set_metadata(int index, std::string&& value);
  void set_metadata(int index, const char* value);
  void set_metadata(int index, const char* value, size_t size);
  std::string* add_metadata();
  void add_metadata(const std::string& value);
  void add_metadata(std::string&& value);
  void add_metadata(const char* value);
  void add_metadata(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& metadata() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_metadata();
  private:
  const std::string& _internal_metadata(int index) const;
  std::string* _internal_add_metadata();
  public:

  // .vega.InstrumentConfiguration instrument = 1 [json_name = "instrument", (.validator.field) = {
  bool has_instrument() const;
  private:
  bool _internal_has_instrument() const;
  public:
  void clear_instrument();
  const ::vega::InstrumentConfiguration& instrument() const;
  ::vega::InstrumentConfiguration* release_instrument();
  ::vega::InstrumentConfiguration* mutable_instrument();
  void set_allocated_instrument(::vega::InstrumentConfiguration* instrument);
  private:
  const ::vega::InstrumentConfiguration& _internal_instrument() const;
  ::vega::InstrumentConfiguration* _internal_mutable_instrument();
  public:
  void unsafe_arena_set_allocated_instrument(
      ::vega::InstrumentConfiguration* instrument);
  ::vega::InstrumentConfiguration* unsafe_arena_release_instrument();

  // .vega.PriceMonitoringParameters priceMonitoringParameters = 4 [json_name = "priceMonitoringParameters"];
  bool has_pricemonitoringparameters() const;
  private:
  bool _internal_has_pricemonitoringparameters() const;
  public:
  void clear_pricemonitoringparameters();
  const ::vega::PriceMonitoringParameters& pricemonitoringparameters() const;
  ::vega::PriceMonitoringParameters* release_pricemonitoringparameters();
  ::vega::PriceMonitoringParameters* mutable_pricemonitoringparameters();
  void set_allocated_pricemonitoringparameters(::vega::PriceMonitoringParameters* pricemonitoringparameters);
  private:
  const ::vega::PriceMonitoringParameters& _internal_pricemonitoringparameters() const;
  ::vega::PriceMonitoringParameters* _internal_mutable_pricemonitoringparameters();
  public:
  void unsafe_arena_set_allocated_pricemonitoringparameters(
      ::vega::PriceMonitoringParameters* pricemonitoringparameters);
  ::vega::PriceMonitoringParameters* unsafe_arena_release_pricemonitoringparameters();

  // uint64 decimalPlaces = 2 [json_name = "decimalPlaces", (.validator.field) = {
  void clear_decimalplaces();
  ::PROTOBUF_NAMESPACE_ID::uint64 decimalplaces() const;
  void set_decimalplaces(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_decimalplaces() const;
  void _internal_set_decimalplaces(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // .vega.SimpleModelParams simple = 100 [json_name = "simple"];
  bool has_simple() const;
  private:
  bool _internal_has_simple() const;
  public:
  void clear_simple();
  const ::vega::SimpleModelParams& simple() const;
  ::vega::SimpleModelParams* release_simple();
  ::vega::SimpleModelParams* mutable_simple();
  void set_allocated_simple(::vega::SimpleModelParams* simple);
  private:
  const ::vega::SimpleModelParams& _internal_simple() const;
  ::vega::SimpleModelParams* _internal_mutable_simple();
  public:
  void unsafe_arena_set_allocated_simple(
      ::vega::SimpleModelParams* simple);
  ::vega::SimpleModelParams* unsafe_arena_release_simple();

  // .vega.LogNormalRiskModel logNormal = 101 [json_name = "logNormal"];
  bool has_lognormal() const;
  private:
  bool _internal_has_lognormal() const;
  public:
  void clear_lognormal();
  const ::vega::LogNormalRiskModel& lognormal() const;
  ::vega::LogNormalRiskModel* release_lognormal();
  ::vega::LogNormalRiskModel* mutable_lognormal();
  void set_allocated_lognormal(::vega::LogNormalRiskModel* lognormal);
  private:
  const ::vega::LogNormalRiskModel& _internal_lognormal() const;
  ::vega::LogNormalRiskModel* _internal_mutable_lognormal();
  public:
  void unsafe_arena_set_allocated_lognormal(
      ::vega::LogNormalRiskModel* lognormal);
  ::vega::LogNormalRiskModel* unsafe_arena_release_lognormal();

  // .vega.ContinuousTrading continuous = 200 [json_name = "continuous"];
  bool has_continuous() const;
  private:
  bool _internal_has_continuous() const;
  public:
  void clear_continuous();
  const ::vega::ContinuousTrading& continuous() const;
  ::vega::ContinuousTrading* release_continuous();
  ::vega::ContinuousTrading* mutable_continuous();
  void set_allocated_continuous(::vega::ContinuousTrading* continuous);
  private:
  const ::vega::ContinuousTrading& _internal_continuous() const;
  ::vega::ContinuousTrading* _internal_mutable_continuous();
  public:
  void unsafe_arena_set_allocated_continuous(
      ::vega::ContinuousTrading* continuous);
  ::vega::ContinuousTrading* unsafe_arena_release_continuous();

  // .vega.DiscreteTrading discrete = 201 [json_name = "discrete"];
  bool has_discrete() const;
  private:
  bool _internal_has_discrete() const;
  public:
  void clear_discrete();
  const ::vega::DiscreteTrading& discrete() const;
  ::vega::DiscreteTrading* release_discrete();
  ::vega::DiscreteTrading* mutable_discrete();
  void set_allocated_discrete(::vega::DiscreteTrading* discrete);
  private:
  const ::vega::DiscreteTrading& _internal_discrete() const;
  ::vega::DiscreteTrading* _internal_mutable_discrete();
  public:
  void unsafe_arena_set_allocated_discrete(
      ::vega::DiscreteTrading* discrete);
  ::vega::DiscreteTrading* unsafe_arena_release_discrete();

  void clear_riskParameters();
  RiskParametersCase riskParameters_case() const;
  void clear_tradingMode();
  TradingModeCase tradingMode_case() const;
  // @@protoc_insertion_point(class_scope:vega.NewMarketConfiguration)
 private:
  class _Internal;
  void set_has_simple();
  void set_has_lognormal();
  void set_has_continuous();
  void set_has_discrete();

  inline bool has_riskParameters() const;
  inline void clear_has_riskParameters();

  inline bool has_tradingMode() const;
  inline void clear_has_tradingMode();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> metadata_;
  ::vega::InstrumentConfiguration* instrument_;
  ::vega::PriceMonitoringParameters* pricemonitoringparameters_;
  ::PROTOBUF_NAMESPACE_ID::uint64 decimalplaces_;
  union RiskParametersUnion {
    RiskParametersUnion() {}
    ::vega::SimpleModelParams* simple_;
    ::vega::LogNormalRiskModel* lognormal_;
  } riskParameters_;
  union TradingModeUnion {
    TradingModeUnion() {}
    ::vega::ContinuousTrading* continuous_;
    ::vega::DiscreteTrading* discrete_;
  } tradingMode_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[2];

  friend struct ::TableStruct_governance_2eproto;
};
// -------------------------------------------------------------------

class NewMarketCommitment PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vega.NewMarketCommitment) */ {
 public:
  inline NewMarketCommitment() : NewMarketCommitment(nullptr) {}
  virtual ~NewMarketCommitment();

  NewMarketCommitment(const NewMarketCommitment& from);
  NewMarketCommitment(NewMarketCommitment&& from) noexcept
    : NewMarketCommitment() {
    *this = ::std::move(from);
  }

  inline NewMarketCommitment& operator=(const NewMarketCommitment& from) {
    CopyFrom(from);
    return *this;
  }
  inline NewMarketCommitment& operator=(NewMarketCommitment&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const NewMarketCommitment& default_instance();

  static inline const NewMarketCommitment* internal_default_instance() {
    return reinterpret_cast<const NewMarketCommitment*>(
               &_NewMarketCommitment_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(NewMarketCommitment& a, NewMarketCommitment& b) {
    a.Swap(&b);
  }
  inline void Swap(NewMarketCommitment* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NewMarketCommitment* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NewMarketCommitment* New() const final {
    return CreateMaybeMessage<NewMarketCommitment>(nullptr);
  }

  NewMarketCommitment* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NewMarketCommitment>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const NewMarketCommitment& from);
  void MergeFrom(const NewMarketCommitment& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NewMarketCommitment* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vega.NewMarketCommitment";
  }
  protected:
  explicit NewMarketCommitment(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_governance_2eproto);
    return ::descriptor_table_governance_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSellsFieldNumber = 3,
    kBuysFieldNumber = 4,
    kFeeFieldNumber = 2,
    kCommitmentAmountFieldNumber = 1,
  };
  // repeated .vega.LiquidityOrder Sells = 3 [json_name = "Sells"];
  int sells_size() const;
  private:
  int _internal_sells_size() const;
  public:
  void clear_sells();
  ::vega::LiquidityOrder* mutable_sells(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vega::LiquidityOrder >*
      mutable_sells();
  private:
  const ::vega::LiquidityOrder& _internal_sells(int index) const;
  ::vega::LiquidityOrder* _internal_add_sells();
  public:
  const ::vega::LiquidityOrder& sells(int index) const;
  ::vega::LiquidityOrder* add_sells();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vega::LiquidityOrder >&
      sells() const;

  // repeated .vega.LiquidityOrder Buys = 4 [json_name = "Buys"];
  int buys_size() const;
  private:
  int _internal_buys_size() const;
  public:
  void clear_buys();
  ::vega::LiquidityOrder* mutable_buys(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vega::LiquidityOrder >*
      mutable_buys();
  private:
  const ::vega::LiquidityOrder& _internal_buys(int index) const;
  ::vega::LiquidityOrder* _internal_add_buys();
  public:
  const ::vega::LiquidityOrder& buys(int index) const;
  ::vega::LiquidityOrder* add_buys();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vega::LiquidityOrder >&
      buys() const;

  // string fee = 2 [json_name = "fee"];
  void clear_fee();
  const std::string& fee() const;
  void set_fee(const std::string& value);
  void set_fee(std::string&& value);
  void set_fee(const char* value);
  void set_fee(const char* value, size_t size);
  std::string* mutable_fee();
  std::string* release_fee();
  void set_allocated_fee(std::string* fee);
  private:
  const std::string& _internal_fee() const;
  void _internal_set_fee(const std::string& value);
  std::string* _internal_mutable_fee();
  public:

  // uint64 commitmentAmount = 1 [json_name = "commitmentAmount"];
  void clear_commitmentamount();
  ::PROTOBUF_NAMESPACE_ID::uint64 commitmentamount() const;
  void set_commitmentamount(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_commitmentamount() const;
  void _internal_set_commitmentamount(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:vega.NewMarketCommitment)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vega::LiquidityOrder > sells_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vega::LiquidityOrder > buys_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fee_;
  ::PROTOBUF_NAMESPACE_ID::uint64 commitmentamount_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_governance_2eproto;
};
// -------------------------------------------------------------------

class NewMarket PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vega.NewMarket) */ {
 public:
  inline NewMarket() : NewMarket(nullptr) {}
  virtual ~NewMarket();

  NewMarket(const NewMarket& from);
  NewMarket(NewMarket&& from) noexcept
    : NewMarket() {
    *this = ::std::move(from);
  }

  inline NewMarket& operator=(const NewMarket& from) {
    CopyFrom(from);
    return *this;
  }
  inline NewMarket& operator=(NewMarket&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const NewMarket& default_instance();

  static inline const NewMarket* internal_default_instance() {
    return reinterpret_cast<const NewMarket*>(
               &_NewMarket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(NewMarket& a, NewMarket& b) {
    a.Swap(&b);
  }
  inline void Swap(NewMarket* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NewMarket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NewMarket* New() const final {
    return CreateMaybeMessage<NewMarket>(nullptr);
  }

  NewMarket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NewMarket>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const NewMarket& from);
  void MergeFrom(const NewMarket& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NewMarket* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vega.NewMarket";
  }
  protected:
  explicit NewMarket(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_governance_2eproto);
    return ::descriptor_table_governance_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChangesFieldNumber = 1,
    kLiquidityCommitmentFieldNumber = 2,
  };
  // .vega.NewMarketConfiguration changes = 1 [json_name = "changes", (.validator.field) = {
  bool has_changes() const;
  private:
  bool _internal_has_changes() const;
  public:
  void clear_changes();
  const ::vega::NewMarketConfiguration& changes() const;
  ::vega::NewMarketConfiguration* release_changes();
  ::vega::NewMarketConfiguration* mutable_changes();
  void set_allocated_changes(::vega::NewMarketConfiguration* changes);
  private:
  const ::vega::NewMarketConfiguration& _internal_changes() const;
  ::vega::NewMarketConfiguration* _internal_mutable_changes();
  public:
  void unsafe_arena_set_allocated_changes(
      ::vega::NewMarketConfiguration* changes);
  ::vega::NewMarketConfiguration* unsafe_arena_release_changes();

  // .vega.NewMarketCommitment liquidityCommitment = 2 [json_name = "liquidityCommitment"];
  bool has_liquiditycommitment() const;
  private:
  bool _internal_has_liquiditycommitment() const;
  public:
  void clear_liquiditycommitment();
  const ::vega::NewMarketCommitment& liquiditycommitment() const;
  ::vega::NewMarketCommitment* release_liquiditycommitment();
  ::vega::NewMarketCommitment* mutable_liquiditycommitment();
  void set_allocated_liquiditycommitment(::vega::NewMarketCommitment* liquiditycommitment);
  private:
  const ::vega::NewMarketCommitment& _internal_liquiditycommitment() const;
  ::vega::NewMarketCommitment* _internal_mutable_liquiditycommitment();
  public:
  void unsafe_arena_set_allocated_liquiditycommitment(
      ::vega::NewMarketCommitment* liquiditycommitment);
  ::vega::NewMarketCommitment* unsafe_arena_release_liquiditycommitment();

  // @@protoc_insertion_point(class_scope:vega.NewMarket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::vega::NewMarketConfiguration* changes_;
  ::vega::NewMarketCommitment* liquiditycommitment_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_governance_2eproto;
};
// -------------------------------------------------------------------

class UpdateMarket PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vega.UpdateMarket) */ {
 public:
  inline UpdateMarket() : UpdateMarket(nullptr) {}
  virtual ~UpdateMarket();

  UpdateMarket(const UpdateMarket& from);
  UpdateMarket(UpdateMarket&& from) noexcept
    : UpdateMarket() {
    *this = ::std::move(from);
  }

  inline UpdateMarket& operator=(const UpdateMarket& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateMarket& operator=(UpdateMarket&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UpdateMarket& default_instance();

  static inline const UpdateMarket* internal_default_instance() {
    return reinterpret_cast<const UpdateMarket*>(
               &_UpdateMarket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(UpdateMarket& a, UpdateMarket& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateMarket* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateMarket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UpdateMarket* New() const final {
    return CreateMaybeMessage<UpdateMarket>(nullptr);
  }

  UpdateMarket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UpdateMarket>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UpdateMarket& from);
  void MergeFrom(const UpdateMarket& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateMarket* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vega.UpdateMarket";
  }
  protected:
  explicit UpdateMarket(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_governance_2eproto);
    return ::descriptor_table_governance_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:vega.UpdateMarket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_governance_2eproto;
};
// -------------------------------------------------------------------

class UpdateNetworkParameter PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vega.UpdateNetworkParameter) */ {
 public:
  inline UpdateNetworkParameter() : UpdateNetworkParameter(nullptr) {}
  virtual ~UpdateNetworkParameter();

  UpdateNetworkParameter(const UpdateNetworkParameter& from);
  UpdateNetworkParameter(UpdateNetworkParameter&& from) noexcept
    : UpdateNetworkParameter() {
    *this = ::std::move(from);
  }

  inline UpdateNetworkParameter& operator=(const UpdateNetworkParameter& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateNetworkParameter& operator=(UpdateNetworkParameter&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UpdateNetworkParameter& default_instance();

  static inline const UpdateNetworkParameter* internal_default_instance() {
    return reinterpret_cast<const UpdateNetworkParameter*>(
               &_UpdateNetworkParameter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(UpdateNetworkParameter& a, UpdateNetworkParameter& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateNetworkParameter* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateNetworkParameter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UpdateNetworkParameter* New() const final {
    return CreateMaybeMessage<UpdateNetworkParameter>(nullptr);
  }

  UpdateNetworkParameter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UpdateNetworkParameter>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UpdateNetworkParameter& from);
  void MergeFrom(const UpdateNetworkParameter& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateNetworkParameter* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vega.UpdateNetworkParameter";
  }
  protected:
  explicit UpdateNetworkParameter(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_governance_2eproto);
    return ::descriptor_table_governance_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChangesFieldNumber = 1,
  };
  // .vega.NetworkParameter changes = 1 [json_name = "changes", (.validator.field) = {
  bool has_changes() const;
  private:
  bool _internal_has_changes() const;
  public:
  void clear_changes();
  const ::vega::NetworkParameter& changes() const;
  ::vega::NetworkParameter* release_changes();
  ::vega::NetworkParameter* mutable_changes();
  void set_allocated_changes(::vega::NetworkParameter* changes);
  private:
  const ::vega::NetworkParameter& _internal_changes() const;
  ::vega::NetworkParameter* _internal_mutable_changes();
  public:
  void unsafe_arena_set_allocated_changes(
      ::vega::NetworkParameter* changes);
  ::vega::NetworkParameter* unsafe_arena_release_changes();

  // @@protoc_insertion_point(class_scope:vega.UpdateNetworkParameter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::vega::NetworkParameter* changes_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_governance_2eproto;
};
// -------------------------------------------------------------------

class NewAsset PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vega.NewAsset) */ {
 public:
  inline NewAsset() : NewAsset(nullptr) {}
  virtual ~NewAsset();

  NewAsset(const NewAsset& from);
  NewAsset(NewAsset&& from) noexcept
    : NewAsset() {
    *this = ::std::move(from);
  }

  inline NewAsset& operator=(const NewAsset& from) {
    CopyFrom(from);
    return *this;
  }
  inline NewAsset& operator=(NewAsset&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const NewAsset& default_instance();

  static inline const NewAsset* internal_default_instance() {
    return reinterpret_cast<const NewAsset*>(
               &_NewAsset_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(NewAsset& a, NewAsset& b) {
    a.Swap(&b);
  }
  inline void Swap(NewAsset* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NewAsset* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NewAsset* New() const final {
    return CreateMaybeMessage<NewAsset>(nullptr);
  }

  NewAsset* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NewAsset>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const NewAsset& from);
  void MergeFrom(const NewAsset& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NewAsset* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vega.NewAsset";
  }
  protected:
  explicit NewAsset(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_governance_2eproto);
    return ::descriptor_table_governance_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChangesFieldNumber = 1,
  };
  // .vega.AssetSource changes = 1 [json_name = "changes", (.validator.field) = {
  bool has_changes() const;
  private:
  bool _internal_has_changes() const;
  public:
  void clear_changes();
  const ::vega::AssetSource& changes() const;
  ::vega::AssetSource* release_changes();
  ::vega::AssetSource* mutable_changes();
  void set_allocated_changes(::vega::AssetSource* changes);
  private:
  const ::vega::AssetSource& _internal_changes() const;
  ::vega::AssetSource* _internal_mutable_changes();
  public:
  void unsafe_arena_set_allocated_changes(
      ::vega::AssetSource* changes);
  ::vega::AssetSource* unsafe_arena_release_changes();

  // @@protoc_insertion_point(class_scope:vega.NewAsset)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::vega::AssetSource* changes_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_governance_2eproto;
};
// -------------------------------------------------------------------

class ProposalTerms PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vega.ProposalTerms) */ {
 public:
  inline ProposalTerms() : ProposalTerms(nullptr) {}
  virtual ~ProposalTerms();

  ProposalTerms(const ProposalTerms& from);
  ProposalTerms(ProposalTerms&& from) noexcept
    : ProposalTerms() {
    *this = ::std::move(from);
  }

  inline ProposalTerms& operator=(const ProposalTerms& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProposalTerms& operator=(ProposalTerms&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ProposalTerms& default_instance();

  enum ChangeCase {
    kUpdateMarket = 101,
    kNewMarket = 102,
    kUpdateNetworkParameter = 103,
    kNewAsset = 104,
    CHANGE_NOT_SET = 0,
  };

  static inline const ProposalTerms* internal_default_instance() {
    return reinterpret_cast<const ProposalTerms*>(
               &_ProposalTerms_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ProposalTerms& a, ProposalTerms& b) {
    a.Swap(&b);
  }
  inline void Swap(ProposalTerms* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProposalTerms* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ProposalTerms* New() const final {
    return CreateMaybeMessage<ProposalTerms>(nullptr);
  }

  ProposalTerms* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ProposalTerms>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ProposalTerms& from);
  void MergeFrom(const ProposalTerms& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProposalTerms* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vega.ProposalTerms";
  }
  protected:
  explicit ProposalTerms(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_governance_2eproto);
    return ::descriptor_table_governance_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClosingTimestampFieldNumber = 1,
    kEnactmentTimestampFieldNumber = 2,
    kValidationTimestampFieldNumber = 3,
    kUpdateMarketFieldNumber = 101,
    kNewMarketFieldNumber = 102,
    kUpdateNetworkParameterFieldNumber = 103,
    kNewAssetFieldNumber = 104,
  };
  // int64 closingTimestamp = 1 [json_name = "closingTimestamp", (.validator.field) = {
  void clear_closingtimestamp();
  ::PROTOBUF_NAMESPACE_ID::int64 closingtimestamp() const;
  void set_closingtimestamp(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_closingtimestamp() const;
  void _internal_set_closingtimestamp(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 enactmentTimestamp = 2 [json_name = "enactmentTimestamp", (.validator.field) = {
  void clear_enactmenttimestamp();
  ::PROTOBUF_NAMESPACE_ID::int64 enactmenttimestamp() const;
  void set_enactmenttimestamp(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_enactmenttimestamp() const;
  void _internal_set_enactmenttimestamp(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 validationTimestamp = 3 [json_name = "validationTimestamp"];
  void clear_validationtimestamp();
  ::PROTOBUF_NAMESPACE_ID::int64 validationtimestamp() const;
  void set_validationtimestamp(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_validationtimestamp() const;
  void _internal_set_validationtimestamp(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // .vega.UpdateMarket updateMarket = 101 [json_name = "updateMarket"];
  bool has_updatemarket() const;
  private:
  bool _internal_has_updatemarket() const;
  public:
  void clear_updatemarket();
  const ::vega::UpdateMarket& updatemarket() const;
  ::vega::UpdateMarket* release_updatemarket();
  ::vega::UpdateMarket* mutable_updatemarket();
  void set_allocated_updatemarket(::vega::UpdateMarket* updatemarket);
  private:
  const ::vega::UpdateMarket& _internal_updatemarket() const;
  ::vega::UpdateMarket* _internal_mutable_updatemarket();
  public:
  void unsafe_arena_set_allocated_updatemarket(
      ::vega::UpdateMarket* updatemarket);
  ::vega::UpdateMarket* unsafe_arena_release_updatemarket();

  // .vega.NewMarket newMarket = 102 [json_name = "newMarket"];
  bool has_newmarket() const;
  private:
  bool _internal_has_newmarket() const;
  public:
  void clear_newmarket();
  const ::vega::NewMarket& newmarket() const;
  ::vega::NewMarket* release_newmarket();
  ::vega::NewMarket* mutable_newmarket();
  void set_allocated_newmarket(::vega::NewMarket* newmarket);
  private:
  const ::vega::NewMarket& _internal_newmarket() const;
  ::vega::NewMarket* _internal_mutable_newmarket();
  public:
  void unsafe_arena_set_allocated_newmarket(
      ::vega::NewMarket* newmarket);
  ::vega::NewMarket* unsafe_arena_release_newmarket();

  // .vega.UpdateNetworkParameter updateNetworkParameter = 103 [json_name = "updateNetworkParameter"];
  bool has_updatenetworkparameter() const;
  private:
  bool _internal_has_updatenetworkparameter() const;
  public:
  void clear_updatenetworkparameter();
  const ::vega::UpdateNetworkParameter& updatenetworkparameter() const;
  ::vega::UpdateNetworkParameter* release_updatenetworkparameter();
  ::vega::UpdateNetworkParameter* mutable_updatenetworkparameter();
  void set_allocated_updatenetworkparameter(::vega::UpdateNetworkParameter* updatenetworkparameter);
  private:
  const ::vega::UpdateNetworkParameter& _internal_updatenetworkparameter() const;
  ::vega::UpdateNetworkParameter* _internal_mutable_updatenetworkparameter();
  public:
  void unsafe_arena_set_allocated_updatenetworkparameter(
      ::vega::UpdateNetworkParameter* updatenetworkparameter);
  ::vega::UpdateNetworkParameter* unsafe_arena_release_updatenetworkparameter();

  // .vega.NewAsset newAsset = 104 [json_name = "newAsset"];
  bool has_newasset() const;
  private:
  bool _internal_has_newasset() const;
  public:
  void clear_newasset();
  const ::vega::NewAsset& newasset() const;
  ::vega::NewAsset* release_newasset();
  ::vega::NewAsset* mutable_newasset();
  void set_allocated_newasset(::vega::NewAsset* newasset);
  private:
  const ::vega::NewAsset& _internal_newasset() const;
  ::vega::NewAsset* _internal_mutable_newasset();
  public:
  void unsafe_arena_set_allocated_newasset(
      ::vega::NewAsset* newasset);
  ::vega::NewAsset* unsafe_arena_release_newasset();

  void clear_change();
  ChangeCase change_case() const;
  // @@protoc_insertion_point(class_scope:vega.ProposalTerms)
 private:
  class _Internal;
  void set_has_updatemarket();
  void set_has_newmarket();
  void set_has_updatenetworkparameter();
  void set_has_newasset();

  inline bool has_change() const;
  inline void clear_has_change();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int64 closingtimestamp_;
  ::PROTOBUF_NAMESPACE_ID::int64 enactmenttimestamp_;
  ::PROTOBUF_NAMESPACE_ID::int64 validationtimestamp_;
  union ChangeUnion {
    ChangeUnion() {}
    ::vega::UpdateMarket* updatemarket_;
    ::vega::NewMarket* newmarket_;
    ::vega::UpdateNetworkParameter* updatenetworkparameter_;
    ::vega::NewAsset* newasset_;
  } change_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_governance_2eproto;
};
// -------------------------------------------------------------------

class GovernanceData_YesPartyEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<GovernanceData_YesPartyEntry_DoNotUse,
    std::string, ::vega::Vote,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<GovernanceData_YesPartyEntry_DoNotUse,
    std::string, ::vega::Vote,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  GovernanceData_YesPartyEntry_DoNotUse();
  explicit GovernanceData_YesPartyEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const GovernanceData_YesPartyEntry_DoNotUse& other);
  static const GovernanceData_YesPartyEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const GovernanceData_YesPartyEntry_DoNotUse*>(&_GovernanceData_YesPartyEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "vega.GovernanceData.YesPartyEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_governance_2eproto);
    return ::descriptor_table_governance_2eproto.file_level_metadata[9];
  }

  public:
};

// -------------------------------------------------------------------

class GovernanceData_NoPartyEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<GovernanceData_NoPartyEntry_DoNotUse,
    std::string, ::vega::Vote,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<GovernanceData_NoPartyEntry_DoNotUse,
    std::string, ::vega::Vote,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  GovernanceData_NoPartyEntry_DoNotUse();
  explicit GovernanceData_NoPartyEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const GovernanceData_NoPartyEntry_DoNotUse& other);
  static const GovernanceData_NoPartyEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const GovernanceData_NoPartyEntry_DoNotUse*>(&_GovernanceData_NoPartyEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "vega.GovernanceData.NoPartyEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_governance_2eproto);
    return ::descriptor_table_governance_2eproto.file_level_metadata[10];
  }

  public:
};

// -------------------------------------------------------------------

class GovernanceData PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vega.GovernanceData) */ {
 public:
  inline GovernanceData() : GovernanceData(nullptr) {}
  virtual ~GovernanceData();

  GovernanceData(const GovernanceData& from);
  GovernanceData(GovernanceData&& from) noexcept
    : GovernanceData() {
    *this = ::std::move(from);
  }

  inline GovernanceData& operator=(const GovernanceData& from) {
    CopyFrom(from);
    return *this;
  }
  inline GovernanceData& operator=(GovernanceData&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GovernanceData& default_instance();

  static inline const GovernanceData* internal_default_instance() {
    return reinterpret_cast<const GovernanceData*>(
               &_GovernanceData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(GovernanceData& a, GovernanceData& b) {
    a.Swap(&b);
  }
  inline void Swap(GovernanceData* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GovernanceData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GovernanceData* New() const final {
    return CreateMaybeMessage<GovernanceData>(nullptr);
  }

  GovernanceData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GovernanceData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GovernanceData& from);
  void MergeFrom(const GovernanceData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GovernanceData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vega.GovernanceData";
  }
  protected:
  explicit GovernanceData(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_governance_2eproto);
    return ::descriptor_table_governance_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kYesFieldNumber = 2,
    kNoFieldNumber = 3,
    kYesPartyFieldNumber = 4,
    kNoPartyFieldNumber = 5,
    kProposalFieldNumber = 1,
  };
  // repeated .vega.Vote yes = 2 [json_name = "yes"];
  int yes_size() const;
  private:
  int _internal_yes_size() const;
  public:
  void clear_yes();
  ::vega::Vote* mutable_yes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vega::Vote >*
      mutable_yes();
  private:
  const ::vega::Vote& _internal_yes(int index) const;
  ::vega::Vote* _internal_add_yes();
  public:
  const ::vega::Vote& yes(int index) const;
  ::vega::Vote* add_yes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vega::Vote >&
      yes() const;

  // repeated .vega.Vote no = 3 [json_name = "no"];
  int no_size() const;
  private:
  int _internal_no_size() const;
  public:
  void clear_no();
  ::vega::Vote* mutable_no(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vega::Vote >*
      mutable_no();
  private:
  const ::vega::Vote& _internal_no(int index) const;
  ::vega::Vote* _internal_add_no();
  public:
  const ::vega::Vote& no(int index) const;
  ::vega::Vote* add_no();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vega::Vote >&
      no() const;

  // map<string, .vega.Vote> yesParty = 4 [json_name = "yesParty"];
  int yesparty_size() const;
  private:
  int _internal_yesparty_size() const;
  public:
  void clear_yesparty();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::vega::Vote >&
      _internal_yesparty() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::vega::Vote >*
      _internal_mutable_yesparty();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::vega::Vote >&
      yesparty() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::vega::Vote >*
      mutable_yesparty();

  // map<string, .vega.Vote> noParty = 5 [json_name = "noParty"];
  int noparty_size() const;
  private:
  int _internal_noparty_size() const;
  public:
  void clear_noparty();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::vega::Vote >&
      _internal_noparty() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::vega::Vote >*
      _internal_mutable_noparty();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::vega::Vote >&
      noparty() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::vega::Vote >*
      mutable_noparty();

  // .vega.Proposal proposal = 1 [json_name = "proposal"];
  bool has_proposal() const;
  private:
  bool _internal_has_proposal() const;
  public:
  void clear_proposal();
  const ::vega::Proposal& proposal() const;
  ::vega::Proposal* release_proposal();
  ::vega::Proposal* mutable_proposal();
  void set_allocated_proposal(::vega::Proposal* proposal);
  private:
  const ::vega::Proposal& _internal_proposal() const;
  ::vega::Proposal* _internal_mutable_proposal();
  public:
  void unsafe_arena_set_allocated_proposal(
      ::vega::Proposal* proposal);
  ::vega::Proposal* unsafe_arena_release_proposal();

  // @@protoc_insertion_point(class_scope:vega.GovernanceData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vega::Vote > yes_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vega::Vote > no_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      GovernanceData_YesPartyEntry_DoNotUse,
      std::string, ::vega::Vote,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> yesparty_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      GovernanceData_NoPartyEntry_DoNotUse,
      std::string, ::vega::Vote,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> noparty_;
  ::vega::Proposal* proposal_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_governance_2eproto;
};
// -------------------------------------------------------------------

class Proposal PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vega.Proposal) */ {
 public:
  inline Proposal() : Proposal(nullptr) {}
  virtual ~Proposal();

  Proposal(const Proposal& from);
  Proposal(Proposal&& from) noexcept
    : Proposal() {
    *this = ::std::move(from);
  }

  inline Proposal& operator=(const Proposal& from) {
    CopyFrom(from);
    return *this;
  }
  inline Proposal& operator=(Proposal&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Proposal& default_instance();

  static inline const Proposal* internal_default_instance() {
    return reinterpret_cast<const Proposal*>(
               &_Proposal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(Proposal& a, Proposal& b) {
    a.Swap(&b);
  }
  inline void Swap(Proposal* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Proposal* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Proposal* New() const final {
    return CreateMaybeMessage<Proposal>(nullptr);
  }

  Proposal* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Proposal>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Proposal& from);
  void MergeFrom(const Proposal& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Proposal* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vega.Proposal";
  }
  protected:
  explicit Proposal(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_governance_2eproto);
    return ::descriptor_table_governance_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Proposal_State State;
  static constexpr State STATE_UNSPECIFIED =
    Proposal_State_STATE_UNSPECIFIED;
  static constexpr State STATE_FAILED =
    Proposal_State_STATE_FAILED;
  static constexpr State STATE_OPEN =
    Proposal_State_STATE_OPEN;
  static constexpr State STATE_PASSED =
    Proposal_State_STATE_PASSED;
  static constexpr State STATE_REJECTED =
    Proposal_State_STATE_REJECTED;
  static constexpr State STATE_DECLINED =
    Proposal_State_STATE_DECLINED;
  static constexpr State STATE_ENACTED =
    Proposal_State_STATE_ENACTED;
  static constexpr State STATE_WAITING_FOR_NODE_VOTE =
    Proposal_State_STATE_WAITING_FOR_NODE_VOTE;
  static inline bool State_IsValid(int value) {
    return Proposal_State_IsValid(value);
  }
  static constexpr State State_MIN =
    Proposal_State_State_MIN;
  static constexpr State State_MAX =
    Proposal_State_State_MAX;
  static constexpr int State_ARRAYSIZE =
    Proposal_State_State_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  State_descriptor() {
    return Proposal_State_descriptor();
  }
  template<typename T>
  static inline const std::string& State_Name(T enum_t_value) {
    static_assert(::std::is_same<T, State>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function State_Name.");
    return Proposal_State_Name(enum_t_value);
  }
  static inline bool State_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      State* value) {
    return Proposal_State_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kIDFieldNumber = 1,
    kReferenceFieldNumber = 2,
    kPartyIDFieldNumber = 3,
    kTermsFieldNumber = 6,
    kTimestampFieldNumber = 5,
    kStateFieldNumber = 4,
    kReasonFieldNumber = 7,
  };
  // string ID = 1 [json_name = "ID"];
  void clear_id();
  const std::string& id() const;
  void set_id(const std::string& value);
  void set_id(std::string&& value);
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  std::string* mutable_id();
  std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string reference = 2 [json_name = "reference"];
  void clear_reference();
  const std::string& reference() const;
  void set_reference(const std::string& value);
  void set_reference(std::string&& value);
  void set_reference(const char* value);
  void set_reference(const char* value, size_t size);
  std::string* mutable_reference();
  std::string* release_reference();
  void set_allocated_reference(std::string* reference);
  private:
  const std::string& _internal_reference() const;
  void _internal_set_reference(const std::string& value);
  std::string* _internal_mutable_reference();
  public:

  // string partyID = 3 [json_name = "partyID", (.validator.field) = {
  void clear_partyid();
  const std::string& partyid() const;
  void set_partyid(const std::string& value);
  void set_partyid(std::string&& value);
  void set_partyid(const char* value);
  void set_partyid(const char* value, size_t size);
  std::string* mutable_partyid();
  std::string* release_partyid();
  void set_allocated_partyid(std::string* partyid);
  private:
  const std::string& _internal_partyid() const;
  void _internal_set_partyid(const std::string& value);
  std::string* _internal_mutable_partyid();
  public:

  // .vega.ProposalTerms terms = 6 [json_name = "terms", (.validator.field) = {
  bool has_terms() const;
  private:
  bool _internal_has_terms() const;
  public:
  void clear_terms();
  const ::vega::ProposalTerms& terms() const;
  ::vega::ProposalTerms* release_terms();
  ::vega::ProposalTerms* mutable_terms();
  void set_allocated_terms(::vega::ProposalTerms* terms);
  private:
  const ::vega::ProposalTerms& _internal_terms() const;
  ::vega::ProposalTerms* _internal_mutable_terms();
  public:
  void unsafe_arena_set_allocated_terms(
      ::vega::ProposalTerms* terms);
  ::vega::ProposalTerms* unsafe_arena_release_terms();

  // int64 timestamp = 5 [json_name = "timestamp"];
  void clear_timestamp();
  ::PROTOBUF_NAMESPACE_ID::int64 timestamp() const;
  void set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_timestamp() const;
  void _internal_set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // .vega.Proposal.State state = 4 [json_name = "state", (.validator.field) = {
  void clear_state();
  ::vega::Proposal_State state() const;
  void set_state(::vega::Proposal_State value);
  private:
  ::vega::Proposal_State _internal_state() const;
  void _internal_set_state(::vega::Proposal_State value);
  public:

  // .vega.ProposalError reason = 7 [json_name = "reason"];
  void clear_reason();
  ::vega::ProposalError reason() const;
  void set_reason(::vega::ProposalError value);
  private:
  ::vega::ProposalError _internal_reason() const;
  void _internal_set_reason(::vega::ProposalError value);
  public:

  // @@protoc_insertion_point(class_scope:vega.Proposal)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reference_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr partyid_;
  ::vega::ProposalTerms* terms_;
  ::PROTOBUF_NAMESPACE_ID::int64 timestamp_;
  int state_;
  int reason_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_governance_2eproto;
};
// -------------------------------------------------------------------

class Vote PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vega.Vote) */ {
 public:
  inline Vote() : Vote(nullptr) {}
  virtual ~Vote();

  Vote(const Vote& from);
  Vote(Vote&& from) noexcept
    : Vote() {
    *this = ::std::move(from);
  }

  inline Vote& operator=(const Vote& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vote& operator=(Vote&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Vote& default_instance();

  static inline const Vote* internal_default_instance() {
    return reinterpret_cast<const Vote*>(
               &_Vote_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(Vote& a, Vote& b) {
    a.Swap(&b);
  }
  inline void Swap(Vote* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Vote* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Vote* New() const final {
    return CreateMaybeMessage<Vote>(nullptr);
  }

  Vote* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Vote>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Vote& from);
  void MergeFrom(const Vote& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vote* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vega.Vote";
  }
  protected:
  explicit Vote(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_governance_2eproto);
    return ::descriptor_table_governance_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Vote_Value Value;
  static constexpr Value VALUE_UNSPECIFIED =
    Vote_Value_VALUE_UNSPECIFIED;
  static constexpr Value VALUE_NO =
    Vote_Value_VALUE_NO;
  static constexpr Value VALUE_YES =
    Vote_Value_VALUE_YES;
  static inline bool Value_IsValid(int value) {
    return Vote_Value_IsValid(value);
  }
  static constexpr Value Value_MIN =
    Vote_Value_Value_MIN;
  static constexpr Value Value_MAX =
    Vote_Value_Value_MAX;
  static constexpr int Value_ARRAYSIZE =
    Vote_Value_Value_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Value_descriptor() {
    return Vote_Value_descriptor();
  }
  template<typename T>
  static inline const std::string& Value_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Value>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Value_Name.");
    return Vote_Value_Name(enum_t_value);
  }
  static inline bool Value_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Value* value) {
    return Vote_Value_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kPartyIDFieldNumber = 1,
    kProposalIDFieldNumber = 3,
    kTimestampFieldNumber = 4,
    kValueFieldNumber = 2,
  };
  // string partyID = 1 [json_name = "partyID", (.validator.field) = {
  void clear_partyid();
  const std::string& partyid() const;
  void set_partyid(const std::string& value);
  void set_partyid(std::string&& value);
  void set_partyid(const char* value);
  void set_partyid(const char* value, size_t size);
  std::string* mutable_partyid();
  std::string* release_partyid();
  void set_allocated_partyid(std::string* partyid);
  private:
  const std::string& _internal_partyid() const;
  void _internal_set_partyid(const std::string& value);
  std::string* _internal_mutable_partyid();
  public:

  // string proposalID = 3 [json_name = "proposalID", (.validator.field) = {
  void clear_proposalid();
  const std::string& proposalid() const;
  void set_proposalid(const std::string& value);
  void set_proposalid(std::string&& value);
  void set_proposalid(const char* value);
  void set_proposalid(const char* value, size_t size);
  std::string* mutable_proposalid();
  std::string* release_proposalid();
  void set_allocated_proposalid(std::string* proposalid);
  private:
  const std::string& _internal_proposalid() const;
  void _internal_set_proposalid(const std::string& value);
  std::string* _internal_mutable_proposalid();
  public:

  // int64 timestamp = 4 [json_name = "timestamp"];
  void clear_timestamp();
  ::PROTOBUF_NAMESPACE_ID::int64 timestamp() const;
  void set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_timestamp() const;
  void _internal_set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // .vega.Vote.Value value = 2 [json_name = "value", (.validator.field) = {
  void clear_value();
  ::vega::Vote_Value value() const;
  void set_value(::vega::Vote_Value value);
  private:
  ::vega::Vote_Value _internal_value() const;
  void _internal_set_value(::vega::Vote_Value value);
  public:

  // @@protoc_insertion_point(class_scope:vega.Vote)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr partyid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr proposalid_;
  ::PROTOBUF_NAMESPACE_ID::int64 timestamp_;
  int value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_governance_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// FutureProduct

// string maturity = 1 [json_name = "maturity", (.validator.field) = {
inline void FutureProduct::clear_maturity() {
  maturity_.ClearToEmpty();
}
inline const std::string& FutureProduct::maturity() const {
  // @@protoc_insertion_point(field_get:vega.FutureProduct.maturity)
  return _internal_maturity();
}
inline void FutureProduct::set_maturity(const std::string& value) {
  _internal_set_maturity(value);
  // @@protoc_insertion_point(field_set:vega.FutureProduct.maturity)
}
inline std::string* FutureProduct::mutable_maturity() {
  // @@protoc_insertion_point(field_mutable:vega.FutureProduct.maturity)
  return _internal_mutable_maturity();
}
inline const std::string& FutureProduct::_internal_maturity() const {
  return maturity_.Get();
}
inline void FutureProduct::_internal_set_maturity(const std::string& value) {

  maturity_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void FutureProduct::set_maturity(std::string&& value) {

  maturity_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vega.FutureProduct.maturity)
}
inline void FutureProduct::set_maturity(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  maturity_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:vega.FutureProduct.maturity)
}
inline void FutureProduct::set_maturity(const char* value,
    size_t size) {

  maturity_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vega.FutureProduct.maturity)
}
inline std::string* FutureProduct::_internal_mutable_maturity() {

  return maturity_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* FutureProduct::release_maturity() {
  // @@protoc_insertion_point(field_release:vega.FutureProduct.maturity)
  return maturity_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void FutureProduct::set_allocated_maturity(std::string* maturity) {
  if (maturity != nullptr) {

  } else {

  }
  maturity_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), maturity,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vega.FutureProduct.maturity)
}

// string settlementAsset = 2 [json_name = "settlementAsset", (.validator.field) = {
inline void FutureProduct::clear_settlementasset() {
  settlementasset_.ClearToEmpty();
}
inline const std::string& FutureProduct::settlementasset() const {
  // @@protoc_insertion_point(field_get:vega.FutureProduct.settlementAsset)
  return _internal_settlementasset();
}
inline void FutureProduct::set_settlementasset(const std::string& value) {
  _internal_set_settlementasset(value);
  // @@protoc_insertion_point(field_set:vega.FutureProduct.settlementAsset)
}
inline std::string* FutureProduct::mutable_settlementasset() {
  // @@protoc_insertion_point(field_mutable:vega.FutureProduct.settlementAsset)
  return _internal_mutable_settlementasset();
}
inline const std::string& FutureProduct::_internal_settlementasset() const {
  return settlementasset_.Get();
}
inline void FutureProduct::_internal_set_settlementasset(const std::string& value) {

  settlementasset_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void FutureProduct::set_settlementasset(std::string&& value) {

  settlementasset_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vega.FutureProduct.settlementAsset)
}
inline void FutureProduct::set_settlementasset(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  settlementasset_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:vega.FutureProduct.settlementAsset)
}
inline void FutureProduct::set_settlementasset(const char* value,
    size_t size) {

  settlementasset_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vega.FutureProduct.settlementAsset)
}
inline std::string* FutureProduct::_internal_mutable_settlementasset() {

  return settlementasset_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* FutureProduct::release_settlementasset() {
  // @@protoc_insertion_point(field_release:vega.FutureProduct.settlementAsset)
  return settlementasset_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void FutureProduct::set_allocated_settlementasset(std::string* settlementasset) {
  if (settlementasset != nullptr) {

  } else {

  }
  settlementasset_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), settlementasset,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vega.FutureProduct.settlementAsset)
}

// string quoteName = 3 [json_name = "quoteName", (.validator.field) = {
inline void FutureProduct::clear_quotename() {
  quotename_.ClearToEmpty();
}
inline const std::string& FutureProduct::quotename() const {
  // @@protoc_insertion_point(field_get:vega.FutureProduct.quoteName)
  return _internal_quotename();
}
inline void FutureProduct::set_quotename(const std::string& value) {
  _internal_set_quotename(value);
  // @@protoc_insertion_point(field_set:vega.FutureProduct.quoteName)
}
inline std::string* FutureProduct::mutable_quotename() {
  // @@protoc_insertion_point(field_mutable:vega.FutureProduct.quoteName)
  return _internal_mutable_quotename();
}
inline const std::string& FutureProduct::_internal_quotename() const {
  return quotename_.Get();
}
inline void FutureProduct::_internal_set_quotename(const std::string& value) {

  quotename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void FutureProduct::set_quotename(std::string&& value) {

  quotename_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vega.FutureProduct.quoteName)
}
inline void FutureProduct::set_quotename(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  quotename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:vega.FutureProduct.quoteName)
}
inline void FutureProduct::set_quotename(const char* value,
    size_t size) {

  quotename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vega.FutureProduct.quoteName)
}
inline std::string* FutureProduct::_internal_mutable_quotename() {

  return quotename_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* FutureProduct::release_quotename() {
  // @@protoc_insertion_point(field_release:vega.FutureProduct.quoteName)
  return quotename_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void FutureProduct::set_allocated_quotename(std::string* quotename) {
  if (quotename != nullptr) {

  } else {

  }
  quotename_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), quotename,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vega.FutureProduct.quoteName)
}

// -------------------------------------------------------------------

// InstrumentConfiguration

// string name = 1 [json_name = "name", (.validator.field) = {
inline void InstrumentConfiguration::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& InstrumentConfiguration::name() const {
  // @@protoc_insertion_point(field_get:vega.InstrumentConfiguration.name)
  return _internal_name();
}
inline void InstrumentConfiguration::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:vega.InstrumentConfiguration.name)
}
inline std::string* InstrumentConfiguration::mutable_name() {
  // @@protoc_insertion_point(field_mutable:vega.InstrumentConfiguration.name)
  return _internal_mutable_name();
}
inline const std::string& InstrumentConfiguration::_internal_name() const {
  return name_.Get();
}
inline void InstrumentConfiguration::_internal_set_name(const std::string& value) {

  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void InstrumentConfiguration::set_name(std::string&& value) {

  name_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vega.InstrumentConfiguration.name)
}
inline void InstrumentConfiguration::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:vega.InstrumentConfiguration.name)
}
inline void InstrumentConfiguration::set_name(const char* value,
    size_t size) {

  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vega.InstrumentConfiguration.name)
}
inline std::string* InstrumentConfiguration::_internal_mutable_name() {

  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* InstrumentConfiguration::release_name() {
  // @@protoc_insertion_point(field_release:vega.InstrumentConfiguration.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void InstrumentConfiguration::set_allocated_name(std::string* name) {
  if (name != nullptr) {

  } else {

  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vega.InstrumentConfiguration.name)
}

// string code = 2 [json_name = "code", (.validator.field) = {
inline void InstrumentConfiguration::clear_code() {
  code_.ClearToEmpty();
}
inline const std::string& InstrumentConfiguration::code() const {
  // @@protoc_insertion_point(field_get:vega.InstrumentConfiguration.code)
  return _internal_code();
}
inline void InstrumentConfiguration::set_code(const std::string& value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:vega.InstrumentConfiguration.code)
}
inline std::string* InstrumentConfiguration::mutable_code() {
  // @@protoc_insertion_point(field_mutable:vega.InstrumentConfiguration.code)
  return _internal_mutable_code();
}
inline const std::string& InstrumentConfiguration::_internal_code() const {
  return code_.Get();
}
inline void InstrumentConfiguration::_internal_set_code(const std::string& value) {

  code_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void InstrumentConfiguration::set_code(std::string&& value) {

  code_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vega.InstrumentConfiguration.code)
}
inline void InstrumentConfiguration::set_code(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  code_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:vega.InstrumentConfiguration.code)
}
inline void InstrumentConfiguration::set_code(const char* value,
    size_t size) {

  code_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vega.InstrumentConfiguration.code)
}
inline std::string* InstrumentConfiguration::_internal_mutable_code() {

  return code_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* InstrumentConfiguration::release_code() {
  // @@protoc_insertion_point(field_release:vega.InstrumentConfiguration.code)
  return code_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void InstrumentConfiguration::set_allocated_code(std::string* code) {
  if (code != nullptr) {

  } else {

  }
  code_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), code,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vega.InstrumentConfiguration.code)
}

// .vega.FutureProduct future = 100 [json_name = "future"];
inline bool InstrumentConfiguration::_internal_has_future() const {
  return product_case() == kFuture;
}
inline bool InstrumentConfiguration::has_future() const {
  return _internal_has_future();
}
inline void InstrumentConfiguration::set_has_future() {
  _oneof_case_[0] = kFuture;
}
inline void InstrumentConfiguration::clear_future() {
  if (_internal_has_future()) {
    if (GetArena() == nullptr) {
      delete product_.future_;
    }
    clear_has_product();
  }
}
inline ::vega::FutureProduct* InstrumentConfiguration::release_future() {
  // @@protoc_insertion_point(field_release:vega.InstrumentConfiguration.future)
  if (_internal_has_future()) {
    clear_has_product();
      ::vega::FutureProduct* temp = product_.future_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    product_.future_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vega::FutureProduct& InstrumentConfiguration::_internal_future() const {
  return _internal_has_future()
      ? *product_.future_
      : reinterpret_cast< ::vega::FutureProduct&>(::vega::_FutureProduct_default_instance_);
}
inline const ::vega::FutureProduct& InstrumentConfiguration::future() const {
  // @@protoc_insertion_point(field_get:vega.InstrumentConfiguration.future)
  return _internal_future();
}
inline ::vega::FutureProduct* InstrumentConfiguration::unsafe_arena_release_future() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vega.InstrumentConfiguration.future)
  if (_internal_has_future()) {
    clear_has_product();
    ::vega::FutureProduct* temp = product_.future_;
    product_.future_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void InstrumentConfiguration::unsafe_arena_set_allocated_future(::vega::FutureProduct* future) {
  clear_product();
  if (future) {
    set_has_future();
    product_.future_ = future;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vega.InstrumentConfiguration.future)
}
inline ::vega::FutureProduct* InstrumentConfiguration::_internal_mutable_future() {
  if (!_internal_has_future()) {
    clear_product();
    set_has_future();
    product_.future_ = CreateMaybeMessage< ::vega::FutureProduct >(GetArena());
  }
  return product_.future_;
}
inline ::vega::FutureProduct* InstrumentConfiguration::mutable_future() {
  // @@protoc_insertion_point(field_mutable:vega.InstrumentConfiguration.future)
  return _internal_mutable_future();
}

inline bool InstrumentConfiguration::has_product() const {
  return product_case() != PRODUCT_NOT_SET;
}
inline void InstrumentConfiguration::clear_has_product() {
  _oneof_case_[0] = PRODUCT_NOT_SET;
}
inline InstrumentConfiguration::ProductCase InstrumentConfiguration::product_case() const {
  return InstrumentConfiguration::ProductCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// NewMarketConfiguration

// .vega.InstrumentConfiguration instrument = 1 [json_name = "instrument", (.validator.field) = {
inline bool NewMarketConfiguration::_internal_has_instrument() const {
  return this != internal_default_instance() && instrument_ != nullptr;
}
inline bool NewMarketConfiguration::has_instrument() const {
  return _internal_has_instrument();
}
inline void NewMarketConfiguration::clear_instrument() {
  if (GetArena() == nullptr && instrument_ != nullptr) {
    delete instrument_;
  }
  instrument_ = nullptr;
}
inline const ::vega::InstrumentConfiguration& NewMarketConfiguration::_internal_instrument() const {
  const ::vega::InstrumentConfiguration* p = instrument_;
  return p != nullptr ? *p : reinterpret_cast<const ::vega::InstrumentConfiguration&>(
      ::vega::_InstrumentConfiguration_default_instance_);
}
inline const ::vega::InstrumentConfiguration& NewMarketConfiguration::instrument() const {
  // @@protoc_insertion_point(field_get:vega.NewMarketConfiguration.instrument)
  return _internal_instrument();
}
inline void NewMarketConfiguration::unsafe_arena_set_allocated_instrument(
    ::vega::InstrumentConfiguration* instrument) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(instrument_);
  }
  instrument_ = instrument;
  if (instrument) {

  } else {

  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vega.NewMarketConfiguration.instrument)
}
inline ::vega::InstrumentConfiguration* NewMarketConfiguration::release_instrument() {

  ::vega::InstrumentConfiguration* temp = instrument_;
  instrument_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::vega::InstrumentConfiguration* NewMarketConfiguration::unsafe_arena_release_instrument() {
  // @@protoc_insertion_point(field_release:vega.NewMarketConfiguration.instrument)

  ::vega::InstrumentConfiguration* temp = instrument_;
  instrument_ = nullptr;
  return temp;
}
inline ::vega::InstrumentConfiguration* NewMarketConfiguration::_internal_mutable_instrument() {

  if (instrument_ == nullptr) {
    auto* p = CreateMaybeMessage<::vega::InstrumentConfiguration>(GetArena());
    instrument_ = p;
  }
  return instrument_;
}
inline ::vega::InstrumentConfiguration* NewMarketConfiguration::mutable_instrument() {
  // @@protoc_insertion_point(field_mutable:vega.NewMarketConfiguration.instrument)
  return _internal_mutable_instrument();
}
inline void NewMarketConfiguration::set_allocated_instrument(::vega::InstrumentConfiguration* instrument) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete instrument_;
  }
  if (instrument) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(instrument);
    if (message_arena != submessage_arena) {
      instrument = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, instrument, submessage_arena);
    }

  } else {

  }
  instrument_ = instrument;
  // @@protoc_insertion_point(field_set_allocated:vega.NewMarketConfiguration.instrument)
}

// uint64 decimalPlaces = 2 [json_name = "decimalPlaces", (.validator.field) = {
inline void NewMarketConfiguration::clear_decimalplaces() {
  decimalplaces_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 NewMarketConfiguration::_internal_decimalplaces() const {
  return decimalplaces_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 NewMarketConfiguration::decimalplaces() const {
  // @@protoc_insertion_point(field_get:vega.NewMarketConfiguration.decimalPlaces)
  return _internal_decimalplaces();
}
inline void NewMarketConfiguration::_internal_set_decimalplaces(::PROTOBUF_NAMESPACE_ID::uint64 value) {

  decimalplaces_ = value;
}
inline void NewMarketConfiguration::set_decimalplaces(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_decimalplaces(value);
  // @@protoc_insertion_point(field_set:vega.NewMarketConfiguration.decimalPlaces)
}

// repeated string metadata = 3 [json_name = "metadata"];
inline int NewMarketConfiguration::_internal_metadata_size() const {
  return metadata_.size();
}
inline int NewMarketConfiguration::metadata_size() const {
  return _internal_metadata_size();
}
inline void NewMarketConfiguration::clear_metadata() {
  metadata_.Clear();
}
inline std::string* NewMarketConfiguration::add_metadata() {
  // @@protoc_insertion_point(field_add_mutable:vega.NewMarketConfiguration.metadata)
  return _internal_add_metadata();
}
inline const std::string& NewMarketConfiguration::_internal_metadata(int index) const {
  return metadata_.Get(index);
}
inline const std::string& NewMarketConfiguration::metadata(int index) const {
  // @@protoc_insertion_point(field_get:vega.NewMarketConfiguration.metadata)
  return _internal_metadata(index);
}
inline std::string* NewMarketConfiguration::mutable_metadata(int index) {
  // @@protoc_insertion_point(field_mutable:vega.NewMarketConfiguration.metadata)
  return metadata_.Mutable(index);
}
inline void NewMarketConfiguration::set_metadata(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:vega.NewMarketConfiguration.metadata)
  metadata_.Mutable(index)->assign(value);
}
inline void NewMarketConfiguration::set_metadata(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:vega.NewMarketConfiguration.metadata)
  metadata_.Mutable(index)->assign(std::move(value));
}
inline void NewMarketConfiguration::set_metadata(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  metadata_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:vega.NewMarketConfiguration.metadata)
}
inline void NewMarketConfiguration::set_metadata(int index, const char* value, size_t size) {
  metadata_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:vega.NewMarketConfiguration.metadata)
}
inline std::string* NewMarketConfiguration::_internal_add_metadata() {
  return metadata_.Add();
}
inline void NewMarketConfiguration::add_metadata(const std::string& value) {
  metadata_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:vega.NewMarketConfiguration.metadata)
}
inline void NewMarketConfiguration::add_metadata(std::string&& value) {
  metadata_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:vega.NewMarketConfiguration.metadata)
}
inline void NewMarketConfiguration::add_metadata(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  metadata_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:vega.NewMarketConfiguration.metadata)
}
inline void NewMarketConfiguration::add_metadata(const char* value, size_t size) {
  metadata_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:vega.NewMarketConfiguration.metadata)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
NewMarketConfiguration::metadata() const {
  // @@protoc_insertion_point(field_list:vega.NewMarketConfiguration.metadata)
  return metadata_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
NewMarketConfiguration::mutable_metadata() {
  // @@protoc_insertion_point(field_mutable_list:vega.NewMarketConfiguration.metadata)
  return &metadata_;
}

// .vega.PriceMonitoringParameters priceMonitoringParameters = 4 [json_name = "priceMonitoringParameters"];
inline bool NewMarketConfiguration::_internal_has_pricemonitoringparameters() const {
  return this != internal_default_instance() && pricemonitoringparameters_ != nullptr;
}
inline bool NewMarketConfiguration::has_pricemonitoringparameters() const {
  return _internal_has_pricemonitoringparameters();
}
inline const ::vega::PriceMonitoringParameters& NewMarketConfiguration::_internal_pricemonitoringparameters() const {
  const ::vega::PriceMonitoringParameters* p = pricemonitoringparameters_;
  return p != nullptr ? *p : reinterpret_cast<const ::vega::PriceMonitoringParameters&>(
      ::vega::_PriceMonitoringParameters_default_instance_);
}
inline const ::vega::PriceMonitoringParameters& NewMarketConfiguration::pricemonitoringparameters() const {
  // @@protoc_insertion_point(field_get:vega.NewMarketConfiguration.priceMonitoringParameters)
  return _internal_pricemonitoringparameters();
}
inline void NewMarketConfiguration::unsafe_arena_set_allocated_pricemonitoringparameters(
    ::vega::PriceMonitoringParameters* pricemonitoringparameters) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pricemonitoringparameters_);
  }
  pricemonitoringparameters_ = pricemonitoringparameters;
  if (pricemonitoringparameters) {

  } else {

  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vega.NewMarketConfiguration.priceMonitoringParameters)
}
inline ::vega::PriceMonitoringParameters* NewMarketConfiguration::release_pricemonitoringparameters() {

  ::vega::PriceMonitoringParameters* temp = pricemonitoringparameters_;
  pricemonitoringparameters_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::vega::PriceMonitoringParameters* NewMarketConfiguration::unsafe_arena_release_pricemonitoringparameters() {
  // @@protoc_insertion_point(field_release:vega.NewMarketConfiguration.priceMonitoringParameters)

  ::vega::PriceMonitoringParameters* temp = pricemonitoringparameters_;
  pricemonitoringparameters_ = nullptr;
  return temp;
}
inline ::vega::PriceMonitoringParameters* NewMarketConfiguration::_internal_mutable_pricemonitoringparameters() {

  if (pricemonitoringparameters_ == nullptr) {
    auto* p = CreateMaybeMessage<::vega::PriceMonitoringParameters>(GetArena());
    pricemonitoringparameters_ = p;
  }
  return pricemonitoringparameters_;
}
inline ::vega::PriceMonitoringParameters* NewMarketConfiguration::mutable_pricemonitoringparameters() {
  // @@protoc_insertion_point(field_mutable:vega.NewMarketConfiguration.priceMonitoringParameters)
  return _internal_mutable_pricemonitoringparameters();
}
inline void NewMarketConfiguration::set_allocated_pricemonitoringparameters(::vega::PriceMonitoringParameters* pricemonitoringparameters) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(pricemonitoringparameters_);
  }
  if (pricemonitoringparameters) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pricemonitoringparameters)->GetArena();
    if (message_arena != submessage_arena) {
      pricemonitoringparameters = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pricemonitoringparameters, submessage_arena);
    }

  } else {

  }
  pricemonitoringparameters_ = pricemonitoringparameters;
  // @@protoc_insertion_point(field_set_allocated:vega.NewMarketConfiguration.priceMonitoringParameters)
}

// .vega.SimpleModelParams simple = 100 [json_name = "simple"];
inline bool NewMarketConfiguration::_internal_has_simple() const {
  return riskParameters_case() == kSimple;
}
inline bool NewMarketConfiguration::has_simple() const {
  return _internal_has_simple();
}
inline void NewMarketConfiguration::set_has_simple() {
  _oneof_case_[0] = kSimple;
}
inline ::vega::SimpleModelParams* NewMarketConfiguration::release_simple() {
  // @@protoc_insertion_point(field_release:vega.NewMarketConfiguration.simple)
  if (_internal_has_simple()) {
    clear_has_riskParameters();
      ::vega::SimpleModelParams* temp = riskParameters_.simple_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    riskParameters_.simple_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vega::SimpleModelParams& NewMarketConfiguration::_internal_simple() const {
  return _internal_has_simple()
      ? *riskParameters_.simple_
      : reinterpret_cast< ::vega::SimpleModelParams&>(::vega::_SimpleModelParams_default_instance_);
}
inline const ::vega::SimpleModelParams& NewMarketConfiguration::simple() const {
  // @@protoc_insertion_point(field_get:vega.NewMarketConfiguration.simple)
  return _internal_simple();
}
inline ::vega::SimpleModelParams* NewMarketConfiguration::unsafe_arena_release_simple() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vega.NewMarketConfiguration.simple)
  if (_internal_has_simple()) {
    clear_has_riskParameters();
    ::vega::SimpleModelParams* temp = riskParameters_.simple_;
    riskParameters_.simple_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void NewMarketConfiguration::unsafe_arena_set_allocated_simple(::vega::SimpleModelParams* simple) {
  clear_riskParameters();
  if (simple) {
    set_has_simple();
    riskParameters_.simple_ = simple;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vega.NewMarketConfiguration.simple)
}
inline ::vega::SimpleModelParams* NewMarketConfiguration::_internal_mutable_simple() {
  if (!_internal_has_simple()) {
    clear_riskParameters();
    set_has_simple();
    riskParameters_.simple_ = CreateMaybeMessage< ::vega::SimpleModelParams >(GetArena());
  }
  return riskParameters_.simple_;
}
inline ::vega::SimpleModelParams* NewMarketConfiguration::mutable_simple() {
  // @@protoc_insertion_point(field_mutable:vega.NewMarketConfiguration.simple)
  return _internal_mutable_simple();
}

// .vega.LogNormalRiskModel logNormal = 101 [json_name = "logNormal"];
inline bool NewMarketConfiguration::_internal_has_lognormal() const {
  return riskParameters_case() == kLogNormal;
}
inline bool NewMarketConfiguration::has_lognormal() const {
  return _internal_has_lognormal();
}
inline void NewMarketConfiguration::set_has_lognormal() {
  _oneof_case_[0] = kLogNormal;
}
inline ::vega::LogNormalRiskModel* NewMarketConfiguration::release_lognormal() {
  // @@protoc_insertion_point(field_release:vega.NewMarketConfiguration.logNormal)
  if (_internal_has_lognormal()) {
    clear_has_riskParameters();
      ::vega::LogNormalRiskModel* temp = riskParameters_.lognormal_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    riskParameters_.lognormal_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vega::LogNormalRiskModel& NewMarketConfiguration::_internal_lognormal() const {
  return _internal_has_lognormal()
      ? *riskParameters_.lognormal_
      : reinterpret_cast< ::vega::LogNormalRiskModel&>(::vega::_LogNormalRiskModel_default_instance_);
}
inline const ::vega::LogNormalRiskModel& NewMarketConfiguration::lognormal() const {
  // @@protoc_insertion_point(field_get:vega.NewMarketConfiguration.logNormal)
  return _internal_lognormal();
}
inline ::vega::LogNormalRiskModel* NewMarketConfiguration::unsafe_arena_release_lognormal() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vega.NewMarketConfiguration.logNormal)
  if (_internal_has_lognormal()) {
    clear_has_riskParameters();
    ::vega::LogNormalRiskModel* temp = riskParameters_.lognormal_;
    riskParameters_.lognormal_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void NewMarketConfiguration::unsafe_arena_set_allocated_lognormal(::vega::LogNormalRiskModel* lognormal) {
  clear_riskParameters();
  if (lognormal) {
    set_has_lognormal();
    riskParameters_.lognormal_ = lognormal;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vega.NewMarketConfiguration.logNormal)
}
inline ::vega::LogNormalRiskModel* NewMarketConfiguration::_internal_mutable_lognormal() {
  if (!_internal_has_lognormal()) {
    clear_riskParameters();
    set_has_lognormal();
    riskParameters_.lognormal_ = CreateMaybeMessage< ::vega::LogNormalRiskModel >(GetArena());
  }
  return riskParameters_.lognormal_;
}
inline ::vega::LogNormalRiskModel* NewMarketConfiguration::mutable_lognormal() {
  // @@protoc_insertion_point(field_mutable:vega.NewMarketConfiguration.logNormal)
  return _internal_mutable_lognormal();
}

// .vega.ContinuousTrading continuous = 200 [json_name = "continuous"];
inline bool NewMarketConfiguration::_internal_has_continuous() const {
  return tradingMode_case() == kContinuous;
}
inline bool NewMarketConfiguration::has_continuous() const {
  return _internal_has_continuous();
}
inline void NewMarketConfiguration::set_has_continuous() {
  _oneof_case_[1] = kContinuous;
}
inline ::vega::ContinuousTrading* NewMarketConfiguration::release_continuous() {
  // @@protoc_insertion_point(field_release:vega.NewMarketConfiguration.continuous)
  if (_internal_has_continuous()) {
    clear_has_tradingMode();
      ::vega::ContinuousTrading* temp = tradingMode_.continuous_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    tradingMode_.continuous_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vega::ContinuousTrading& NewMarketConfiguration::_internal_continuous() const {
  return _internal_has_continuous()
      ? *tradingMode_.continuous_
      : reinterpret_cast< ::vega::ContinuousTrading&>(::vega::_ContinuousTrading_default_instance_);
}
inline const ::vega::ContinuousTrading& NewMarketConfiguration::continuous() const {
  // @@protoc_insertion_point(field_get:vega.NewMarketConfiguration.continuous)
  return _internal_continuous();
}
inline ::vega::ContinuousTrading* NewMarketConfiguration::unsafe_arena_release_continuous() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vega.NewMarketConfiguration.continuous)
  if (_internal_has_continuous()) {
    clear_has_tradingMode();
    ::vega::ContinuousTrading* temp = tradingMode_.continuous_;
    tradingMode_.continuous_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void NewMarketConfiguration::unsafe_arena_set_allocated_continuous(::vega::ContinuousTrading* continuous) {
  clear_tradingMode();
  if (continuous) {
    set_has_continuous();
    tradingMode_.continuous_ = continuous;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vega.NewMarketConfiguration.continuous)
}
inline ::vega::ContinuousTrading* NewMarketConfiguration::_internal_mutable_continuous() {
  if (!_internal_has_continuous()) {
    clear_tradingMode();
    set_has_continuous();
    tradingMode_.continuous_ = CreateMaybeMessage< ::vega::ContinuousTrading >(GetArena());
  }
  return tradingMode_.continuous_;
}
inline ::vega::ContinuousTrading* NewMarketConfiguration::mutable_continuous() {
  // @@protoc_insertion_point(field_mutable:vega.NewMarketConfiguration.continuous)
  return _internal_mutable_continuous();
}

// .vega.DiscreteTrading discrete = 201 [json_name = "discrete"];
inline bool NewMarketConfiguration::_internal_has_discrete() const {
  return tradingMode_case() == kDiscrete;
}
inline bool NewMarketConfiguration::has_discrete() const {
  return _internal_has_discrete();
}
inline void NewMarketConfiguration::set_has_discrete() {
  _oneof_case_[1] = kDiscrete;
}
inline ::vega::DiscreteTrading* NewMarketConfiguration::release_discrete() {
  // @@protoc_insertion_point(field_release:vega.NewMarketConfiguration.discrete)
  if (_internal_has_discrete()) {
    clear_has_tradingMode();
      ::vega::DiscreteTrading* temp = tradingMode_.discrete_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    tradingMode_.discrete_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vega::DiscreteTrading& NewMarketConfiguration::_internal_discrete() const {
  return _internal_has_discrete()
      ? *tradingMode_.discrete_
      : reinterpret_cast< ::vega::DiscreteTrading&>(::vega::_DiscreteTrading_default_instance_);
}
inline const ::vega::DiscreteTrading& NewMarketConfiguration::discrete() const {
  // @@protoc_insertion_point(field_get:vega.NewMarketConfiguration.discrete)
  return _internal_discrete();
}
inline ::vega::DiscreteTrading* NewMarketConfiguration::unsafe_arena_release_discrete() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vega.NewMarketConfiguration.discrete)
  if (_internal_has_discrete()) {
    clear_has_tradingMode();
    ::vega::DiscreteTrading* temp = tradingMode_.discrete_;
    tradingMode_.discrete_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void NewMarketConfiguration::unsafe_arena_set_allocated_discrete(::vega::DiscreteTrading* discrete) {
  clear_tradingMode();
  if (discrete) {
    set_has_discrete();
    tradingMode_.discrete_ = discrete;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vega.NewMarketConfiguration.discrete)
}
inline ::vega::DiscreteTrading* NewMarketConfiguration::_internal_mutable_discrete() {
  if (!_internal_has_discrete()) {
    clear_tradingMode();
    set_has_discrete();
    tradingMode_.discrete_ = CreateMaybeMessage< ::vega::DiscreteTrading >(GetArena());
  }
  return tradingMode_.discrete_;
}
inline ::vega::DiscreteTrading* NewMarketConfiguration::mutable_discrete() {
  // @@protoc_insertion_point(field_mutable:vega.NewMarketConfiguration.discrete)
  return _internal_mutable_discrete();
}

inline bool NewMarketConfiguration::has_riskParameters() const {
  return riskParameters_case() != RISKPARAMETERS_NOT_SET;
}
inline void NewMarketConfiguration::clear_has_riskParameters() {
  _oneof_case_[0] = RISKPARAMETERS_NOT_SET;
}
inline bool NewMarketConfiguration::has_tradingMode() const {
  return tradingMode_case() != TRADINGMODE_NOT_SET;
}
inline void NewMarketConfiguration::clear_has_tradingMode() {
  _oneof_case_[1] = TRADINGMODE_NOT_SET;
}
inline NewMarketConfiguration::RiskParametersCase NewMarketConfiguration::riskParameters_case() const {
  return NewMarketConfiguration::RiskParametersCase(_oneof_case_[0]);
}
inline NewMarketConfiguration::TradingModeCase NewMarketConfiguration::tradingMode_case() const {
  return NewMarketConfiguration::TradingModeCase(_oneof_case_[1]);
}
// -------------------------------------------------------------------

// NewMarketCommitment

// uint64 commitmentAmount = 1 [json_name = "commitmentAmount"];
inline void NewMarketCommitment::clear_commitmentamount() {
  commitmentamount_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 NewMarketCommitment::_internal_commitmentamount() const {
  return commitmentamount_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 NewMarketCommitment::commitmentamount() const {
  // @@protoc_insertion_point(field_get:vega.NewMarketCommitment.commitmentAmount)
  return _internal_commitmentamount();
}
inline void NewMarketCommitment::_internal_set_commitmentamount(::PROTOBUF_NAMESPACE_ID::uint64 value) {

  commitmentamount_ = value;
}
inline void NewMarketCommitment::set_commitmentamount(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_commitmentamount(value);
  // @@protoc_insertion_point(field_set:vega.NewMarketCommitment.commitmentAmount)
}

// string fee = 2 [json_name = "fee"];
inline void NewMarketCommitment::clear_fee() {
  fee_.ClearToEmpty();
}
inline const std::string& NewMarketCommitment::fee() const {
  // @@protoc_insertion_point(field_get:vega.NewMarketCommitment.fee)
  return _internal_fee();
}
inline void NewMarketCommitment::set_fee(const std::string& value) {
  _internal_set_fee(value);
  // @@protoc_insertion_point(field_set:vega.NewMarketCommitment.fee)
}
inline std::string* NewMarketCommitment::mutable_fee() {
  // @@protoc_insertion_point(field_mutable:vega.NewMarketCommitment.fee)
  return _internal_mutable_fee();
}
inline const std::string& NewMarketCommitment::_internal_fee() const {
  return fee_.Get();
}
inline void NewMarketCommitment::_internal_set_fee(const std::string& value) {

  fee_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void NewMarketCommitment::set_fee(std::string&& value) {

  fee_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vega.NewMarketCommitment.fee)
}
inline void NewMarketCommitment::set_fee(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  fee_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:vega.NewMarketCommitment.fee)
}
inline void NewMarketCommitment::set_fee(const char* value,
    size_t size) {

  fee_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vega.NewMarketCommitment.fee)
}
inline std::string* NewMarketCommitment::_internal_mutable_fee() {

  return fee_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* NewMarketCommitment::release_fee() {
  // @@protoc_insertion_point(field_release:vega.NewMarketCommitment.fee)
  return fee_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void NewMarketCommitment::set_allocated_fee(std::string* fee) {
  if (fee != nullptr) {

  } else {

  }
  fee_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), fee,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vega.NewMarketCommitment.fee)
}

// repeated .vega.LiquidityOrder Sells = 3 [json_name = "Sells"];
inline int NewMarketCommitment::_internal_sells_size() const {
  return sells_.size();
}
inline int NewMarketCommitment::sells_size() const {
  return _internal_sells_size();
}
inline ::vega::LiquidityOrder* NewMarketCommitment::mutable_sells(int index) {
  // @@protoc_insertion_point(field_mutable:vega.NewMarketCommitment.Sells)
  return sells_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vega::LiquidityOrder >*
NewMarketCommitment::mutable_sells() {
  // @@protoc_insertion_point(field_mutable_list:vega.NewMarketCommitment.Sells)
  return &sells_;
}
inline const ::vega::LiquidityOrder& NewMarketCommitment::_internal_sells(int index) const {
  return sells_.Get(index);
}
inline const ::vega::LiquidityOrder& NewMarketCommitment::sells(int index) const {
  // @@protoc_insertion_point(field_get:vega.NewMarketCommitment.Sells)
  return _internal_sells(index);
}
inline ::vega::LiquidityOrder* NewMarketCommitment::_internal_add_sells() {
  return sells_.Add();
}
inline ::vega::LiquidityOrder* NewMarketCommitment::add_sells() {
  // @@protoc_insertion_point(field_add:vega.NewMarketCommitment.Sells)
  return _internal_add_sells();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vega::LiquidityOrder >&
NewMarketCommitment::sells() const {
  // @@protoc_insertion_point(field_list:vega.NewMarketCommitment.Sells)
  return sells_;
}

// repeated .vega.LiquidityOrder Buys = 4 [json_name = "Buys"];
inline int NewMarketCommitment::_internal_buys_size() const {
  return buys_.size();
}
inline int NewMarketCommitment::buys_size() const {
  return _internal_buys_size();
}
inline ::vega::LiquidityOrder* NewMarketCommitment::mutable_buys(int index) {
  // @@protoc_insertion_point(field_mutable:vega.NewMarketCommitment.Buys)
  return buys_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vega::LiquidityOrder >*
NewMarketCommitment::mutable_buys() {
  // @@protoc_insertion_point(field_mutable_list:vega.NewMarketCommitment.Buys)
  return &buys_;
}
inline const ::vega::LiquidityOrder& NewMarketCommitment::_internal_buys(int index) const {
  return buys_.Get(index);
}
inline const ::vega::LiquidityOrder& NewMarketCommitment::buys(int index) const {
  // @@protoc_insertion_point(field_get:vega.NewMarketCommitment.Buys)
  return _internal_buys(index);
}
inline ::vega::LiquidityOrder* NewMarketCommitment::_internal_add_buys() {
  return buys_.Add();
}
inline ::vega::LiquidityOrder* NewMarketCommitment::add_buys() {
  // @@protoc_insertion_point(field_add:vega.NewMarketCommitment.Buys)
  return _internal_add_buys();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vega::LiquidityOrder >&
NewMarketCommitment::buys() const {
  // @@protoc_insertion_point(field_list:vega.NewMarketCommitment.Buys)
  return buys_;
}

// -------------------------------------------------------------------

// NewMarket

// .vega.NewMarketConfiguration changes = 1 [json_name = "changes", (.validator.field) = {
inline bool NewMarket::_internal_has_changes() const {
  return this != internal_default_instance() && changes_ != nullptr;
}
inline bool NewMarket::has_changes() const {
  return _internal_has_changes();
}
inline void NewMarket::clear_changes() {
  if (GetArena() == nullptr && changes_ != nullptr) {
    delete changes_;
  }
  changes_ = nullptr;
}
inline const ::vega::NewMarketConfiguration& NewMarket::_internal_changes() const {
  const ::vega::NewMarketConfiguration* p = changes_;
  return p != nullptr ? *p : reinterpret_cast<const ::vega::NewMarketConfiguration&>(
      ::vega::_NewMarketConfiguration_default_instance_);
}
inline const ::vega::NewMarketConfiguration& NewMarket::changes() const {
  // @@protoc_insertion_point(field_get:vega.NewMarket.changes)
  return _internal_changes();
}
inline void NewMarket::unsafe_arena_set_allocated_changes(
    ::vega::NewMarketConfiguration* changes) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(changes_);
  }
  changes_ = changes;
  if (changes) {

  } else {

  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vega.NewMarket.changes)
}
inline ::vega::NewMarketConfiguration* NewMarket::release_changes() {

  ::vega::NewMarketConfiguration* temp = changes_;
  changes_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::vega::NewMarketConfiguration* NewMarket::unsafe_arena_release_changes() {
  // @@protoc_insertion_point(field_release:vega.NewMarket.changes)

  ::vega::NewMarketConfiguration* temp = changes_;
  changes_ = nullptr;
  return temp;
}
inline ::vega::NewMarketConfiguration* NewMarket::_internal_mutable_changes() {

  if (changes_ == nullptr) {
    auto* p = CreateMaybeMessage<::vega::NewMarketConfiguration>(GetArena());
    changes_ = p;
  }
  return changes_;
}
inline ::vega::NewMarketConfiguration* NewMarket::mutable_changes() {
  // @@protoc_insertion_point(field_mutable:vega.NewMarket.changes)
  return _internal_mutable_changes();
}
inline void NewMarket::set_allocated_changes(::vega::NewMarketConfiguration* changes) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete changes_;
  }
  if (changes) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(changes);
    if (message_arena != submessage_arena) {
      changes = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, changes, submessage_arena);
    }

  } else {

  }
  changes_ = changes;
  // @@protoc_insertion_point(field_set_allocated:vega.NewMarket.changes)
}

// .vega.NewMarketCommitment liquidityCommitment = 2 [json_name = "liquidityCommitment"];
inline bool NewMarket::_internal_has_liquiditycommitment() const {
  return this != internal_default_instance() && liquiditycommitment_ != nullptr;
}
inline bool NewMarket::has_liquiditycommitment() const {
  return _internal_has_liquiditycommitment();
}
inline void NewMarket::clear_liquiditycommitment() {
  if (GetArena() == nullptr && liquiditycommitment_ != nullptr) {
    delete liquiditycommitment_;
  }
  liquiditycommitment_ = nullptr;
}
inline const ::vega::NewMarketCommitment& NewMarket::_internal_liquiditycommitment() const {
  const ::vega::NewMarketCommitment* p = liquiditycommitment_;
  return p != nullptr ? *p : reinterpret_cast<const ::vega::NewMarketCommitment&>(
      ::vega::_NewMarketCommitment_default_instance_);
}
inline const ::vega::NewMarketCommitment& NewMarket::liquiditycommitment() const {
  // @@protoc_insertion_point(field_get:vega.NewMarket.liquidityCommitment)
  return _internal_liquiditycommitment();
}
inline void NewMarket::unsafe_arena_set_allocated_liquiditycommitment(
    ::vega::NewMarketCommitment* liquiditycommitment) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(liquiditycommitment_);
  }
  liquiditycommitment_ = liquiditycommitment;
  if (liquiditycommitment) {

  } else {

  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vega.NewMarket.liquidityCommitment)
}
inline ::vega::NewMarketCommitment* NewMarket::release_liquiditycommitment() {

  ::vega::NewMarketCommitment* temp = liquiditycommitment_;
  liquiditycommitment_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::vega::NewMarketCommitment* NewMarket::unsafe_arena_release_liquiditycommitment() {
  // @@protoc_insertion_point(field_release:vega.NewMarket.liquidityCommitment)

  ::vega::NewMarketCommitment* temp = liquiditycommitment_;
  liquiditycommitment_ = nullptr;
  return temp;
}
inline ::vega::NewMarketCommitment* NewMarket::_internal_mutable_liquiditycommitment() {

  if (liquiditycommitment_ == nullptr) {
    auto* p = CreateMaybeMessage<::vega::NewMarketCommitment>(GetArena());
    liquiditycommitment_ = p;
  }
  return liquiditycommitment_;
}
inline ::vega::NewMarketCommitment* NewMarket::mutable_liquiditycommitment() {
  // @@protoc_insertion_point(field_mutable:vega.NewMarket.liquidityCommitment)
  return _internal_mutable_liquiditycommitment();
}
inline void NewMarket::set_allocated_liquiditycommitment(::vega::NewMarketCommitment* liquiditycommitment) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete liquiditycommitment_;
  }
  if (liquiditycommitment) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(liquiditycommitment);
    if (message_arena != submessage_arena) {
      liquiditycommitment = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, liquiditycommitment, submessage_arena);
    }

  } else {

  }
  liquiditycommitment_ = liquiditycommitment;
  // @@protoc_insertion_point(field_set_allocated:vega.NewMarket.liquidityCommitment)
}

// -------------------------------------------------------------------

// UpdateMarket

// -------------------------------------------------------------------

// UpdateNetworkParameter

// .vega.NetworkParameter changes = 1 [json_name = "changes", (.validator.field) = {
inline bool UpdateNetworkParameter::_internal_has_changes() const {
  return this != internal_default_instance() && changes_ != nullptr;
}
inline bool UpdateNetworkParameter::has_changes() const {
  return _internal_has_changes();
}
inline const ::vega::NetworkParameter& UpdateNetworkParameter::_internal_changes() const {
  const ::vega::NetworkParameter* p = changes_;
  return p != nullptr ? *p : reinterpret_cast<const ::vega::NetworkParameter&>(
      ::vega::_NetworkParameter_default_instance_);
}
inline const ::vega::NetworkParameter& UpdateNetworkParameter::changes() const {
  // @@protoc_insertion_point(field_get:vega.UpdateNetworkParameter.changes)
  return _internal_changes();
}
inline void UpdateNetworkParameter::unsafe_arena_set_allocated_changes(
    ::vega::NetworkParameter* changes) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(changes_);
  }
  changes_ = changes;
  if (changes) {

  } else {

  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vega.UpdateNetworkParameter.changes)
}
inline ::vega::NetworkParameter* UpdateNetworkParameter::release_changes() {

  ::vega::NetworkParameter* temp = changes_;
  changes_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::vega::NetworkParameter* UpdateNetworkParameter::unsafe_arena_release_changes() {
  // @@protoc_insertion_point(field_release:vega.UpdateNetworkParameter.changes)

  ::vega::NetworkParameter* temp = changes_;
  changes_ = nullptr;
  return temp;
}
inline ::vega::NetworkParameter* UpdateNetworkParameter::_internal_mutable_changes() {

  if (changes_ == nullptr) {
    auto* p = CreateMaybeMessage<::vega::NetworkParameter>(GetArena());
    changes_ = p;
  }
  return changes_;
}
inline ::vega::NetworkParameter* UpdateNetworkParameter::mutable_changes() {
  // @@protoc_insertion_point(field_mutable:vega.UpdateNetworkParameter.changes)
  return _internal_mutable_changes();
}
inline void UpdateNetworkParameter::set_allocated_changes(::vega::NetworkParameter* changes) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(changes_);
  }
  if (changes) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(changes)->GetArena();
    if (message_arena != submessage_arena) {
      changes = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, changes, submessage_arena);
    }

  } else {

  }
  changes_ = changes;
  // @@protoc_insertion_point(field_set_allocated:vega.UpdateNetworkParameter.changes)
}

// -------------------------------------------------------------------

// NewAsset

// .vega.AssetSource changes = 1 [json_name = "changes", (.validator.field) = {
inline bool NewAsset::_internal_has_changes() const {
  return this != internal_default_instance() && changes_ != nullptr;
}
inline bool NewAsset::has_changes() const {
  return _internal_has_changes();
}
inline const ::vega::AssetSource& NewAsset::_internal_changes() const {
  const ::vega::AssetSource* p = changes_;
  return p != nullptr ? *p : reinterpret_cast<const ::vega::AssetSource&>(
      ::vega::_AssetSource_default_instance_);
}
inline const ::vega::AssetSource& NewAsset::changes() const {
  // @@protoc_insertion_point(field_get:vega.NewAsset.changes)
  return _internal_changes();
}
inline void NewAsset::unsafe_arena_set_allocated_changes(
    ::vega::AssetSource* changes) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(changes_);
  }
  changes_ = changes;
  if (changes) {

  } else {

  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vega.NewAsset.changes)
}
inline ::vega::AssetSource* NewAsset::release_changes() {

  ::vega::AssetSource* temp = changes_;
  changes_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::vega::AssetSource* NewAsset::unsafe_arena_release_changes() {
  // @@protoc_insertion_point(field_release:vega.NewAsset.changes)

  ::vega::AssetSource* temp = changes_;
  changes_ = nullptr;
  return temp;
}
inline ::vega::AssetSource* NewAsset::_internal_mutable_changes() {

  if (changes_ == nullptr) {
    auto* p = CreateMaybeMessage<::vega::AssetSource>(GetArena());
    changes_ = p;
  }
  return changes_;
}
inline ::vega::AssetSource* NewAsset::mutable_changes() {
  // @@protoc_insertion_point(field_mutable:vega.NewAsset.changes)
  return _internal_mutable_changes();
}
inline void NewAsset::set_allocated_changes(::vega::AssetSource* changes) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(changes_);
  }
  if (changes) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(changes)->GetArena();
    if (message_arena != submessage_arena) {
      changes = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, changes, submessage_arena);
    }

  } else {

  }
  changes_ = changes;
  // @@protoc_insertion_point(field_set_allocated:vega.NewAsset.changes)
}

// -------------------------------------------------------------------

// ProposalTerms

// int64 closingTimestamp = 1 [json_name = "closingTimestamp", (.validator.field) = {
inline void ProposalTerms::clear_closingtimestamp() {
  closingtimestamp_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ProposalTerms::_internal_closingtimestamp() const {
  return closingtimestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ProposalTerms::closingtimestamp() const {
  // @@protoc_insertion_point(field_get:vega.ProposalTerms.closingTimestamp)
  return _internal_closingtimestamp();
}
inline void ProposalTerms::_internal_set_closingtimestamp(::PROTOBUF_NAMESPACE_ID::int64 value) {

  closingtimestamp_ = value;
}
inline void ProposalTerms::set_closingtimestamp(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_closingtimestamp(value);
  // @@protoc_insertion_point(field_set:vega.ProposalTerms.closingTimestamp)
}

// int64 enactmentTimestamp = 2 [json_name = "enactmentTimestamp", (.validator.field) = {
inline void ProposalTerms::clear_enactmenttimestamp() {
  enactmenttimestamp_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ProposalTerms::_internal_enactmenttimestamp() const {
  return enactmenttimestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ProposalTerms::enactmenttimestamp() const {
  // @@protoc_insertion_point(field_get:vega.ProposalTerms.enactmentTimestamp)
  return _internal_enactmenttimestamp();
}
inline void ProposalTerms::_internal_set_enactmenttimestamp(::PROTOBUF_NAMESPACE_ID::int64 value) {

  enactmenttimestamp_ = value;
}
inline void ProposalTerms::set_enactmenttimestamp(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_enactmenttimestamp(value);
  // @@protoc_insertion_point(field_set:vega.ProposalTerms.enactmentTimestamp)
}

// int64 validationTimestamp = 3 [json_name = "validationTimestamp"];
inline void ProposalTerms::clear_validationtimestamp() {
  validationtimestamp_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ProposalTerms::_internal_validationtimestamp() const {
  return validationtimestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ProposalTerms::validationtimestamp() const {
  // @@protoc_insertion_point(field_get:vega.ProposalTerms.validationTimestamp)
  return _internal_validationtimestamp();
}
inline void ProposalTerms::_internal_set_validationtimestamp(::PROTOBUF_NAMESPACE_ID::int64 value) {

  validationtimestamp_ = value;
}
inline void ProposalTerms::set_validationtimestamp(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_validationtimestamp(value);
  // @@protoc_insertion_point(field_set:vega.ProposalTerms.validationTimestamp)
}

// .vega.UpdateMarket updateMarket = 101 [json_name = "updateMarket"];
inline bool ProposalTerms::_internal_has_updatemarket() const {
  return change_case() == kUpdateMarket;
}
inline bool ProposalTerms::has_updatemarket() const {
  return _internal_has_updatemarket();
}
inline void ProposalTerms::set_has_updatemarket() {
  _oneof_case_[0] = kUpdateMarket;
}
inline void ProposalTerms::clear_updatemarket() {
  if (_internal_has_updatemarket()) {
    if (GetArena() == nullptr) {
      delete change_.updatemarket_;
    }
    clear_has_change();
  }
}
inline ::vega::UpdateMarket* ProposalTerms::release_updatemarket() {
  // @@protoc_insertion_point(field_release:vega.ProposalTerms.updateMarket)
  if (_internal_has_updatemarket()) {
    clear_has_change();
      ::vega::UpdateMarket* temp = change_.updatemarket_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    change_.updatemarket_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vega::UpdateMarket& ProposalTerms::_internal_updatemarket() const {
  return _internal_has_updatemarket()
      ? *change_.updatemarket_
      : reinterpret_cast< ::vega::UpdateMarket&>(::vega::_UpdateMarket_default_instance_);
}
inline const ::vega::UpdateMarket& ProposalTerms::updatemarket() const {
  // @@protoc_insertion_point(field_get:vega.ProposalTerms.updateMarket)
  return _internal_updatemarket();
}
inline ::vega::UpdateMarket* ProposalTerms::unsafe_arena_release_updatemarket() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vega.ProposalTerms.updateMarket)
  if (_internal_has_updatemarket()) {
    clear_has_change();
    ::vega::UpdateMarket* temp = change_.updatemarket_;
    change_.updatemarket_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ProposalTerms::unsafe_arena_set_allocated_updatemarket(::vega::UpdateMarket* updatemarket) {
  clear_change();
  if (updatemarket) {
    set_has_updatemarket();
    change_.updatemarket_ = updatemarket;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vega.ProposalTerms.updateMarket)
}
inline ::vega::UpdateMarket* ProposalTerms::_internal_mutable_updatemarket() {
  if (!_internal_has_updatemarket()) {
    clear_change();
    set_has_updatemarket();
    change_.updatemarket_ = CreateMaybeMessage< ::vega::UpdateMarket >(GetArena());
  }
  return change_.updatemarket_;
}
inline ::vega::UpdateMarket* ProposalTerms::mutable_updatemarket() {
  // @@protoc_insertion_point(field_mutable:vega.ProposalTerms.updateMarket)
  return _internal_mutable_updatemarket();
}

// .vega.NewMarket newMarket = 102 [json_name = "newMarket"];
inline bool ProposalTerms::_internal_has_newmarket() const {
  return change_case() == kNewMarket;
}
inline bool ProposalTerms::has_newmarket() const {
  return _internal_has_newmarket();
}
inline void ProposalTerms::set_has_newmarket() {
  _oneof_case_[0] = kNewMarket;
}
inline void ProposalTerms::clear_newmarket() {
  if (_internal_has_newmarket()) {
    if (GetArena() == nullptr) {
      delete change_.newmarket_;
    }
    clear_has_change();
  }
}
inline ::vega::NewMarket* ProposalTerms::release_newmarket() {
  // @@protoc_insertion_point(field_release:vega.ProposalTerms.newMarket)
  if (_internal_has_newmarket()) {
    clear_has_change();
      ::vega::NewMarket* temp = change_.newmarket_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    change_.newmarket_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vega::NewMarket& ProposalTerms::_internal_newmarket() const {
  return _internal_has_newmarket()
      ? *change_.newmarket_
      : reinterpret_cast< ::vega::NewMarket&>(::vega::_NewMarket_default_instance_);
}
inline const ::vega::NewMarket& ProposalTerms::newmarket() const {
  // @@protoc_insertion_point(field_get:vega.ProposalTerms.newMarket)
  return _internal_newmarket();
}
inline ::vega::NewMarket* ProposalTerms::unsafe_arena_release_newmarket() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vega.ProposalTerms.newMarket)
  if (_internal_has_newmarket()) {
    clear_has_change();
    ::vega::NewMarket* temp = change_.newmarket_;
    change_.newmarket_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ProposalTerms::unsafe_arena_set_allocated_newmarket(::vega::NewMarket* newmarket) {
  clear_change();
  if (newmarket) {
    set_has_newmarket();
    change_.newmarket_ = newmarket;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vega.ProposalTerms.newMarket)
}
inline ::vega::NewMarket* ProposalTerms::_internal_mutable_newmarket() {
  if (!_internal_has_newmarket()) {
    clear_change();
    set_has_newmarket();
    change_.newmarket_ = CreateMaybeMessage< ::vega::NewMarket >(GetArena());
  }
  return change_.newmarket_;
}
inline ::vega::NewMarket* ProposalTerms::mutable_newmarket() {
  // @@protoc_insertion_point(field_mutable:vega.ProposalTerms.newMarket)
  return _internal_mutable_newmarket();
}

// .vega.UpdateNetworkParameter updateNetworkParameter = 103 [json_name = "updateNetworkParameter"];
inline bool ProposalTerms::_internal_has_updatenetworkparameter() const {
  return change_case() == kUpdateNetworkParameter;
}
inline bool ProposalTerms::has_updatenetworkparameter() const {
  return _internal_has_updatenetworkparameter();
}
inline void ProposalTerms::set_has_updatenetworkparameter() {
  _oneof_case_[0] = kUpdateNetworkParameter;
}
inline void ProposalTerms::clear_updatenetworkparameter() {
  if (_internal_has_updatenetworkparameter()) {
    if (GetArena() == nullptr) {
      delete change_.updatenetworkparameter_;
    }
    clear_has_change();
  }
}
inline ::vega::UpdateNetworkParameter* ProposalTerms::release_updatenetworkparameter() {
  // @@protoc_insertion_point(field_release:vega.ProposalTerms.updateNetworkParameter)
  if (_internal_has_updatenetworkparameter()) {
    clear_has_change();
      ::vega::UpdateNetworkParameter* temp = change_.updatenetworkparameter_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    change_.updatenetworkparameter_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vega::UpdateNetworkParameter& ProposalTerms::_internal_updatenetworkparameter() const {
  return _internal_has_updatenetworkparameter()
      ? *change_.updatenetworkparameter_
      : reinterpret_cast< ::vega::UpdateNetworkParameter&>(::vega::_UpdateNetworkParameter_default_instance_);
}
inline const ::vega::UpdateNetworkParameter& ProposalTerms::updatenetworkparameter() const {
  // @@protoc_insertion_point(field_get:vega.ProposalTerms.updateNetworkParameter)
  return _internal_updatenetworkparameter();
}
inline ::vega::UpdateNetworkParameter* ProposalTerms::unsafe_arena_release_updatenetworkparameter() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vega.ProposalTerms.updateNetworkParameter)
  if (_internal_has_updatenetworkparameter()) {
    clear_has_change();
    ::vega::UpdateNetworkParameter* temp = change_.updatenetworkparameter_;
    change_.updatenetworkparameter_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ProposalTerms::unsafe_arena_set_allocated_updatenetworkparameter(::vega::UpdateNetworkParameter* updatenetworkparameter) {
  clear_change();
  if (updatenetworkparameter) {
    set_has_updatenetworkparameter();
    change_.updatenetworkparameter_ = updatenetworkparameter;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vega.ProposalTerms.updateNetworkParameter)
}
inline ::vega::UpdateNetworkParameter* ProposalTerms::_internal_mutable_updatenetworkparameter() {
  if (!_internal_has_updatenetworkparameter()) {
    clear_change();
    set_has_updatenetworkparameter();
    change_.updatenetworkparameter_ = CreateMaybeMessage< ::vega::UpdateNetworkParameter >(GetArena());
  }
  return change_.updatenetworkparameter_;
}
inline ::vega::UpdateNetworkParameter* ProposalTerms::mutable_updatenetworkparameter() {
  // @@protoc_insertion_point(field_mutable:vega.ProposalTerms.updateNetworkParameter)
  return _internal_mutable_updatenetworkparameter();
}

// .vega.NewAsset newAsset = 104 [json_name = "newAsset"];
inline bool ProposalTerms::_internal_has_newasset() const {
  return change_case() == kNewAsset;
}
inline bool ProposalTerms::has_newasset() const {
  return _internal_has_newasset();
}
inline void ProposalTerms::set_has_newasset() {
  _oneof_case_[0] = kNewAsset;
}
inline void ProposalTerms::clear_newasset() {
  if (_internal_has_newasset()) {
    if (GetArena() == nullptr) {
      delete change_.newasset_;
    }
    clear_has_change();
  }
}
inline ::vega::NewAsset* ProposalTerms::release_newasset() {
  // @@protoc_insertion_point(field_release:vega.ProposalTerms.newAsset)
  if (_internal_has_newasset()) {
    clear_has_change();
      ::vega::NewAsset* temp = change_.newasset_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    change_.newasset_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vega::NewAsset& ProposalTerms::_internal_newasset() const {
  return _internal_has_newasset()
      ? *change_.newasset_
      : reinterpret_cast< ::vega::NewAsset&>(::vega::_NewAsset_default_instance_);
}
inline const ::vega::NewAsset& ProposalTerms::newasset() const {
  // @@protoc_insertion_point(field_get:vega.ProposalTerms.newAsset)
  return _internal_newasset();
}
inline ::vega::NewAsset* ProposalTerms::unsafe_arena_release_newasset() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vega.ProposalTerms.newAsset)
  if (_internal_has_newasset()) {
    clear_has_change();
    ::vega::NewAsset* temp = change_.newasset_;
    change_.newasset_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ProposalTerms::unsafe_arena_set_allocated_newasset(::vega::NewAsset* newasset) {
  clear_change();
  if (newasset) {
    set_has_newasset();
    change_.newasset_ = newasset;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vega.ProposalTerms.newAsset)
}
inline ::vega::NewAsset* ProposalTerms::_internal_mutable_newasset() {
  if (!_internal_has_newasset()) {
    clear_change();
    set_has_newasset();
    change_.newasset_ = CreateMaybeMessage< ::vega::NewAsset >(GetArena());
  }
  return change_.newasset_;
}
inline ::vega::NewAsset* ProposalTerms::mutable_newasset() {
  // @@protoc_insertion_point(field_mutable:vega.ProposalTerms.newAsset)
  return _internal_mutable_newasset();
}

inline bool ProposalTerms::has_change() const {
  return change_case() != CHANGE_NOT_SET;
}
inline void ProposalTerms::clear_has_change() {
  _oneof_case_[0] = CHANGE_NOT_SET;
}
inline ProposalTerms::ChangeCase ProposalTerms::change_case() const {
  return ProposalTerms::ChangeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// GovernanceData

// .vega.Proposal proposal = 1 [json_name = "proposal"];
inline bool GovernanceData::_internal_has_proposal() const {
  return this != internal_default_instance() && proposal_ != nullptr;
}
inline bool GovernanceData::has_proposal() const {
  return _internal_has_proposal();
}
inline void GovernanceData::clear_proposal() {
  if (GetArena() == nullptr && proposal_ != nullptr) {
    delete proposal_;
  }
  proposal_ = nullptr;
}
inline const ::vega::Proposal& GovernanceData::_internal_proposal() const {
  const ::vega::Proposal* p = proposal_;
  return p != nullptr ? *p : reinterpret_cast<const ::vega::Proposal&>(
      ::vega::_Proposal_default_instance_);
}
inline const ::vega::Proposal& GovernanceData::proposal() const {
  // @@protoc_insertion_point(field_get:vega.GovernanceData.proposal)
  return _internal_proposal();
}
inline void GovernanceData::unsafe_arena_set_allocated_proposal(
    ::vega::Proposal* proposal) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(proposal_);
  }
  proposal_ = proposal;
  if (proposal) {

  } else {

  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vega.GovernanceData.proposal)
}
inline ::vega::Proposal* GovernanceData::release_proposal() {

  ::vega::Proposal* temp = proposal_;
  proposal_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::vega::Proposal* GovernanceData::unsafe_arena_release_proposal() {
  // @@protoc_insertion_point(field_release:vega.GovernanceData.proposal)

  ::vega::Proposal* temp = proposal_;
  proposal_ = nullptr;
  return temp;
}
inline ::vega::Proposal* GovernanceData::_internal_mutable_proposal() {

  if (proposal_ == nullptr) {
    auto* p = CreateMaybeMessage<::vega::Proposal>(GetArena());
    proposal_ = p;
  }
  return proposal_;
}
inline ::vega::Proposal* GovernanceData::mutable_proposal() {
  // @@protoc_insertion_point(field_mutable:vega.GovernanceData.proposal)
  return _internal_mutable_proposal();
}
inline void GovernanceData::set_allocated_proposal(::vega::Proposal* proposal) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete proposal_;
  }
  if (proposal) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(proposal);
    if (message_arena != submessage_arena) {
      proposal = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, proposal, submessage_arena);
    }

  } else {

  }
  proposal_ = proposal;
  // @@protoc_insertion_point(field_set_allocated:vega.GovernanceData.proposal)
}

// repeated .vega.Vote yes = 2 [json_name = "yes"];
inline int GovernanceData::_internal_yes_size() const {
  return yes_.size();
}
inline int GovernanceData::yes_size() const {
  return _internal_yes_size();
}
inline void GovernanceData::clear_yes() {
  yes_.Clear();
}
inline ::vega::Vote* GovernanceData::mutable_yes(int index) {
  // @@protoc_insertion_point(field_mutable:vega.GovernanceData.yes)
  return yes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vega::Vote >*
GovernanceData::mutable_yes() {
  // @@protoc_insertion_point(field_mutable_list:vega.GovernanceData.yes)
  return &yes_;
}
inline const ::vega::Vote& GovernanceData::_internal_yes(int index) const {
  return yes_.Get(index);
}
inline const ::vega::Vote& GovernanceData::yes(int index) const {
  // @@protoc_insertion_point(field_get:vega.GovernanceData.yes)
  return _internal_yes(index);
}
inline ::vega::Vote* GovernanceData::_internal_add_yes() {
  return yes_.Add();
}
inline ::vega::Vote* GovernanceData::add_yes() {
  // @@protoc_insertion_point(field_add:vega.GovernanceData.yes)
  return _internal_add_yes();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vega::Vote >&
GovernanceData::yes() const {
  // @@protoc_insertion_point(field_list:vega.GovernanceData.yes)
  return yes_;
}

// repeated .vega.Vote no = 3 [json_name = "no"];
inline int GovernanceData::_internal_no_size() const {
  return no_.size();
}
inline int GovernanceData::no_size() const {
  return _internal_no_size();
}
inline void GovernanceData::clear_no() {
  no_.Clear();
}
inline ::vega::Vote* GovernanceData::mutable_no(int index) {
  // @@protoc_insertion_point(field_mutable:vega.GovernanceData.no)
  return no_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vega::Vote >*
GovernanceData::mutable_no() {
  // @@protoc_insertion_point(field_mutable_list:vega.GovernanceData.no)
  return &no_;
}
inline const ::vega::Vote& GovernanceData::_internal_no(int index) const {
  return no_.Get(index);
}
inline const ::vega::Vote& GovernanceData::no(int index) const {
  // @@protoc_insertion_point(field_get:vega.GovernanceData.no)
  return _internal_no(index);
}
inline ::vega::Vote* GovernanceData::_internal_add_no() {
  return no_.Add();
}
inline ::vega::Vote* GovernanceData::add_no() {
  // @@protoc_insertion_point(field_add:vega.GovernanceData.no)
  return _internal_add_no();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vega::Vote >&
GovernanceData::no() const {
  // @@protoc_insertion_point(field_list:vega.GovernanceData.no)
  return no_;
}

// map<string, .vega.Vote> yesParty = 4 [json_name = "yesParty"];
inline int GovernanceData::_internal_yesparty_size() const {
  return yesparty_.size();
}
inline int GovernanceData::yesparty_size() const {
  return _internal_yesparty_size();
}
inline void GovernanceData::clear_yesparty() {
  yesparty_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::vega::Vote >&
GovernanceData::_internal_yesparty() const {
  return yesparty_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::vega::Vote >&
GovernanceData::yesparty() const {
  // @@protoc_insertion_point(field_map:vega.GovernanceData.yesParty)
  return _internal_yesparty();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::vega::Vote >*
GovernanceData::_internal_mutable_yesparty() {
  return yesparty_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::vega::Vote >*
GovernanceData::mutable_yesparty() {
  // @@protoc_insertion_point(field_mutable_map:vega.GovernanceData.yesParty)
  return _internal_mutable_yesparty();
}

// map<string, .vega.Vote> noParty = 5 [json_name = "noParty"];
inline int GovernanceData::_internal_noparty_size() const {
  return noparty_.size();
}
inline int GovernanceData::noparty_size() const {
  return _internal_noparty_size();
}
inline void GovernanceData::clear_noparty() {
  noparty_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::vega::Vote >&
GovernanceData::_internal_noparty() const {
  return noparty_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::vega::Vote >&
GovernanceData::noparty() const {
  // @@protoc_insertion_point(field_map:vega.GovernanceData.noParty)
  return _internal_noparty();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::vega::Vote >*
GovernanceData::_internal_mutable_noparty() {
  return noparty_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::vega::Vote >*
GovernanceData::mutable_noparty() {
  // @@protoc_insertion_point(field_mutable_map:vega.GovernanceData.noParty)
  return _internal_mutable_noparty();
}

// -------------------------------------------------------------------

// Proposal

// string ID = 1 [json_name = "ID"];
inline void Proposal::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& Proposal::id() const {
  // @@protoc_insertion_point(field_get:vega.Proposal.ID)
  return _internal_id();
}
inline void Proposal::set_id(const std::string& value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:vega.Proposal.ID)
}
inline std::string* Proposal::mutable_id() {
  // @@protoc_insertion_point(field_mutable:vega.Proposal.ID)
  return _internal_mutable_id();
}
inline const std::string& Proposal::_internal_id() const {
  return id_.Get();
}
inline void Proposal::_internal_set_id(const std::string& value) {

  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Proposal::set_id(std::string&& value) {

  id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vega.Proposal.ID)
}
inline void Proposal::set_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:vega.Proposal.ID)
}
inline void Proposal::set_id(const char* value,
    size_t size) {

  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vega.Proposal.ID)
}
inline std::string* Proposal::_internal_mutable_id() {

  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Proposal::release_id() {
  // @@protoc_insertion_point(field_release:vega.Proposal.ID)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Proposal::set_allocated_id(std::string* id) {
  if (id != nullptr) {

  } else {

  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vega.Proposal.ID)
}

// string reference = 2 [json_name = "reference"];
inline void Proposal::clear_reference() {
  reference_.ClearToEmpty();
}
inline const std::string& Proposal::reference() const {
  // @@protoc_insertion_point(field_get:vega.Proposal.reference)
  return _internal_reference();
}
inline void Proposal::set_reference(const std::string& value) {
  _internal_set_reference(value);
  // @@protoc_insertion_point(field_set:vega.Proposal.reference)
}
inline std::string* Proposal::mutable_reference() {
  // @@protoc_insertion_point(field_mutable:vega.Proposal.reference)
  return _internal_mutable_reference();
}
inline const std::string& Proposal::_internal_reference() const {
  return reference_.Get();
}
inline void Proposal::_internal_set_reference(const std::string& value) {

  reference_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Proposal::set_reference(std::string&& value) {

  reference_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vega.Proposal.reference)
}
inline void Proposal::set_reference(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  reference_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:vega.Proposal.reference)
}
inline void Proposal::set_reference(const char* value,
    size_t size) {

  reference_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vega.Proposal.reference)
}
inline std::string* Proposal::_internal_mutable_reference() {

  return reference_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Proposal::release_reference() {
  // @@protoc_insertion_point(field_release:vega.Proposal.reference)
  return reference_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Proposal::set_allocated_reference(std::string* reference) {
  if (reference != nullptr) {

  } else {

  }
  reference_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), reference,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vega.Proposal.reference)
}

// string partyID = 3 [json_name = "partyID", (.validator.field) = {
inline void Proposal::clear_partyid() {
  partyid_.ClearToEmpty();
}
inline const std::string& Proposal::partyid() const {
  // @@protoc_insertion_point(field_get:vega.Proposal.partyID)
  return _internal_partyid();
}
inline void Proposal::set_partyid(const std::string& value) {
  _internal_set_partyid(value);
  // @@protoc_insertion_point(field_set:vega.Proposal.partyID)
}
inline std::string* Proposal::mutable_partyid() {
  // @@protoc_insertion_point(field_mutable:vega.Proposal.partyID)
  return _internal_mutable_partyid();
}
inline const std::string& Proposal::_internal_partyid() const {
  return partyid_.Get();
}
inline void Proposal::_internal_set_partyid(const std::string& value) {

  partyid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Proposal::set_partyid(std::string&& value) {

  partyid_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vega.Proposal.partyID)
}
inline void Proposal::set_partyid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  partyid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:vega.Proposal.partyID)
}
inline void Proposal::set_partyid(const char* value,
    size_t size) {

  partyid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vega.Proposal.partyID)
}
inline std::string* Proposal::_internal_mutable_partyid() {

  return partyid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Proposal::release_partyid() {
  // @@protoc_insertion_point(field_release:vega.Proposal.partyID)
  return partyid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Proposal::set_allocated_partyid(std::string* partyid) {
  if (partyid != nullptr) {

  } else {

  }
  partyid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), partyid,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vega.Proposal.partyID)
}

// .vega.Proposal.State state = 4 [json_name = "state", (.validator.field) = {
inline void Proposal::clear_state() {
  state_ = 0;
}
inline ::vega::Proposal_State Proposal::_internal_state() const {
  return static_cast< ::vega::Proposal_State >(state_);
}
inline ::vega::Proposal_State Proposal::state() const {
  // @@protoc_insertion_point(field_get:vega.Proposal.state)
  return _internal_state();
}
inline void Proposal::_internal_set_state(::vega::Proposal_State value) {

  state_ = value;
}
inline void Proposal::set_state(::vega::Proposal_State value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:vega.Proposal.state)
}

// int64 timestamp = 5 [json_name = "timestamp"];
inline void Proposal::clear_timestamp() {
  timestamp_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Proposal::_internal_timestamp() const {
  return timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Proposal::timestamp() const {
  // @@protoc_insertion_point(field_get:vega.Proposal.timestamp)
  return _internal_timestamp();
}
inline void Proposal::_internal_set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value) {

  timestamp_ = value;
}
inline void Proposal::set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:vega.Proposal.timestamp)
}

// .vega.ProposalTerms terms = 6 [json_name = "terms", (.validator.field) = {
inline bool Proposal::_internal_has_terms() const {
  return this != internal_default_instance() && terms_ != nullptr;
}
inline bool Proposal::has_terms() const {
  return _internal_has_terms();
}
inline void Proposal::clear_terms() {
  if (GetArena() == nullptr && terms_ != nullptr) {
    delete terms_;
  }
  terms_ = nullptr;
}
inline const ::vega::ProposalTerms& Proposal::_internal_terms() const {
  const ::vega::ProposalTerms* p = terms_;
  return p != nullptr ? *p : reinterpret_cast<const ::vega::ProposalTerms&>(
      ::vega::_ProposalTerms_default_instance_);
}
inline const ::vega::ProposalTerms& Proposal::terms() const {
  // @@protoc_insertion_point(field_get:vega.Proposal.terms)
  return _internal_terms();
}
inline void Proposal::unsafe_arena_set_allocated_terms(
    ::vega::ProposalTerms* terms) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(terms_);
  }
  terms_ = terms;
  if (terms) {

  } else {

  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vega.Proposal.terms)
}
inline ::vega::ProposalTerms* Proposal::release_terms() {

  ::vega::ProposalTerms* temp = terms_;
  terms_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::vega::ProposalTerms* Proposal::unsafe_arena_release_terms() {
  // @@protoc_insertion_point(field_release:vega.Proposal.terms)

  ::vega::ProposalTerms* temp = terms_;
  terms_ = nullptr;
  return temp;
}
inline ::vega::ProposalTerms* Proposal::_internal_mutable_terms() {

  if (terms_ == nullptr) {
    auto* p = CreateMaybeMessage<::vega::ProposalTerms>(GetArena());
    terms_ = p;
  }
  return terms_;
}
inline ::vega::ProposalTerms* Proposal::mutable_terms() {
  // @@protoc_insertion_point(field_mutable:vega.Proposal.terms)
  return _internal_mutable_terms();
}
inline void Proposal::set_allocated_terms(::vega::ProposalTerms* terms) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete terms_;
  }
  if (terms) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(terms);
    if (message_arena != submessage_arena) {
      terms = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, terms, submessage_arena);
    }

  } else {

  }
  terms_ = terms;
  // @@protoc_insertion_point(field_set_allocated:vega.Proposal.terms)
}

// .vega.ProposalError reason = 7 [json_name = "reason"];
inline void Proposal::clear_reason() {
  reason_ = 0;
}
inline ::vega::ProposalError Proposal::_internal_reason() const {
  return static_cast< ::vega::ProposalError >(reason_);
}
inline ::vega::ProposalError Proposal::reason() const {
  // @@protoc_insertion_point(field_get:vega.Proposal.reason)
  return _internal_reason();
}
inline void Proposal::_internal_set_reason(::vega::ProposalError value) {

  reason_ = value;
}
inline void Proposal::set_reason(::vega::ProposalError value) {
  _internal_set_reason(value);
  // @@protoc_insertion_point(field_set:vega.Proposal.reason)
}

// -------------------------------------------------------------------

// Vote

// string partyID = 1 [json_name = "partyID", (.validator.field) = {
inline void Vote::clear_partyid() {
  partyid_.ClearToEmpty();
}
inline const std::string& Vote::partyid() const {
  // @@protoc_insertion_point(field_get:vega.Vote.partyID)
  return _internal_partyid();
}
inline void Vote::set_partyid(const std::string& value) {
  _internal_set_partyid(value);
  // @@protoc_insertion_point(field_set:vega.Vote.partyID)
}
inline std::string* Vote::mutable_partyid() {
  // @@protoc_insertion_point(field_mutable:vega.Vote.partyID)
  return _internal_mutable_partyid();
}
inline const std::string& Vote::_internal_partyid() const {
  return partyid_.Get();
}
inline void Vote::_internal_set_partyid(const std::string& value) {

  partyid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Vote::set_partyid(std::string&& value) {

  partyid_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vega.Vote.partyID)
}
inline void Vote::set_partyid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  partyid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:vega.Vote.partyID)
}
inline void Vote::set_partyid(const char* value,
    size_t size) {

  partyid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vega.Vote.partyID)
}
inline std::string* Vote::_internal_mutable_partyid() {

  return partyid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Vote::release_partyid() {
  // @@protoc_insertion_point(field_release:vega.Vote.partyID)
  return partyid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Vote::set_allocated_partyid(std::string* partyid) {
  if (partyid != nullptr) {

  } else {

  }
  partyid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), partyid,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vega.Vote.partyID)
}

// .vega.Vote.Value value = 2 [json_name = "value", (.validator.field) = {
inline void Vote::clear_value() {
  value_ = 0;
}
inline ::vega::Vote_Value Vote::_internal_value() const {
  return static_cast< ::vega::Vote_Value >(value_);
}
inline ::vega::Vote_Value Vote::value() const {
  // @@protoc_insertion_point(field_get:vega.Vote.value)
  return _internal_value();
}
inline void Vote::_internal_set_value(::vega::Vote_Value value) {

  value_ = value;
}
inline void Vote::set_value(::vega::Vote_Value value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:vega.Vote.value)
}

// string proposalID = 3 [json_name = "proposalID", (.validator.field) = {
inline void Vote::clear_proposalid() {
  proposalid_.ClearToEmpty();
}
inline const std::string& Vote::proposalid() const {
  // @@protoc_insertion_point(field_get:vega.Vote.proposalID)
  return _internal_proposalid();
}
inline void Vote::set_proposalid(const std::string& value) {
  _internal_set_proposalid(value);
  // @@protoc_insertion_point(field_set:vega.Vote.proposalID)
}
inline std::string* Vote::mutable_proposalid() {
  // @@protoc_insertion_point(field_mutable:vega.Vote.proposalID)
  return _internal_mutable_proposalid();
}
inline const std::string& Vote::_internal_proposalid() const {
  return proposalid_.Get();
}
inline void Vote::_internal_set_proposalid(const std::string& value) {

  proposalid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Vote::set_proposalid(std::string&& value) {

  proposalid_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vega.Vote.proposalID)
}
inline void Vote::set_proposalid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  proposalid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:vega.Vote.proposalID)
}
inline void Vote::set_proposalid(const char* value,
    size_t size) {

  proposalid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vega.Vote.proposalID)
}
inline std::string* Vote::_internal_mutable_proposalid() {

  return proposalid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Vote::release_proposalid() {
  // @@protoc_insertion_point(field_release:vega.Vote.proposalID)
  return proposalid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Vote::set_allocated_proposalid(std::string* proposalid) {
  if (proposalid != nullptr) {

  } else {

  }
  proposalid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), proposalid,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vega.Vote.proposalID)
}

// int64 timestamp = 4 [json_name = "timestamp"];
inline void Vote::clear_timestamp() {
  timestamp_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Vote::_internal_timestamp() const {
  return timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Vote::timestamp() const {
  // @@protoc_insertion_point(field_get:vega.Vote.timestamp)
  return _internal_timestamp();
}
inline void Vote::_internal_set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value) {

  timestamp_ = value;
}
inline void Vote::set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:vega.Vote.timestamp)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace vega

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::vega::Proposal_State> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::vega::Proposal_State>() {
  return ::vega::Proposal_State_descriptor();
}
template <> struct is_proto_enum< ::vega::Vote_Value> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::vega::Vote_Value>() {
  return ::vega::Vote_Value_descriptor();
}
template <> struct is_proto_enum< ::vega::ProposalError> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::vega::ProposalError>() {
  return ::vega::ProposalError_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_governance_2eproto

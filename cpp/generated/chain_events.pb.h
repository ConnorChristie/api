// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: chain_events.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_chain_5fevents_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_chain_5fevents_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3014000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3014000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_chain_5fevents_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_chain_5fevents_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[18]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_chain_5fevents_2eproto;
namespace vega {
class AddValidator;
class AddValidatorDefaultTypeInternal;
extern AddValidatorDefaultTypeInternal _AddValidator_default_instance_;
class BTCDeposit;
class BTCDepositDefaultTypeInternal;
extern BTCDepositDefaultTypeInternal _BTCDeposit_default_instance_;
class BTCEvent;
class BTCEventDefaultTypeInternal;
extern BTCEventDefaultTypeInternal _BTCEvent_default_instance_;
class BTCWithdrawal;
class BTCWithdrawalDefaultTypeInternal;
extern BTCWithdrawalDefaultTypeInternal _BTCWithdrawal_default_instance_;
class BitcoinAddress;
class BitcoinAddressDefaultTypeInternal;
extern BitcoinAddressDefaultTypeInternal _BitcoinAddress_default_instance_;
class BuiltinAssetDeposit;
class BuiltinAssetDepositDefaultTypeInternal;
extern BuiltinAssetDepositDefaultTypeInternal _BuiltinAssetDeposit_default_instance_;
class BuiltinAssetEvent;
class BuiltinAssetEventDefaultTypeInternal;
extern BuiltinAssetEventDefaultTypeInternal _BuiltinAssetEvent_default_instance_;
class BuiltinAssetWithdrawal;
class BuiltinAssetWithdrawalDefaultTypeInternal;
extern BuiltinAssetWithdrawalDefaultTypeInternal _BuiltinAssetWithdrawal_default_instance_;
class ChainEvent;
class ChainEventDefaultTypeInternal;
extern ChainEventDefaultTypeInternal _ChainEvent_default_instance_;
class ERC20AssetDelist;
class ERC20AssetDelistDefaultTypeInternal;
extern ERC20AssetDelistDefaultTypeInternal _ERC20AssetDelist_default_instance_;
class ERC20AssetList;
class ERC20AssetListDefaultTypeInternal;
extern ERC20AssetListDefaultTypeInternal _ERC20AssetList_default_instance_;
class ERC20Deposit;
class ERC20DepositDefaultTypeInternal;
extern ERC20DepositDefaultTypeInternal _ERC20Deposit_default_instance_;
class ERC20Event;
class ERC20EventDefaultTypeInternal;
extern ERC20EventDefaultTypeInternal _ERC20Event_default_instance_;
class ERC20Withdrawal;
class ERC20WithdrawalDefaultTypeInternal;
extern ERC20WithdrawalDefaultTypeInternal _ERC20Withdrawal_default_instance_;
class EthereumAddress;
class EthereumAddressDefaultTypeInternal;
extern EthereumAddressDefaultTypeInternal _EthereumAddress_default_instance_;
class Identifier;
class IdentifierDefaultTypeInternal;
extern IdentifierDefaultTypeInternal _Identifier_default_instance_;
class RemoveValidator;
class RemoveValidatorDefaultTypeInternal;
extern RemoveValidatorDefaultTypeInternal _RemoveValidator_default_instance_;
class ValidatorEvent;
class ValidatorEventDefaultTypeInternal;
extern ValidatorEventDefaultTypeInternal _ValidatorEvent_default_instance_;
}  // namespace vega
PROTOBUF_NAMESPACE_OPEN
template<> ::vega::AddValidator* Arena::CreateMaybeMessage<::vega::AddValidator>(Arena*);
template<> ::vega::BTCDeposit* Arena::CreateMaybeMessage<::vega::BTCDeposit>(Arena*);
template<> ::vega::BTCEvent* Arena::CreateMaybeMessage<::vega::BTCEvent>(Arena*);
template<> ::vega::BTCWithdrawal* Arena::CreateMaybeMessage<::vega::BTCWithdrawal>(Arena*);
template<> ::vega::BitcoinAddress* Arena::CreateMaybeMessage<::vega::BitcoinAddress>(Arena*);
template<> ::vega::BuiltinAssetDeposit* Arena::CreateMaybeMessage<::vega::BuiltinAssetDeposit>(Arena*);
template<> ::vega::BuiltinAssetEvent* Arena::CreateMaybeMessage<::vega::BuiltinAssetEvent>(Arena*);
template<> ::vega::BuiltinAssetWithdrawal* Arena::CreateMaybeMessage<::vega::BuiltinAssetWithdrawal>(Arena*);
template<> ::vega::ChainEvent* Arena::CreateMaybeMessage<::vega::ChainEvent>(Arena*);
template<> ::vega::ERC20AssetDelist* Arena::CreateMaybeMessage<::vega::ERC20AssetDelist>(Arena*);
template<> ::vega::ERC20AssetList* Arena::CreateMaybeMessage<::vega::ERC20AssetList>(Arena*);
template<> ::vega::ERC20Deposit* Arena::CreateMaybeMessage<::vega::ERC20Deposit>(Arena*);
template<> ::vega::ERC20Event* Arena::CreateMaybeMessage<::vega::ERC20Event>(Arena*);
template<> ::vega::ERC20Withdrawal* Arena::CreateMaybeMessage<::vega::ERC20Withdrawal>(Arena*);
template<> ::vega::EthereumAddress* Arena::CreateMaybeMessage<::vega::EthereumAddress>(Arena*);
template<> ::vega::Identifier* Arena::CreateMaybeMessage<::vega::Identifier>(Arena*);
template<> ::vega::RemoveValidator* Arena::CreateMaybeMessage<::vega::RemoveValidator>(Arena*);
template<> ::vega::ValidatorEvent* Arena::CreateMaybeMessage<::vega::ValidatorEvent>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace vega {

// ===================================================================

class BuiltinAssetDeposit PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vega.BuiltinAssetDeposit) */ {
 public:
  inline BuiltinAssetDeposit() : BuiltinAssetDeposit(nullptr) {}
  virtual ~BuiltinAssetDeposit();

  BuiltinAssetDeposit(const BuiltinAssetDeposit& from);
  BuiltinAssetDeposit(BuiltinAssetDeposit&& from) noexcept
    : BuiltinAssetDeposit() {
    *this = ::std::move(from);
  }

  inline BuiltinAssetDeposit& operator=(const BuiltinAssetDeposit& from) {
    CopyFrom(from);
    return *this;
  }
  inline BuiltinAssetDeposit& operator=(BuiltinAssetDeposit&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BuiltinAssetDeposit& default_instance();

  static inline const BuiltinAssetDeposit* internal_default_instance() {
    return reinterpret_cast<const BuiltinAssetDeposit*>(
               &_BuiltinAssetDeposit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(BuiltinAssetDeposit& a, BuiltinAssetDeposit& b) {
    a.Swap(&b);
  }
  inline void Swap(BuiltinAssetDeposit* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BuiltinAssetDeposit* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BuiltinAssetDeposit* New() const final {
    return CreateMaybeMessage<BuiltinAssetDeposit>(nullptr);
  }

  BuiltinAssetDeposit* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BuiltinAssetDeposit>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BuiltinAssetDeposit& from);
  void MergeFrom(const BuiltinAssetDeposit& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BuiltinAssetDeposit* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vega.BuiltinAssetDeposit";
  }
  protected:
  explicit BuiltinAssetDeposit(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_chain_5fevents_2eproto);
    return ::descriptor_table_chain_5fevents_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVegaAssetIDFieldNumber = 1,
    kPartyIDFieldNumber = 2,
    kAmountFieldNumber = 3,
  };
  // string vegaAssetID = 1 [json_name = "vegaAssetID"];
  void clear_vegaassetid();
  const std::string& vegaassetid() const;
  void set_vegaassetid(const std::string& value);
  void set_vegaassetid(std::string&& value);
  void set_vegaassetid(const char* value);
  void set_vegaassetid(const char* value, size_t size);
  std::string* mutable_vegaassetid();
  std::string* release_vegaassetid();
  void set_allocated_vegaassetid(std::string* vegaassetid);
  private:
  const std::string& _internal_vegaassetid() const;
  void _internal_set_vegaassetid(const std::string& value);
  std::string* _internal_mutable_vegaassetid();
  public:

  // string partyID = 2 [json_name = "partyID"];
  void clear_partyid();
  const std::string& partyid() const;
  void set_partyid(const std::string& value);
  void set_partyid(std::string&& value);
  void set_partyid(const char* value);
  void set_partyid(const char* value, size_t size);
  std::string* mutable_partyid();
  std::string* release_partyid();
  void set_allocated_partyid(std::string* partyid);
  private:
  const std::string& _internal_partyid() const;
  void _internal_set_partyid(const std::string& value);
  std::string* _internal_mutable_partyid();
  public:

  // uint64 amount = 3 [json_name = "amount"];
  void clear_amount();
  ::PROTOBUF_NAMESPACE_ID::uint64 amount() const;
  void set_amount(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_amount() const;
  void _internal_set_amount(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:vega.BuiltinAssetDeposit)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vegaassetid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr partyid_;
  ::PROTOBUF_NAMESPACE_ID::uint64 amount_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_chain_5fevents_2eproto;
};
// -------------------------------------------------------------------

class BuiltinAssetWithdrawal PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vega.BuiltinAssetWithdrawal) */ {
 public:
  inline BuiltinAssetWithdrawal() : BuiltinAssetWithdrawal(nullptr) {}
  virtual ~BuiltinAssetWithdrawal();

  BuiltinAssetWithdrawal(const BuiltinAssetWithdrawal& from);
  BuiltinAssetWithdrawal(BuiltinAssetWithdrawal&& from) noexcept
    : BuiltinAssetWithdrawal() {
    *this = ::std::move(from);
  }

  inline BuiltinAssetWithdrawal& operator=(const BuiltinAssetWithdrawal& from) {
    CopyFrom(from);
    return *this;
  }
  inline BuiltinAssetWithdrawal& operator=(BuiltinAssetWithdrawal&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BuiltinAssetWithdrawal& default_instance();

  static inline const BuiltinAssetWithdrawal* internal_default_instance() {
    return reinterpret_cast<const BuiltinAssetWithdrawal*>(
               &_BuiltinAssetWithdrawal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(BuiltinAssetWithdrawal& a, BuiltinAssetWithdrawal& b) {
    a.Swap(&b);
  }
  inline void Swap(BuiltinAssetWithdrawal* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BuiltinAssetWithdrawal* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BuiltinAssetWithdrawal* New() const final {
    return CreateMaybeMessage<BuiltinAssetWithdrawal>(nullptr);
  }

  BuiltinAssetWithdrawal* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BuiltinAssetWithdrawal>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BuiltinAssetWithdrawal& from);
  void MergeFrom(const BuiltinAssetWithdrawal& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BuiltinAssetWithdrawal* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vega.BuiltinAssetWithdrawal";
  }
  protected:
  explicit BuiltinAssetWithdrawal(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_chain_5fevents_2eproto);
    return ::descriptor_table_chain_5fevents_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVegaAssetIDFieldNumber = 1,
    kPartyIDFieldNumber = 2,
    kAmountFieldNumber = 3,
  };
  // string vegaAssetID = 1 [json_name = "vegaAssetID"];
  void clear_vegaassetid();
  const std::string& vegaassetid() const;
  void set_vegaassetid(const std::string& value);
  void set_vegaassetid(std::string&& value);
  void set_vegaassetid(const char* value);
  void set_vegaassetid(const char* value, size_t size);
  std::string* mutable_vegaassetid();
  std::string* release_vegaassetid();
  void set_allocated_vegaassetid(std::string* vegaassetid);
  private:
  const std::string& _internal_vegaassetid() const;
  void _internal_set_vegaassetid(const std::string& value);
  std::string* _internal_mutable_vegaassetid();
  public:

  // string partyID = 2 [json_name = "partyID"];
  void clear_partyid();
  const std::string& partyid() const;
  void set_partyid(const std::string& value);
  void set_partyid(std::string&& value);
  void set_partyid(const char* value);
  void set_partyid(const char* value, size_t size);
  std::string* mutable_partyid();
  std::string* release_partyid();
  void set_allocated_partyid(std::string* partyid);
  private:
  const std::string& _internal_partyid() const;
  void _internal_set_partyid(const std::string& value);
  std::string* _internal_mutable_partyid();
  public:

  // uint64 amount = 3 [json_name = "amount"];
  void clear_amount();
  ::PROTOBUF_NAMESPACE_ID::uint64 amount() const;
  void set_amount(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_amount() const;
  void _internal_set_amount(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:vega.BuiltinAssetWithdrawal)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vegaassetid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr partyid_;
  ::PROTOBUF_NAMESPACE_ID::uint64 amount_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_chain_5fevents_2eproto;
};
// -------------------------------------------------------------------

class BuiltinAssetEvent PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vega.BuiltinAssetEvent) */ {
 public:
  inline BuiltinAssetEvent() : BuiltinAssetEvent(nullptr) {}
  virtual ~BuiltinAssetEvent();

  BuiltinAssetEvent(const BuiltinAssetEvent& from);
  BuiltinAssetEvent(BuiltinAssetEvent&& from) noexcept
    : BuiltinAssetEvent() {
    *this = ::std::move(from);
  }

  inline BuiltinAssetEvent& operator=(const BuiltinAssetEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline BuiltinAssetEvent& operator=(BuiltinAssetEvent&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BuiltinAssetEvent& default_instance();

  enum ActionCase {
    kDeposit = 1001,
    kWithdrawal = 1002,
    ACTION_NOT_SET = 0,
  };

  static inline const BuiltinAssetEvent* internal_default_instance() {
    return reinterpret_cast<const BuiltinAssetEvent*>(
               &_BuiltinAssetEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(BuiltinAssetEvent& a, BuiltinAssetEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(BuiltinAssetEvent* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BuiltinAssetEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BuiltinAssetEvent* New() const final {
    return CreateMaybeMessage<BuiltinAssetEvent>(nullptr);
  }

  BuiltinAssetEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BuiltinAssetEvent>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BuiltinAssetEvent& from);
  void MergeFrom(const BuiltinAssetEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BuiltinAssetEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vega.BuiltinAssetEvent";
  }
  protected:
  explicit BuiltinAssetEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_chain_5fevents_2eproto);
    return ::descriptor_table_chain_5fevents_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDepositFieldNumber = 1001,
    kWithdrawalFieldNumber = 1002,
  };
  // .vega.BuiltinAssetDeposit deposit = 1001 [json_name = "deposit"];
  bool has_deposit() const;
  private:
  bool _internal_has_deposit() const;
  public:
  void clear_deposit();
  const ::vega::BuiltinAssetDeposit& deposit() const;
  ::vega::BuiltinAssetDeposit* release_deposit();
  ::vega::BuiltinAssetDeposit* mutable_deposit();
  void set_allocated_deposit(::vega::BuiltinAssetDeposit* deposit);
  private:
  const ::vega::BuiltinAssetDeposit& _internal_deposit() const;
  ::vega::BuiltinAssetDeposit* _internal_mutable_deposit();
  public:
  void unsafe_arena_set_allocated_deposit(
      ::vega::BuiltinAssetDeposit* deposit);
  ::vega::BuiltinAssetDeposit* unsafe_arena_release_deposit();

  // .vega.BuiltinAssetWithdrawal withdrawal = 1002 [json_name = "withdrawal"];
  bool has_withdrawal() const;
  private:
  bool _internal_has_withdrawal() const;
  public:
  void clear_withdrawal();
  const ::vega::BuiltinAssetWithdrawal& withdrawal() const;
  ::vega::BuiltinAssetWithdrawal* release_withdrawal();
  ::vega::BuiltinAssetWithdrawal* mutable_withdrawal();
  void set_allocated_withdrawal(::vega::BuiltinAssetWithdrawal* withdrawal);
  private:
  const ::vega::BuiltinAssetWithdrawal& _internal_withdrawal() const;
  ::vega::BuiltinAssetWithdrawal* _internal_mutable_withdrawal();
  public:
  void unsafe_arena_set_allocated_withdrawal(
      ::vega::BuiltinAssetWithdrawal* withdrawal);
  ::vega::BuiltinAssetWithdrawal* unsafe_arena_release_withdrawal();

  void clear_action();
  ActionCase action_case() const;
  // @@protoc_insertion_point(class_scope:vega.BuiltinAssetEvent)
 private:
  class _Internal;
  void set_has_deposit();
  void set_has_withdrawal();

  inline bool has_action() const;
  inline void clear_has_action();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union ActionUnion {
    ActionUnion() {}
    ::vega::BuiltinAssetDeposit* deposit_;
    ::vega::BuiltinAssetWithdrawal* withdrawal_;
  } action_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_chain_5fevents_2eproto;
};
// -------------------------------------------------------------------

class ERC20AssetList PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vega.ERC20AssetList) */ {
 public:
  inline ERC20AssetList() : ERC20AssetList(nullptr) {}
  virtual ~ERC20AssetList();

  ERC20AssetList(const ERC20AssetList& from);
  ERC20AssetList(ERC20AssetList&& from) noexcept
    : ERC20AssetList() {
    *this = ::std::move(from);
  }

  inline ERC20AssetList& operator=(const ERC20AssetList& from) {
    CopyFrom(from);
    return *this;
  }
  inline ERC20AssetList& operator=(ERC20AssetList&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ERC20AssetList& default_instance();

  static inline const ERC20AssetList* internal_default_instance() {
    return reinterpret_cast<const ERC20AssetList*>(
               &_ERC20AssetList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ERC20AssetList& a, ERC20AssetList& b) {
    a.Swap(&b);
  }
  inline void Swap(ERC20AssetList* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ERC20AssetList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ERC20AssetList* New() const final {
    return CreateMaybeMessage<ERC20AssetList>(nullptr);
  }

  ERC20AssetList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ERC20AssetList>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ERC20AssetList& from);
  void MergeFrom(const ERC20AssetList& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ERC20AssetList* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vega.ERC20AssetList";
  }
  protected:
  explicit ERC20AssetList(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_chain_5fevents_2eproto);
    return ::descriptor_table_chain_5fevents_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVegaAssetIDFieldNumber = 1,
  };
  // string vegaAssetID = 1 [json_name = "vegaAssetID"];
  void clear_vegaassetid();
  const std::string& vegaassetid() const;
  void set_vegaassetid(const std::string& value);
  void set_vegaassetid(std::string&& value);
  void set_vegaassetid(const char* value);
  void set_vegaassetid(const char* value, size_t size);
  std::string* mutable_vegaassetid();
  std::string* release_vegaassetid();
  void set_allocated_vegaassetid(std::string* vegaassetid);
  private:
  const std::string& _internal_vegaassetid() const;
  void _internal_set_vegaassetid(const std::string& value);
  std::string* _internal_mutable_vegaassetid();
  public:

  // @@protoc_insertion_point(class_scope:vega.ERC20AssetList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vegaassetid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_chain_5fevents_2eproto;
};
// -------------------------------------------------------------------

class ERC20AssetDelist PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vega.ERC20AssetDelist) */ {
 public:
  inline ERC20AssetDelist() : ERC20AssetDelist(nullptr) {}
  virtual ~ERC20AssetDelist();

  ERC20AssetDelist(const ERC20AssetDelist& from);
  ERC20AssetDelist(ERC20AssetDelist&& from) noexcept
    : ERC20AssetDelist() {
    *this = ::std::move(from);
  }

  inline ERC20AssetDelist& operator=(const ERC20AssetDelist& from) {
    CopyFrom(from);
    return *this;
  }
  inline ERC20AssetDelist& operator=(ERC20AssetDelist&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ERC20AssetDelist& default_instance();

  static inline const ERC20AssetDelist* internal_default_instance() {
    return reinterpret_cast<const ERC20AssetDelist*>(
               &_ERC20AssetDelist_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ERC20AssetDelist& a, ERC20AssetDelist& b) {
    a.Swap(&b);
  }
  inline void Swap(ERC20AssetDelist* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ERC20AssetDelist* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ERC20AssetDelist* New() const final {
    return CreateMaybeMessage<ERC20AssetDelist>(nullptr);
  }

  ERC20AssetDelist* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ERC20AssetDelist>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ERC20AssetDelist& from);
  void MergeFrom(const ERC20AssetDelist& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ERC20AssetDelist* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vega.ERC20AssetDelist";
  }
  protected:
  explicit ERC20AssetDelist(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_chain_5fevents_2eproto);
    return ::descriptor_table_chain_5fevents_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVegaAssetIDFieldNumber = 1,
  };
  // string vegaAssetID = 1 [json_name = "vegaAssetID"];
  void clear_vegaassetid();
  const std::string& vegaassetid() const;
  void set_vegaassetid(const std::string& value);
  void set_vegaassetid(std::string&& value);
  void set_vegaassetid(const char* value);
  void set_vegaassetid(const char* value, size_t size);
  std::string* mutable_vegaassetid();
  std::string* release_vegaassetid();
  void set_allocated_vegaassetid(std::string* vegaassetid);
  private:
  const std::string& _internal_vegaassetid() const;
  void _internal_set_vegaassetid(const std::string& value);
  std::string* _internal_mutable_vegaassetid();
  public:

  // @@protoc_insertion_point(class_scope:vega.ERC20AssetDelist)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vegaassetid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_chain_5fevents_2eproto;
};
// -------------------------------------------------------------------

class ERC20Deposit PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vega.ERC20Deposit) */ {
 public:
  inline ERC20Deposit() : ERC20Deposit(nullptr) {}
  virtual ~ERC20Deposit();

  ERC20Deposit(const ERC20Deposit& from);
  ERC20Deposit(ERC20Deposit&& from) noexcept
    : ERC20Deposit() {
    *this = ::std::move(from);
  }

  inline ERC20Deposit& operator=(const ERC20Deposit& from) {
    CopyFrom(from);
    return *this;
  }
  inline ERC20Deposit& operator=(ERC20Deposit&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ERC20Deposit& default_instance();

  static inline const ERC20Deposit* internal_default_instance() {
    return reinterpret_cast<const ERC20Deposit*>(
               &_ERC20Deposit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ERC20Deposit& a, ERC20Deposit& b) {
    a.Swap(&b);
  }
  inline void Swap(ERC20Deposit* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ERC20Deposit* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ERC20Deposit* New() const final {
    return CreateMaybeMessage<ERC20Deposit>(nullptr);
  }

  ERC20Deposit* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ERC20Deposit>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ERC20Deposit& from);
  void MergeFrom(const ERC20Deposit& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ERC20Deposit* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vega.ERC20Deposit";
  }
  protected:
  explicit ERC20Deposit(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_chain_5fevents_2eproto);
    return ::descriptor_table_chain_5fevents_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVegaAssetIDFieldNumber = 1,
    kSourceEthereumAddressFieldNumber = 2,
    kTargetPartyIDFieldNumber = 3,
    kAmountFieldNumber = 4,
  };
  // string vegaAssetID = 1 [json_name = "vegaAssetID"];
  void clear_vegaassetid();
  const std::string& vegaassetid() const;
  void set_vegaassetid(const std::string& value);
  void set_vegaassetid(std::string&& value);
  void set_vegaassetid(const char* value);
  void set_vegaassetid(const char* value, size_t size);
  std::string* mutable_vegaassetid();
  std::string* release_vegaassetid();
  void set_allocated_vegaassetid(std::string* vegaassetid);
  private:
  const std::string& _internal_vegaassetid() const;
  void _internal_set_vegaassetid(const std::string& value);
  std::string* _internal_mutable_vegaassetid();
  public:

  // string sourceEthereumAddress = 2 [json_name = "sourceEthereumAddress"];
  void clear_sourceethereumaddress();
  const std::string& sourceethereumaddress() const;
  void set_sourceethereumaddress(const std::string& value);
  void set_sourceethereumaddress(std::string&& value);
  void set_sourceethereumaddress(const char* value);
  void set_sourceethereumaddress(const char* value, size_t size);
  std::string* mutable_sourceethereumaddress();
  std::string* release_sourceethereumaddress();
  void set_allocated_sourceethereumaddress(std::string* sourceethereumaddress);
  private:
  const std::string& _internal_sourceethereumaddress() const;
  void _internal_set_sourceethereumaddress(const std::string& value);
  std::string* _internal_mutable_sourceethereumaddress();
  public:

  // string targetPartyID = 3 [json_name = "targetPartyID"];
  void clear_targetpartyid();
  const std::string& targetpartyid() const;
  void set_targetpartyid(const std::string& value);
  void set_targetpartyid(std::string&& value);
  void set_targetpartyid(const char* value);
  void set_targetpartyid(const char* value, size_t size);
  std::string* mutable_targetpartyid();
  std::string* release_targetpartyid();
  void set_allocated_targetpartyid(std::string* targetpartyid);
  private:
  const std::string& _internal_targetpartyid() const;
  void _internal_set_targetpartyid(const std::string& value);
  std::string* _internal_mutable_targetpartyid();
  public:

  // string amount = 4 [json_name = "amount"];
  void clear_amount();
  const std::string& amount() const;
  void set_amount(const std::string& value);
  void set_amount(std::string&& value);
  void set_amount(const char* value);
  void set_amount(const char* value, size_t size);
  std::string* mutable_amount();
  std::string* release_amount();
  void set_allocated_amount(std::string* amount);
  private:
  const std::string& _internal_amount() const;
  void _internal_set_amount(const std::string& value);
  std::string* _internal_mutable_amount();
  public:

  // @@protoc_insertion_point(class_scope:vega.ERC20Deposit)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vegaassetid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sourceethereumaddress_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr targetpartyid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr amount_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_chain_5fevents_2eproto;
};
// -------------------------------------------------------------------

class ERC20Withdrawal PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vega.ERC20Withdrawal) */ {
 public:
  inline ERC20Withdrawal() : ERC20Withdrawal(nullptr) {}
  virtual ~ERC20Withdrawal();

  ERC20Withdrawal(const ERC20Withdrawal& from);
  ERC20Withdrawal(ERC20Withdrawal&& from) noexcept
    : ERC20Withdrawal() {
    *this = ::std::move(from);
  }

  inline ERC20Withdrawal& operator=(const ERC20Withdrawal& from) {
    CopyFrom(from);
    return *this;
  }
  inline ERC20Withdrawal& operator=(ERC20Withdrawal&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ERC20Withdrawal& default_instance();

  static inline const ERC20Withdrawal* internal_default_instance() {
    return reinterpret_cast<const ERC20Withdrawal*>(
               &_ERC20Withdrawal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ERC20Withdrawal& a, ERC20Withdrawal& b) {
    a.Swap(&b);
  }
  inline void Swap(ERC20Withdrawal* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ERC20Withdrawal* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ERC20Withdrawal* New() const final {
    return CreateMaybeMessage<ERC20Withdrawal>(nullptr);
  }

  ERC20Withdrawal* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ERC20Withdrawal>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ERC20Withdrawal& from);
  void MergeFrom(const ERC20Withdrawal& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ERC20Withdrawal* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vega.ERC20Withdrawal";
  }
  protected:
  explicit ERC20Withdrawal(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_chain_5fevents_2eproto);
    return ::descriptor_table_chain_5fevents_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVegaAssetIDFieldNumber = 1,
    kTargetEthereumAddressFieldNumber = 2,
    kReferenceNonceFieldNumber = 3,
  };
  // string vegaAssetID = 1 [json_name = "vegaAssetID"];
  void clear_vegaassetid();
  const std::string& vegaassetid() const;
  void set_vegaassetid(const std::string& value);
  void set_vegaassetid(std::string&& value);
  void set_vegaassetid(const char* value);
  void set_vegaassetid(const char* value, size_t size);
  std::string* mutable_vegaassetid();
  std::string* release_vegaassetid();
  void set_allocated_vegaassetid(std::string* vegaassetid);
  private:
  const std::string& _internal_vegaassetid() const;
  void _internal_set_vegaassetid(const std::string& value);
  std::string* _internal_mutable_vegaassetid();
  public:

  // string targetEthereumAddress = 2 [json_name = "targetEthereumAddress"];
  void clear_targetethereumaddress();
  const std::string& targetethereumaddress() const;
  void set_targetethereumaddress(const std::string& value);
  void set_targetethereumaddress(std::string&& value);
  void set_targetethereumaddress(const char* value);
  void set_targetethereumaddress(const char* value, size_t size);
  std::string* mutable_targetethereumaddress();
  std::string* release_targetethereumaddress();
  void set_allocated_targetethereumaddress(std::string* targetethereumaddress);
  private:
  const std::string& _internal_targetethereumaddress() const;
  void _internal_set_targetethereumaddress(const std::string& value);
  std::string* _internal_mutable_targetethereumaddress();
  public:

  // string referenceNonce = 3 [json_name = "referenceNonce"];
  void clear_referencenonce();
  const std::string& referencenonce() const;
  void set_referencenonce(const std::string& value);
  void set_referencenonce(std::string&& value);
  void set_referencenonce(const char* value);
  void set_referencenonce(const char* value, size_t size);
  std::string* mutable_referencenonce();
  std::string* release_referencenonce();
  void set_allocated_referencenonce(std::string* referencenonce);
  private:
  const std::string& _internal_referencenonce() const;
  void _internal_set_referencenonce(const std::string& value);
  std::string* _internal_mutable_referencenonce();
  public:

  // @@protoc_insertion_point(class_scope:vega.ERC20Withdrawal)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vegaassetid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr targetethereumaddress_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr referencenonce_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_chain_5fevents_2eproto;
};
// -------------------------------------------------------------------

class ERC20Event PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vega.ERC20Event) */ {
 public:
  inline ERC20Event() : ERC20Event(nullptr) {}
  virtual ~ERC20Event();

  ERC20Event(const ERC20Event& from);
  ERC20Event(ERC20Event&& from) noexcept
    : ERC20Event() {
    *this = ::std::move(from);
  }

  inline ERC20Event& operator=(const ERC20Event& from) {
    CopyFrom(from);
    return *this;
  }
  inline ERC20Event& operator=(ERC20Event&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ERC20Event& default_instance();

  enum ActionCase {
    kAssetList = 1001,
    kAssetDelist = 1002,
    kDeposit = 1003,
    kWithdrawal = 1004,
    ACTION_NOT_SET = 0,
  };

  static inline const ERC20Event* internal_default_instance() {
    return reinterpret_cast<const ERC20Event*>(
               &_ERC20Event_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ERC20Event& a, ERC20Event& b) {
    a.Swap(&b);
  }
  inline void Swap(ERC20Event* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ERC20Event* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ERC20Event* New() const final {
    return CreateMaybeMessage<ERC20Event>(nullptr);
  }

  ERC20Event* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ERC20Event>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ERC20Event& from);
  void MergeFrom(const ERC20Event& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ERC20Event* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vega.ERC20Event";
  }
  protected:
  explicit ERC20Event(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_chain_5fevents_2eproto);
    return ::descriptor_table_chain_5fevents_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIndexFieldNumber = 1,
    kBlockFieldNumber = 2,
    kAssetListFieldNumber = 1001,
    kAssetDelistFieldNumber = 1002,
    kDepositFieldNumber = 1003,
    kWithdrawalFieldNumber = 1004,
  };
  // uint64 index = 1 [json_name = "index"];
  void clear_index();
  ::PROTOBUF_NAMESPACE_ID::uint64 index() const;
  void set_index(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_index() const;
  void _internal_set_index(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 block = 2 [json_name = "block"];
  void clear_block();
  ::PROTOBUF_NAMESPACE_ID::uint64 block() const;
  void set_block(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_block() const;
  void _internal_set_block(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // .vega.ERC20AssetList assetList = 1001 [json_name = "assetList"];
  bool has_assetlist() const;
  private:
  bool _internal_has_assetlist() const;
  public:
  void clear_assetlist();
  const ::vega::ERC20AssetList& assetlist() const;
  ::vega::ERC20AssetList* release_assetlist();
  ::vega::ERC20AssetList* mutable_assetlist();
  void set_allocated_assetlist(::vega::ERC20AssetList* assetlist);
  private:
  const ::vega::ERC20AssetList& _internal_assetlist() const;
  ::vega::ERC20AssetList* _internal_mutable_assetlist();
  public:
  void unsafe_arena_set_allocated_assetlist(
      ::vega::ERC20AssetList* assetlist);
  ::vega::ERC20AssetList* unsafe_arena_release_assetlist();

  // .vega.ERC20AssetDelist assetDelist = 1002 [json_name = "assetDelist"];
  bool has_assetdelist() const;
  private:
  bool _internal_has_assetdelist() const;
  public:
  void clear_assetdelist();
  const ::vega::ERC20AssetDelist& assetdelist() const;
  ::vega::ERC20AssetDelist* release_assetdelist();
  ::vega::ERC20AssetDelist* mutable_assetdelist();
  void set_allocated_assetdelist(::vega::ERC20AssetDelist* assetdelist);
  private:
  const ::vega::ERC20AssetDelist& _internal_assetdelist() const;
  ::vega::ERC20AssetDelist* _internal_mutable_assetdelist();
  public:
  void unsafe_arena_set_allocated_assetdelist(
      ::vega::ERC20AssetDelist* assetdelist);
  ::vega::ERC20AssetDelist* unsafe_arena_release_assetdelist();

  // .vega.ERC20Deposit deposit = 1003 [json_name = "deposit"];
  bool has_deposit() const;
  private:
  bool _internal_has_deposit() const;
  public:
  void clear_deposit();
  const ::vega::ERC20Deposit& deposit() const;
  ::vega::ERC20Deposit* release_deposit();
  ::vega::ERC20Deposit* mutable_deposit();
  void set_allocated_deposit(::vega::ERC20Deposit* deposit);
  private:
  const ::vega::ERC20Deposit& _internal_deposit() const;
  ::vega::ERC20Deposit* _internal_mutable_deposit();
  public:
  void unsafe_arena_set_allocated_deposit(
      ::vega::ERC20Deposit* deposit);
  ::vega::ERC20Deposit* unsafe_arena_release_deposit();

  // .vega.ERC20Withdrawal withdrawal = 1004 [json_name = "withdrawal"];
  bool has_withdrawal() const;
  private:
  bool _internal_has_withdrawal() const;
  public:
  void clear_withdrawal();
  const ::vega::ERC20Withdrawal& withdrawal() const;
  ::vega::ERC20Withdrawal* release_withdrawal();
  ::vega::ERC20Withdrawal* mutable_withdrawal();
  void set_allocated_withdrawal(::vega::ERC20Withdrawal* withdrawal);
  private:
  const ::vega::ERC20Withdrawal& _internal_withdrawal() const;
  ::vega::ERC20Withdrawal* _internal_mutable_withdrawal();
  public:
  void unsafe_arena_set_allocated_withdrawal(
      ::vega::ERC20Withdrawal* withdrawal);
  ::vega::ERC20Withdrawal* unsafe_arena_release_withdrawal();

  void clear_action();
  ActionCase action_case() const;
  // @@protoc_insertion_point(class_scope:vega.ERC20Event)
 private:
  class _Internal;
  void set_has_assetlist();
  void set_has_assetdelist();
  void set_has_deposit();
  void set_has_withdrawal();

  inline bool has_action() const;
  inline void clear_has_action();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint64 index_;
  ::PROTOBUF_NAMESPACE_ID::uint64 block_;
  union ActionUnion {
    ActionUnion() {}
    ::vega::ERC20AssetList* assetlist_;
    ::vega::ERC20AssetDelist* assetdelist_;
    ::vega::ERC20Deposit* deposit_;
    ::vega::ERC20Withdrawal* withdrawal_;
  } action_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_chain_5fevents_2eproto;
};
// -------------------------------------------------------------------

class BTCDeposit PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vega.BTCDeposit) */ {
 public:
  inline BTCDeposit() : BTCDeposit(nullptr) {}
  virtual ~BTCDeposit();

  BTCDeposit(const BTCDeposit& from);
  BTCDeposit(BTCDeposit&& from) noexcept
    : BTCDeposit() {
    *this = ::std::move(from);
  }

  inline BTCDeposit& operator=(const BTCDeposit& from) {
    CopyFrom(from);
    return *this;
  }
  inline BTCDeposit& operator=(BTCDeposit&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BTCDeposit& default_instance();

  static inline const BTCDeposit* internal_default_instance() {
    return reinterpret_cast<const BTCDeposit*>(
               &_BTCDeposit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(BTCDeposit& a, BTCDeposit& b) {
    a.Swap(&b);
  }
  inline void Swap(BTCDeposit* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BTCDeposit* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BTCDeposit* New() const final {
    return CreateMaybeMessage<BTCDeposit>(nullptr);
  }

  BTCDeposit* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BTCDeposit>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BTCDeposit& from);
  void MergeFrom(const BTCDeposit& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BTCDeposit* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vega.BTCDeposit";
  }
  protected:
  explicit BTCDeposit(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_chain_5fevents_2eproto);
    return ::descriptor_table_chain_5fevents_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVegaAssetIDFieldNumber = 1,
    kSourceBTCAddressFieldNumber = 2,
    kTargetPartyIdFieldNumber = 3,
  };
  // string vegaAssetID = 1 [json_name = "vegaAssetID"];
  void clear_vegaassetid();
  const std::string& vegaassetid() const;
  void set_vegaassetid(const std::string& value);
  void set_vegaassetid(std::string&& value);
  void set_vegaassetid(const char* value);
  void set_vegaassetid(const char* value, size_t size);
  std::string* mutable_vegaassetid();
  std::string* release_vegaassetid();
  void set_allocated_vegaassetid(std::string* vegaassetid);
  private:
  const std::string& _internal_vegaassetid() const;
  void _internal_set_vegaassetid(const std::string& value);
  std::string* _internal_mutable_vegaassetid();
  public:

  // string sourceBTCAddress = 2 [json_name = "sourceBTCAddress"];
  void clear_sourcebtcaddress();
  const std::string& sourcebtcaddress() const;
  void set_sourcebtcaddress(const std::string& value);
  void set_sourcebtcaddress(std::string&& value);
  void set_sourcebtcaddress(const char* value);
  void set_sourcebtcaddress(const char* value, size_t size);
  std::string* mutable_sourcebtcaddress();
  std::string* release_sourcebtcaddress();
  void set_allocated_sourcebtcaddress(std::string* sourcebtcaddress);
  private:
  const std::string& _internal_sourcebtcaddress() const;
  void _internal_set_sourcebtcaddress(const std::string& value);
  std::string* _internal_mutable_sourcebtcaddress();
  public:

  // string targetPartyId = 3 [json_name = "targetPartyId"];
  void clear_targetpartyid();
  const std::string& targetpartyid() const;
  void set_targetpartyid(const std::string& value);
  void set_targetpartyid(std::string&& value);
  void set_targetpartyid(const char* value);
  void set_targetpartyid(const char* value, size_t size);
  std::string* mutable_targetpartyid();
  std::string* release_targetpartyid();
  void set_allocated_targetpartyid(std::string* targetpartyid);
  private:
  const std::string& _internal_targetpartyid() const;
  void _internal_set_targetpartyid(const std::string& value);
  std::string* _internal_mutable_targetpartyid();
  public:

  // @@protoc_insertion_point(class_scope:vega.BTCDeposit)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vegaassetid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sourcebtcaddress_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr targetpartyid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_chain_5fevents_2eproto;
};
// -------------------------------------------------------------------

class BTCWithdrawal PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vega.BTCWithdrawal) */ {
 public:
  inline BTCWithdrawal() : BTCWithdrawal(nullptr) {}
  virtual ~BTCWithdrawal();

  BTCWithdrawal(const BTCWithdrawal& from);
  BTCWithdrawal(BTCWithdrawal&& from) noexcept
    : BTCWithdrawal() {
    *this = ::std::move(from);
  }

  inline BTCWithdrawal& operator=(const BTCWithdrawal& from) {
    CopyFrom(from);
    return *this;
  }
  inline BTCWithdrawal& operator=(BTCWithdrawal&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BTCWithdrawal& default_instance();

  static inline const BTCWithdrawal* internal_default_instance() {
    return reinterpret_cast<const BTCWithdrawal*>(
               &_BTCWithdrawal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(BTCWithdrawal& a, BTCWithdrawal& b) {
    a.Swap(&b);
  }
  inline void Swap(BTCWithdrawal* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BTCWithdrawal* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BTCWithdrawal* New() const final {
    return CreateMaybeMessage<BTCWithdrawal>(nullptr);
  }

  BTCWithdrawal* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BTCWithdrawal>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BTCWithdrawal& from);
  void MergeFrom(const BTCWithdrawal& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BTCWithdrawal* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vega.BTCWithdrawal";
  }
  protected:
  explicit BTCWithdrawal(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_chain_5fevents_2eproto);
    return ::descriptor_table_chain_5fevents_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVegaAssetIDFieldNumber = 1,
    kSourcePartyIdFieldNumber = 2,
    kTargetBTCAddressFieldNumber = 3,
    kReferenceNonceFieldNumber = 4,
  };
  // string vegaAssetID = 1 [json_name = "vegaAssetID"];
  void clear_vegaassetid();
  const std::string& vegaassetid() const;
  void set_vegaassetid(const std::string& value);
  void set_vegaassetid(std::string&& value);
  void set_vegaassetid(const char* value);
  void set_vegaassetid(const char* value, size_t size);
  std::string* mutable_vegaassetid();
  std::string* release_vegaassetid();
  void set_allocated_vegaassetid(std::string* vegaassetid);
  private:
  const std::string& _internal_vegaassetid() const;
  void _internal_set_vegaassetid(const std::string& value);
  std::string* _internal_mutable_vegaassetid();
  public:

  // string sourcePartyId = 2 [json_name = "sourcePartyId"];
  void clear_sourcepartyid();
  const std::string& sourcepartyid() const;
  void set_sourcepartyid(const std::string& value);
  void set_sourcepartyid(std::string&& value);
  void set_sourcepartyid(const char* value);
  void set_sourcepartyid(const char* value, size_t size);
  std::string* mutable_sourcepartyid();
  std::string* release_sourcepartyid();
  void set_allocated_sourcepartyid(std::string* sourcepartyid);
  private:
  const std::string& _internal_sourcepartyid() const;
  void _internal_set_sourcepartyid(const std::string& value);
  std::string* _internal_mutable_sourcepartyid();
  public:

  // string targetBTCAddress = 3 [json_name = "targetBTCAddress"];
  void clear_targetbtcaddress();
  const std::string& targetbtcaddress() const;
  void set_targetbtcaddress(const std::string& value);
  void set_targetbtcaddress(std::string&& value);
  void set_targetbtcaddress(const char* value);
  void set_targetbtcaddress(const char* value, size_t size);
  std::string* mutable_targetbtcaddress();
  std::string* release_targetbtcaddress();
  void set_allocated_targetbtcaddress(std::string* targetbtcaddress);
  private:
  const std::string& _internal_targetbtcaddress() const;
  void _internal_set_targetbtcaddress(const std::string& value);
  std::string* _internal_mutable_targetbtcaddress();
  public:

  // string referenceNonce = 4 [json_name = "referenceNonce"];
  void clear_referencenonce();
  const std::string& referencenonce() const;
  void set_referencenonce(const std::string& value);
  void set_referencenonce(std::string&& value);
  void set_referencenonce(const char* value);
  void set_referencenonce(const char* value, size_t size);
  std::string* mutable_referencenonce();
  std::string* release_referencenonce();
  void set_allocated_referencenonce(std::string* referencenonce);
  private:
  const std::string& _internal_referencenonce() const;
  void _internal_set_referencenonce(const std::string& value);
  std::string* _internal_mutable_referencenonce();
  public:

  // @@protoc_insertion_point(class_scope:vega.BTCWithdrawal)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vegaassetid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sourcepartyid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr targetbtcaddress_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr referencenonce_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_chain_5fevents_2eproto;
};
// -------------------------------------------------------------------

class BTCEvent PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vega.BTCEvent) */ {
 public:
  inline BTCEvent() : BTCEvent(nullptr) {}
  virtual ~BTCEvent();

  BTCEvent(const BTCEvent& from);
  BTCEvent(BTCEvent&& from) noexcept
    : BTCEvent() {
    *this = ::std::move(from);
  }

  inline BTCEvent& operator=(const BTCEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline BTCEvent& operator=(BTCEvent&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BTCEvent& default_instance();

  enum ActionCase {
    kDeposit = 1001,
    kWithdrawal = 1002,
    ACTION_NOT_SET = 0,
  };

  static inline const BTCEvent* internal_default_instance() {
    return reinterpret_cast<const BTCEvent*>(
               &_BTCEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(BTCEvent& a, BTCEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(BTCEvent* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BTCEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BTCEvent* New() const final {
    return CreateMaybeMessage<BTCEvent>(nullptr);
  }

  BTCEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BTCEvent>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BTCEvent& from);
  void MergeFrom(const BTCEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BTCEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vega.BTCEvent";
  }
  protected:
  explicit BTCEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_chain_5fevents_2eproto);
    return ::descriptor_table_chain_5fevents_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIndexFieldNumber = 1,
    kBlockFieldNumber = 2,
    kDepositFieldNumber = 1001,
    kWithdrawalFieldNumber = 1002,
  };
  // uint64 index = 1 [json_name = "index"];
  void clear_index();
  ::PROTOBUF_NAMESPACE_ID::uint64 index() const;
  void set_index(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_index() const;
  void _internal_set_index(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 block = 2 [json_name = "block"];
  void clear_block();
  ::PROTOBUF_NAMESPACE_ID::uint64 block() const;
  void set_block(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_block() const;
  void _internal_set_block(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // .vega.BTCDeposit deposit = 1001 [json_name = "deposit"];
  bool has_deposit() const;
  private:
  bool _internal_has_deposit() const;
  public:
  void clear_deposit();
  const ::vega::BTCDeposit& deposit() const;
  ::vega::BTCDeposit* release_deposit();
  ::vega::BTCDeposit* mutable_deposit();
  void set_allocated_deposit(::vega::BTCDeposit* deposit);
  private:
  const ::vega::BTCDeposit& _internal_deposit() const;
  ::vega::BTCDeposit* _internal_mutable_deposit();
  public:
  void unsafe_arena_set_allocated_deposit(
      ::vega::BTCDeposit* deposit);
  ::vega::BTCDeposit* unsafe_arena_release_deposit();

  // .vega.BTCWithdrawal withdrawal = 1002 [json_name = "withdrawal"];
  bool has_withdrawal() const;
  private:
  bool _internal_has_withdrawal() const;
  public:
  void clear_withdrawal();
  const ::vega::BTCWithdrawal& withdrawal() const;
  ::vega::BTCWithdrawal* release_withdrawal();
  ::vega::BTCWithdrawal* mutable_withdrawal();
  void set_allocated_withdrawal(::vega::BTCWithdrawal* withdrawal);
  private:
  const ::vega::BTCWithdrawal& _internal_withdrawal() const;
  ::vega::BTCWithdrawal* _internal_mutable_withdrawal();
  public:
  void unsafe_arena_set_allocated_withdrawal(
      ::vega::BTCWithdrawal* withdrawal);
  ::vega::BTCWithdrawal* unsafe_arena_release_withdrawal();

  void clear_action();
  ActionCase action_case() const;
  // @@protoc_insertion_point(class_scope:vega.BTCEvent)
 private:
  class _Internal;
  void set_has_deposit();
  void set_has_withdrawal();

  inline bool has_action() const;
  inline void clear_has_action();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint64 index_;
  ::PROTOBUF_NAMESPACE_ID::uint64 block_;
  union ActionUnion {
    ActionUnion() {}
    ::vega::BTCDeposit* deposit_;
    ::vega::BTCWithdrawal* withdrawal_;
  } action_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_chain_5fevents_2eproto;
};
// -------------------------------------------------------------------

class EthereumAddress PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vega.EthereumAddress) */ {
 public:
  inline EthereumAddress() : EthereumAddress(nullptr) {}
  virtual ~EthereumAddress();

  EthereumAddress(const EthereumAddress& from);
  EthereumAddress(EthereumAddress&& from) noexcept
    : EthereumAddress() {
    *this = ::std::move(from);
  }

  inline EthereumAddress& operator=(const EthereumAddress& from) {
    CopyFrom(from);
    return *this;
  }
  inline EthereumAddress& operator=(EthereumAddress&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const EthereumAddress& default_instance();

  static inline const EthereumAddress* internal_default_instance() {
    return reinterpret_cast<const EthereumAddress*>(
               &_EthereumAddress_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(EthereumAddress& a, EthereumAddress& b) {
    a.Swap(&b);
  }
  inline void Swap(EthereumAddress* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EthereumAddress* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EthereumAddress* New() const final {
    return CreateMaybeMessage<EthereumAddress>(nullptr);
  }

  EthereumAddress* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EthereumAddress>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const EthereumAddress& from);
  void MergeFrom(const EthereumAddress& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EthereumAddress* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vega.EthereumAddress";
  }
  protected:
  explicit EthereumAddress(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_chain_5fevents_2eproto);
    return ::descriptor_table_chain_5fevents_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddressFieldNumber = 1,
  };
  // string address = 1 [json_name = "address"];
  void clear_address();
  const std::string& address() const;
  void set_address(const std::string& value);
  void set_address(std::string&& value);
  void set_address(const char* value);
  void set_address(const char* value, size_t size);
  std::string* mutable_address();
  std::string* release_address();
  void set_allocated_address(std::string* address);
  private:
  const std::string& _internal_address() const;
  void _internal_set_address(const std::string& value);
  std::string* _internal_mutable_address();
  public:

  // @@protoc_insertion_point(class_scope:vega.EthereumAddress)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_chain_5fevents_2eproto;
};
// -------------------------------------------------------------------

class BitcoinAddress PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vega.BitcoinAddress) */ {
 public:
  inline BitcoinAddress() : BitcoinAddress(nullptr) {}
  virtual ~BitcoinAddress();

  BitcoinAddress(const BitcoinAddress& from);
  BitcoinAddress(BitcoinAddress&& from) noexcept
    : BitcoinAddress() {
    *this = ::std::move(from);
  }

  inline BitcoinAddress& operator=(const BitcoinAddress& from) {
    CopyFrom(from);
    return *this;
  }
  inline BitcoinAddress& operator=(BitcoinAddress&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BitcoinAddress& default_instance();

  static inline const BitcoinAddress* internal_default_instance() {
    return reinterpret_cast<const BitcoinAddress*>(
               &_BitcoinAddress_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(BitcoinAddress& a, BitcoinAddress& b) {
    a.Swap(&b);
  }
  inline void Swap(BitcoinAddress* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BitcoinAddress* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BitcoinAddress* New() const final {
    return CreateMaybeMessage<BitcoinAddress>(nullptr);
  }

  BitcoinAddress* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BitcoinAddress>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BitcoinAddress& from);
  void MergeFrom(const BitcoinAddress& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BitcoinAddress* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vega.BitcoinAddress";
  }
  protected:
  explicit BitcoinAddress(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_chain_5fevents_2eproto);
    return ::descriptor_table_chain_5fevents_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddressFieldNumber = 1,
  };
  // string address = 1 [json_name = "address"];
  void clear_address();
  const std::string& address() const;
  void set_address(const std::string& value);
  void set_address(std::string&& value);
  void set_address(const char* value);
  void set_address(const char* value, size_t size);
  std::string* mutable_address();
  std::string* release_address();
  void set_allocated_address(std::string* address);
  private:
  const std::string& _internal_address() const;
  void _internal_set_address(const std::string& value);
  std::string* _internal_mutable_address();
  public:

  // @@protoc_insertion_point(class_scope:vega.BitcoinAddress)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_chain_5fevents_2eproto;
};
// -------------------------------------------------------------------

class Identifier PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vega.Identifier) */ {
 public:
  inline Identifier() : Identifier(nullptr) {}
  virtual ~Identifier();

  Identifier(const Identifier& from);
  Identifier(Identifier&& from) noexcept
    : Identifier() {
    *this = ::std::move(from);
  }

  inline Identifier& operator=(const Identifier& from) {
    CopyFrom(from);
    return *this;
  }
  inline Identifier& operator=(Identifier&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Identifier& default_instance();

  enum IdentifierCase {
    kEthereumAddress = 1,
    kBitcoinAddress = 2,
    IDENTIFIER_NOT_SET = 0,
  };

  static inline const Identifier* internal_default_instance() {
    return reinterpret_cast<const Identifier*>(
               &_Identifier_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(Identifier& a, Identifier& b) {
    a.Swap(&b);
  }
  inline void Swap(Identifier* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Identifier* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Identifier* New() const final {
    return CreateMaybeMessage<Identifier>(nullptr);
  }

  Identifier* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Identifier>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Identifier& from);
  void MergeFrom(const Identifier& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Identifier* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vega.Identifier";
  }
  protected:
  explicit Identifier(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_chain_5fevents_2eproto);
    return ::descriptor_table_chain_5fevents_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEthereumAddressFieldNumber = 1,
    kBitcoinAddressFieldNumber = 2,
  };
  // .vega.EthereumAddress ethereumAddress = 1 [json_name = "ethereumAddress"];
  bool has_ethereumaddress() const;
  private:
  bool _internal_has_ethereumaddress() const;
  public:
  void clear_ethereumaddress();
  const ::vega::EthereumAddress& ethereumaddress() const;
  ::vega::EthereumAddress* release_ethereumaddress();
  ::vega::EthereumAddress* mutable_ethereumaddress();
  void set_allocated_ethereumaddress(::vega::EthereumAddress* ethereumaddress);
  private:
  const ::vega::EthereumAddress& _internal_ethereumaddress() const;
  ::vega::EthereumAddress* _internal_mutable_ethereumaddress();
  public:
  void unsafe_arena_set_allocated_ethereumaddress(
      ::vega::EthereumAddress* ethereumaddress);
  ::vega::EthereumAddress* unsafe_arena_release_ethereumaddress();

  // .vega.BitcoinAddress bitcoinAddress = 2 [json_name = "bitcoinAddress"];
  bool has_bitcoinaddress() const;
  private:
  bool _internal_has_bitcoinaddress() const;
  public:
  void clear_bitcoinaddress();
  const ::vega::BitcoinAddress& bitcoinaddress() const;
  ::vega::BitcoinAddress* release_bitcoinaddress();
  ::vega::BitcoinAddress* mutable_bitcoinaddress();
  void set_allocated_bitcoinaddress(::vega::BitcoinAddress* bitcoinaddress);
  private:
  const ::vega::BitcoinAddress& _internal_bitcoinaddress() const;
  ::vega::BitcoinAddress* _internal_mutable_bitcoinaddress();
  public:
  void unsafe_arena_set_allocated_bitcoinaddress(
      ::vega::BitcoinAddress* bitcoinaddress);
  ::vega::BitcoinAddress* unsafe_arena_release_bitcoinaddress();

  void clear_identifier();
  IdentifierCase identifier_case() const;
  // @@protoc_insertion_point(class_scope:vega.Identifier)
 private:
  class _Internal;
  void set_has_ethereumaddress();
  void set_has_bitcoinaddress();

  inline bool has_identifier() const;
  inline void clear_has_identifier();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union IdentifierUnion {
    IdentifierUnion() {}
    ::vega::EthereumAddress* ethereumaddress_;
    ::vega::BitcoinAddress* bitcoinaddress_;
  } identifier_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_chain_5fevents_2eproto;
};
// -------------------------------------------------------------------

class AddValidator PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vega.AddValidator) */ {
 public:
  inline AddValidator() : AddValidator(nullptr) {}
  virtual ~AddValidator();

  AddValidator(const AddValidator& from);
  AddValidator(AddValidator&& from) noexcept
    : AddValidator() {
    *this = ::std::move(from);
  }

  inline AddValidator& operator=(const AddValidator& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddValidator& operator=(AddValidator&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AddValidator& default_instance();

  static inline const AddValidator* internal_default_instance() {
    return reinterpret_cast<const AddValidator*>(
               &_AddValidator_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(AddValidator& a, AddValidator& b) {
    a.Swap(&b);
  }
  inline void Swap(AddValidator* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddValidator* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AddValidator* New() const final {
    return CreateMaybeMessage<AddValidator>(nullptr);
  }

  AddValidator* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AddValidator>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AddValidator& from);
  void MergeFrom(const AddValidator& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddValidator* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vega.AddValidator";
  }
  protected:
  explicit AddValidator(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_chain_5fevents_2eproto);
    return ::descriptor_table_chain_5fevents_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // .vega.Identifier id = 1 [json_name = "id"];
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const ::vega::Identifier& id() const;
  ::vega::Identifier* release_id();
  ::vega::Identifier* mutable_id();
  void set_allocated_id(::vega::Identifier* id);
  private:
  const ::vega::Identifier& _internal_id() const;
  ::vega::Identifier* _internal_mutable_id();
  public:
  void unsafe_arena_set_allocated_id(
      ::vega::Identifier* id);
  ::vega::Identifier* unsafe_arena_release_id();

  // @@protoc_insertion_point(class_scope:vega.AddValidator)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::vega::Identifier* id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_chain_5fevents_2eproto;
};
// -------------------------------------------------------------------

class RemoveValidator PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vega.RemoveValidator) */ {
 public:
  inline RemoveValidator() : RemoveValidator(nullptr) {}
  virtual ~RemoveValidator();

  RemoveValidator(const RemoveValidator& from);
  RemoveValidator(RemoveValidator&& from) noexcept
    : RemoveValidator() {
    *this = ::std::move(from);
  }

  inline RemoveValidator& operator=(const RemoveValidator& from) {
    CopyFrom(from);
    return *this;
  }
  inline RemoveValidator& operator=(RemoveValidator&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RemoveValidator& default_instance();

  static inline const RemoveValidator* internal_default_instance() {
    return reinterpret_cast<const RemoveValidator*>(
               &_RemoveValidator_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(RemoveValidator& a, RemoveValidator& b) {
    a.Swap(&b);
  }
  inline void Swap(RemoveValidator* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RemoveValidator* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RemoveValidator* New() const final {
    return CreateMaybeMessage<RemoveValidator>(nullptr);
  }

  RemoveValidator* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RemoveValidator>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RemoveValidator& from);
  void MergeFrom(const RemoveValidator& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RemoveValidator* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vega.RemoveValidator";
  }
  protected:
  explicit RemoveValidator(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_chain_5fevents_2eproto);
    return ::descriptor_table_chain_5fevents_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // .vega.Identifier id = 1 [json_name = "id"];
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const ::vega::Identifier& id() const;
  ::vega::Identifier* release_id();
  ::vega::Identifier* mutable_id();
  void set_allocated_id(::vega::Identifier* id);
  private:
  const ::vega::Identifier& _internal_id() const;
  ::vega::Identifier* _internal_mutable_id();
  public:
  void unsafe_arena_set_allocated_id(
      ::vega::Identifier* id);
  ::vega::Identifier* unsafe_arena_release_id();

  // @@protoc_insertion_point(class_scope:vega.RemoveValidator)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::vega::Identifier* id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_chain_5fevents_2eproto;
};
// -------------------------------------------------------------------

class ValidatorEvent PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vega.ValidatorEvent) */ {
 public:
  inline ValidatorEvent() : ValidatorEvent(nullptr) {}
  virtual ~ValidatorEvent();

  ValidatorEvent(const ValidatorEvent& from);
  ValidatorEvent(ValidatorEvent&& from) noexcept
    : ValidatorEvent() {
    *this = ::std::move(from);
  }

  inline ValidatorEvent& operator=(const ValidatorEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline ValidatorEvent& operator=(ValidatorEvent&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ValidatorEvent& default_instance();

  enum ActionCase {
    kAdd = 1001,
    kRm = 1002,
    ACTION_NOT_SET = 0,
  };

  static inline const ValidatorEvent* internal_default_instance() {
    return reinterpret_cast<const ValidatorEvent*>(
               &_ValidatorEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(ValidatorEvent& a, ValidatorEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(ValidatorEvent* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ValidatorEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ValidatorEvent* New() const final {
    return CreateMaybeMessage<ValidatorEvent>(nullptr);
  }

  ValidatorEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ValidatorEvent>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ValidatorEvent& from);
  void MergeFrom(const ValidatorEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ValidatorEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vega.ValidatorEvent";
  }
  protected:
  explicit ValidatorEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_chain_5fevents_2eproto);
    return ::descriptor_table_chain_5fevents_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSourceIDFieldNumber = 1,
    kAddFieldNumber = 1001,
    kRmFieldNumber = 1002,
  };
  // string sourceID = 1 [json_name = "sourceID"];
  void clear_sourceid();
  const std::string& sourceid() const;
  void set_sourceid(const std::string& value);
  void set_sourceid(std::string&& value);
  void set_sourceid(const char* value);
  void set_sourceid(const char* value, size_t size);
  std::string* mutable_sourceid();
  std::string* release_sourceid();
  void set_allocated_sourceid(std::string* sourceid);
  private:
  const std::string& _internal_sourceid() const;
  void _internal_set_sourceid(const std::string& value);
  std::string* _internal_mutable_sourceid();
  public:

  // .vega.AddValidator add = 1001 [json_name = "add"];
  bool has_add() const;
  private:
  bool _internal_has_add() const;
  public:
  void clear_add();
  const ::vega::AddValidator& add() const;
  ::vega::AddValidator* release_add();
  ::vega::AddValidator* mutable_add();
  void set_allocated_add(::vega::AddValidator* add);
  private:
  const ::vega::AddValidator& _internal_add() const;
  ::vega::AddValidator* _internal_mutable_add();
  public:
  void unsafe_arena_set_allocated_add(
      ::vega::AddValidator* add);
  ::vega::AddValidator* unsafe_arena_release_add();

  // .vega.RemoveValidator rm = 1002 [json_name = "rm"];
  bool has_rm() const;
  private:
  bool _internal_has_rm() const;
  public:
  void clear_rm();
  const ::vega::RemoveValidator& rm() const;
  ::vega::RemoveValidator* release_rm();
  ::vega::RemoveValidator* mutable_rm();
  void set_allocated_rm(::vega::RemoveValidator* rm);
  private:
  const ::vega::RemoveValidator& _internal_rm() const;
  ::vega::RemoveValidator* _internal_mutable_rm();
  public:
  void unsafe_arena_set_allocated_rm(
      ::vega::RemoveValidator* rm);
  ::vega::RemoveValidator* unsafe_arena_release_rm();

  void clear_action();
  ActionCase action_case() const;
  // @@protoc_insertion_point(class_scope:vega.ValidatorEvent)
 private:
  class _Internal;
  void set_has_add();
  void set_has_rm();

  inline bool has_action() const;
  inline void clear_has_action();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sourceid_;
  union ActionUnion {
    ActionUnion() {}
    ::vega::AddValidator* add_;
    ::vega::RemoveValidator* rm_;
  } action_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_chain_5fevents_2eproto;
};
// -------------------------------------------------------------------

class ChainEvent PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vega.ChainEvent) */ {
 public:
  inline ChainEvent() : ChainEvent(nullptr) {}
  virtual ~ChainEvent();

  ChainEvent(const ChainEvent& from);
  ChainEvent(ChainEvent&& from) noexcept
    : ChainEvent() {
    *this = ::std::move(from);
  }

  inline ChainEvent& operator=(const ChainEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChainEvent& operator=(ChainEvent&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ChainEvent& default_instance();

  enum EventCase {
    kBuiltin = 1001,
    kErc20 = 1002,
    kBtc = 1003,
    kValidator = 1004,
    EVENT_NOT_SET = 0,
  };

  static inline const ChainEvent* internal_default_instance() {
    return reinterpret_cast<const ChainEvent*>(
               &_ChainEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(ChainEvent& a, ChainEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(ChainEvent* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChainEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ChainEvent* New() const final {
    return CreateMaybeMessage<ChainEvent>(nullptr);
  }

  ChainEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ChainEvent>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ChainEvent& from);
  void MergeFrom(const ChainEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChainEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vega.ChainEvent";
  }
  protected:
  explicit ChainEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_chain_5fevents_2eproto);
    return ::descriptor_table_chain_5fevents_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTxIDFieldNumber = 1,
    kNonceFieldNumber = 2,
    kBuiltinFieldNumber = 1001,
    kErc20FieldNumber = 1002,
    kBtcFieldNumber = 1003,
    kValidatorFieldNumber = 1004,
  };
  // string txID = 1 [json_name = "txID"];
  void clear_txid();
  const std::string& txid() const;
  void set_txid(const std::string& value);
  void set_txid(std::string&& value);
  void set_txid(const char* value);
  void set_txid(const char* value, size_t size);
  std::string* mutable_txid();
  std::string* release_txid();
  void set_allocated_txid(std::string* txid);
  private:
  const std::string& _internal_txid() const;
  void _internal_set_txid(const std::string& value);
  std::string* _internal_mutable_txid();
  public:

  // uint64 nonce = 2 [json_name = "nonce"];
  void clear_nonce();
  ::PROTOBUF_NAMESPACE_ID::uint64 nonce() const;
  void set_nonce(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_nonce() const;
  void _internal_set_nonce(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // .vega.BuiltinAssetEvent builtin = 1001 [json_name = "builtin"];
  bool has_builtin() const;
  private:
  bool _internal_has_builtin() const;
  public:
  void clear_builtin();
  const ::vega::BuiltinAssetEvent& builtin() const;
  ::vega::BuiltinAssetEvent* release_builtin();
  ::vega::BuiltinAssetEvent* mutable_builtin();
  void set_allocated_builtin(::vega::BuiltinAssetEvent* builtin);
  private:
  const ::vega::BuiltinAssetEvent& _internal_builtin() const;
  ::vega::BuiltinAssetEvent* _internal_mutable_builtin();
  public:
  void unsafe_arena_set_allocated_builtin(
      ::vega::BuiltinAssetEvent* builtin);
  ::vega::BuiltinAssetEvent* unsafe_arena_release_builtin();

  // .vega.ERC20Event erc20 = 1002 [json_name = "erc20"];
  bool has_erc20() const;
  private:
  bool _internal_has_erc20() const;
  public:
  void clear_erc20();
  const ::vega::ERC20Event& erc20() const;
  ::vega::ERC20Event* release_erc20();
  ::vega::ERC20Event* mutable_erc20();
  void set_allocated_erc20(::vega::ERC20Event* erc20);
  private:
  const ::vega::ERC20Event& _internal_erc20() const;
  ::vega::ERC20Event* _internal_mutable_erc20();
  public:
  void unsafe_arena_set_allocated_erc20(
      ::vega::ERC20Event* erc20);
  ::vega::ERC20Event* unsafe_arena_release_erc20();

  // .vega.BTCEvent btc = 1003 [json_name = "btc"];
  bool has_btc() const;
  private:
  bool _internal_has_btc() const;
  public:
  void clear_btc();
  const ::vega::BTCEvent& btc() const;
  ::vega::BTCEvent* release_btc();
  ::vega::BTCEvent* mutable_btc();
  void set_allocated_btc(::vega::BTCEvent* btc);
  private:
  const ::vega::BTCEvent& _internal_btc() const;
  ::vega::BTCEvent* _internal_mutable_btc();
  public:
  void unsafe_arena_set_allocated_btc(
      ::vega::BTCEvent* btc);
  ::vega::BTCEvent* unsafe_arena_release_btc();

  // .vega.ValidatorEvent validator = 1004 [json_name = "validator"];
  bool has_validator() const;
  private:
  bool _internal_has_validator() const;
  public:
  void clear_validator();
  const ::vega::ValidatorEvent& validator() const;
  ::vega::ValidatorEvent* release_validator();
  ::vega::ValidatorEvent* mutable_validator();
  void set_allocated_validator(::vega::ValidatorEvent* validator);
  private:
  const ::vega::ValidatorEvent& _internal_validator() const;
  ::vega::ValidatorEvent* _internal_mutable_validator();
  public:
  void unsafe_arena_set_allocated_validator(
      ::vega::ValidatorEvent* validator);
  ::vega::ValidatorEvent* unsafe_arena_release_validator();

  void clear_event();
  EventCase event_case() const;
  // @@protoc_insertion_point(class_scope:vega.ChainEvent)
 private:
  class _Internal;
  void set_has_builtin();
  void set_has_erc20();
  void set_has_btc();
  void set_has_validator();

  inline bool has_event() const;
  inline void clear_has_event();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr txid_;
  ::PROTOBUF_NAMESPACE_ID::uint64 nonce_;
  union EventUnion {
    EventUnion() {}
    ::vega::BuiltinAssetEvent* builtin_;
    ::vega::ERC20Event* erc20_;
    ::vega::BTCEvent* btc_;
    ::vega::ValidatorEvent* validator_;
  } event_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_chain_5fevents_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// BuiltinAssetDeposit

// string vegaAssetID = 1 [json_name = "vegaAssetID"];
inline void BuiltinAssetDeposit::clear_vegaassetid() {
  vegaassetid_.ClearToEmpty();
}
inline const std::string& BuiltinAssetDeposit::vegaassetid() const {
  // @@protoc_insertion_point(field_get:vega.BuiltinAssetDeposit.vegaAssetID)
  return _internal_vegaassetid();
}
inline void BuiltinAssetDeposit::set_vegaassetid(const std::string& value) {
  _internal_set_vegaassetid(value);
  // @@protoc_insertion_point(field_set:vega.BuiltinAssetDeposit.vegaAssetID)
}
inline std::string* BuiltinAssetDeposit::mutable_vegaassetid() {
  // @@protoc_insertion_point(field_mutable:vega.BuiltinAssetDeposit.vegaAssetID)
  return _internal_mutable_vegaassetid();
}
inline const std::string& BuiltinAssetDeposit::_internal_vegaassetid() const {
  return vegaassetid_.Get();
}
inline void BuiltinAssetDeposit::_internal_set_vegaassetid(const std::string& value) {

  vegaassetid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void BuiltinAssetDeposit::set_vegaassetid(std::string&& value) {

  vegaassetid_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vega.BuiltinAssetDeposit.vegaAssetID)
}
inline void BuiltinAssetDeposit::set_vegaassetid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  vegaassetid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:vega.BuiltinAssetDeposit.vegaAssetID)
}
inline void BuiltinAssetDeposit::set_vegaassetid(const char* value,
    size_t size) {

  vegaassetid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vega.BuiltinAssetDeposit.vegaAssetID)
}
inline std::string* BuiltinAssetDeposit::_internal_mutable_vegaassetid() {

  return vegaassetid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* BuiltinAssetDeposit::release_vegaassetid() {
  // @@protoc_insertion_point(field_release:vega.BuiltinAssetDeposit.vegaAssetID)
  return vegaassetid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void BuiltinAssetDeposit::set_allocated_vegaassetid(std::string* vegaassetid) {
  if (vegaassetid != nullptr) {

  } else {

  }
  vegaassetid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), vegaassetid,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vega.BuiltinAssetDeposit.vegaAssetID)
}

// string partyID = 2 [json_name = "partyID"];
inline void BuiltinAssetDeposit::clear_partyid() {
  partyid_.ClearToEmpty();
}
inline const std::string& BuiltinAssetDeposit::partyid() const {
  // @@protoc_insertion_point(field_get:vega.BuiltinAssetDeposit.partyID)
  return _internal_partyid();
}
inline void BuiltinAssetDeposit::set_partyid(const std::string& value) {
  _internal_set_partyid(value);
  // @@protoc_insertion_point(field_set:vega.BuiltinAssetDeposit.partyID)
}
inline std::string* BuiltinAssetDeposit::mutable_partyid() {
  // @@protoc_insertion_point(field_mutable:vega.BuiltinAssetDeposit.partyID)
  return _internal_mutable_partyid();
}
inline const std::string& BuiltinAssetDeposit::_internal_partyid() const {
  return partyid_.Get();
}
inline void BuiltinAssetDeposit::_internal_set_partyid(const std::string& value) {

  partyid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void BuiltinAssetDeposit::set_partyid(std::string&& value) {

  partyid_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vega.BuiltinAssetDeposit.partyID)
}
inline void BuiltinAssetDeposit::set_partyid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  partyid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:vega.BuiltinAssetDeposit.partyID)
}
inline void BuiltinAssetDeposit::set_partyid(const char* value,
    size_t size) {

  partyid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vega.BuiltinAssetDeposit.partyID)
}
inline std::string* BuiltinAssetDeposit::_internal_mutable_partyid() {

  return partyid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* BuiltinAssetDeposit::release_partyid() {
  // @@protoc_insertion_point(field_release:vega.BuiltinAssetDeposit.partyID)
  return partyid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void BuiltinAssetDeposit::set_allocated_partyid(std::string* partyid) {
  if (partyid != nullptr) {

  } else {

  }
  partyid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), partyid,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vega.BuiltinAssetDeposit.partyID)
}

// uint64 amount = 3 [json_name = "amount"];
inline void BuiltinAssetDeposit::clear_amount() {
  amount_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 BuiltinAssetDeposit::_internal_amount() const {
  return amount_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 BuiltinAssetDeposit::amount() const {
  // @@protoc_insertion_point(field_get:vega.BuiltinAssetDeposit.amount)
  return _internal_amount();
}
inline void BuiltinAssetDeposit::_internal_set_amount(::PROTOBUF_NAMESPACE_ID::uint64 value) {

  amount_ = value;
}
inline void BuiltinAssetDeposit::set_amount(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_amount(value);
  // @@protoc_insertion_point(field_set:vega.BuiltinAssetDeposit.amount)
}

// -------------------------------------------------------------------

// BuiltinAssetWithdrawal

// string vegaAssetID = 1 [json_name = "vegaAssetID"];
inline void BuiltinAssetWithdrawal::clear_vegaassetid() {
  vegaassetid_.ClearToEmpty();
}
inline const std::string& BuiltinAssetWithdrawal::vegaassetid() const {
  // @@protoc_insertion_point(field_get:vega.BuiltinAssetWithdrawal.vegaAssetID)
  return _internal_vegaassetid();
}
inline void BuiltinAssetWithdrawal::set_vegaassetid(const std::string& value) {
  _internal_set_vegaassetid(value);
  // @@protoc_insertion_point(field_set:vega.BuiltinAssetWithdrawal.vegaAssetID)
}
inline std::string* BuiltinAssetWithdrawal::mutable_vegaassetid() {
  // @@protoc_insertion_point(field_mutable:vega.BuiltinAssetWithdrawal.vegaAssetID)
  return _internal_mutable_vegaassetid();
}
inline const std::string& BuiltinAssetWithdrawal::_internal_vegaassetid() const {
  return vegaassetid_.Get();
}
inline void BuiltinAssetWithdrawal::_internal_set_vegaassetid(const std::string& value) {

  vegaassetid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void BuiltinAssetWithdrawal::set_vegaassetid(std::string&& value) {

  vegaassetid_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vega.BuiltinAssetWithdrawal.vegaAssetID)
}
inline void BuiltinAssetWithdrawal::set_vegaassetid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  vegaassetid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:vega.BuiltinAssetWithdrawal.vegaAssetID)
}
inline void BuiltinAssetWithdrawal::set_vegaassetid(const char* value,
    size_t size) {

  vegaassetid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vega.BuiltinAssetWithdrawal.vegaAssetID)
}
inline std::string* BuiltinAssetWithdrawal::_internal_mutable_vegaassetid() {

  return vegaassetid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* BuiltinAssetWithdrawal::release_vegaassetid() {
  // @@protoc_insertion_point(field_release:vega.BuiltinAssetWithdrawal.vegaAssetID)
  return vegaassetid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void BuiltinAssetWithdrawal::set_allocated_vegaassetid(std::string* vegaassetid) {
  if (vegaassetid != nullptr) {

  } else {

  }
  vegaassetid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), vegaassetid,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vega.BuiltinAssetWithdrawal.vegaAssetID)
}

// string partyID = 2 [json_name = "partyID"];
inline void BuiltinAssetWithdrawal::clear_partyid() {
  partyid_.ClearToEmpty();
}
inline const std::string& BuiltinAssetWithdrawal::partyid() const {
  // @@protoc_insertion_point(field_get:vega.BuiltinAssetWithdrawal.partyID)
  return _internal_partyid();
}
inline void BuiltinAssetWithdrawal::set_partyid(const std::string& value) {
  _internal_set_partyid(value);
  // @@protoc_insertion_point(field_set:vega.BuiltinAssetWithdrawal.partyID)
}
inline std::string* BuiltinAssetWithdrawal::mutable_partyid() {
  // @@protoc_insertion_point(field_mutable:vega.BuiltinAssetWithdrawal.partyID)
  return _internal_mutable_partyid();
}
inline const std::string& BuiltinAssetWithdrawal::_internal_partyid() const {
  return partyid_.Get();
}
inline void BuiltinAssetWithdrawal::_internal_set_partyid(const std::string& value) {

  partyid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void BuiltinAssetWithdrawal::set_partyid(std::string&& value) {

  partyid_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vega.BuiltinAssetWithdrawal.partyID)
}
inline void BuiltinAssetWithdrawal::set_partyid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  partyid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:vega.BuiltinAssetWithdrawal.partyID)
}
inline void BuiltinAssetWithdrawal::set_partyid(const char* value,
    size_t size) {

  partyid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vega.BuiltinAssetWithdrawal.partyID)
}
inline std::string* BuiltinAssetWithdrawal::_internal_mutable_partyid() {

  return partyid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* BuiltinAssetWithdrawal::release_partyid() {
  // @@protoc_insertion_point(field_release:vega.BuiltinAssetWithdrawal.partyID)
  return partyid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void BuiltinAssetWithdrawal::set_allocated_partyid(std::string* partyid) {
  if (partyid != nullptr) {

  } else {

  }
  partyid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), partyid,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vega.BuiltinAssetWithdrawal.partyID)
}

// uint64 amount = 3 [json_name = "amount"];
inline void BuiltinAssetWithdrawal::clear_amount() {
  amount_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 BuiltinAssetWithdrawal::_internal_amount() const {
  return amount_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 BuiltinAssetWithdrawal::amount() const {
  // @@protoc_insertion_point(field_get:vega.BuiltinAssetWithdrawal.amount)
  return _internal_amount();
}
inline void BuiltinAssetWithdrawal::_internal_set_amount(::PROTOBUF_NAMESPACE_ID::uint64 value) {

  amount_ = value;
}
inline void BuiltinAssetWithdrawal::set_amount(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_amount(value);
  // @@protoc_insertion_point(field_set:vega.BuiltinAssetWithdrawal.amount)
}

// -------------------------------------------------------------------

// BuiltinAssetEvent

// .vega.BuiltinAssetDeposit deposit = 1001 [json_name = "deposit"];
inline bool BuiltinAssetEvent::_internal_has_deposit() const {
  return action_case() == kDeposit;
}
inline bool BuiltinAssetEvent::has_deposit() const {
  return _internal_has_deposit();
}
inline void BuiltinAssetEvent::set_has_deposit() {
  _oneof_case_[0] = kDeposit;
}
inline void BuiltinAssetEvent::clear_deposit() {
  if (_internal_has_deposit()) {
    if (GetArena() == nullptr) {
      delete action_.deposit_;
    }
    clear_has_action();
  }
}
inline ::vega::BuiltinAssetDeposit* BuiltinAssetEvent::release_deposit() {
  // @@protoc_insertion_point(field_release:vega.BuiltinAssetEvent.deposit)
  if (_internal_has_deposit()) {
    clear_has_action();
      ::vega::BuiltinAssetDeposit* temp = action_.deposit_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    action_.deposit_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vega::BuiltinAssetDeposit& BuiltinAssetEvent::_internal_deposit() const {
  return _internal_has_deposit()
      ? *action_.deposit_
      : reinterpret_cast< ::vega::BuiltinAssetDeposit&>(::vega::_BuiltinAssetDeposit_default_instance_);
}
inline const ::vega::BuiltinAssetDeposit& BuiltinAssetEvent::deposit() const {
  // @@protoc_insertion_point(field_get:vega.BuiltinAssetEvent.deposit)
  return _internal_deposit();
}
inline ::vega::BuiltinAssetDeposit* BuiltinAssetEvent::unsafe_arena_release_deposit() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vega.BuiltinAssetEvent.deposit)
  if (_internal_has_deposit()) {
    clear_has_action();
    ::vega::BuiltinAssetDeposit* temp = action_.deposit_;
    action_.deposit_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BuiltinAssetEvent::unsafe_arena_set_allocated_deposit(::vega::BuiltinAssetDeposit* deposit) {
  clear_action();
  if (deposit) {
    set_has_deposit();
    action_.deposit_ = deposit;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vega.BuiltinAssetEvent.deposit)
}
inline ::vega::BuiltinAssetDeposit* BuiltinAssetEvent::_internal_mutable_deposit() {
  if (!_internal_has_deposit()) {
    clear_action();
    set_has_deposit();
    action_.deposit_ = CreateMaybeMessage< ::vega::BuiltinAssetDeposit >(GetArena());
  }
  return action_.deposit_;
}
inline ::vega::BuiltinAssetDeposit* BuiltinAssetEvent::mutable_deposit() {
  // @@protoc_insertion_point(field_mutable:vega.BuiltinAssetEvent.deposit)
  return _internal_mutable_deposit();
}

// .vega.BuiltinAssetWithdrawal withdrawal = 1002 [json_name = "withdrawal"];
inline bool BuiltinAssetEvent::_internal_has_withdrawal() const {
  return action_case() == kWithdrawal;
}
inline bool BuiltinAssetEvent::has_withdrawal() const {
  return _internal_has_withdrawal();
}
inline void BuiltinAssetEvent::set_has_withdrawal() {
  _oneof_case_[0] = kWithdrawal;
}
inline void BuiltinAssetEvent::clear_withdrawal() {
  if (_internal_has_withdrawal()) {
    if (GetArena() == nullptr) {
      delete action_.withdrawal_;
    }
    clear_has_action();
  }
}
inline ::vega::BuiltinAssetWithdrawal* BuiltinAssetEvent::release_withdrawal() {
  // @@protoc_insertion_point(field_release:vega.BuiltinAssetEvent.withdrawal)
  if (_internal_has_withdrawal()) {
    clear_has_action();
      ::vega::BuiltinAssetWithdrawal* temp = action_.withdrawal_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    action_.withdrawal_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vega::BuiltinAssetWithdrawal& BuiltinAssetEvent::_internal_withdrawal() const {
  return _internal_has_withdrawal()
      ? *action_.withdrawal_
      : reinterpret_cast< ::vega::BuiltinAssetWithdrawal&>(::vega::_BuiltinAssetWithdrawal_default_instance_);
}
inline const ::vega::BuiltinAssetWithdrawal& BuiltinAssetEvent::withdrawal() const {
  // @@protoc_insertion_point(field_get:vega.BuiltinAssetEvent.withdrawal)
  return _internal_withdrawal();
}
inline ::vega::BuiltinAssetWithdrawal* BuiltinAssetEvent::unsafe_arena_release_withdrawal() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vega.BuiltinAssetEvent.withdrawal)
  if (_internal_has_withdrawal()) {
    clear_has_action();
    ::vega::BuiltinAssetWithdrawal* temp = action_.withdrawal_;
    action_.withdrawal_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BuiltinAssetEvent::unsafe_arena_set_allocated_withdrawal(::vega::BuiltinAssetWithdrawal* withdrawal) {
  clear_action();
  if (withdrawal) {
    set_has_withdrawal();
    action_.withdrawal_ = withdrawal;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vega.BuiltinAssetEvent.withdrawal)
}
inline ::vega::BuiltinAssetWithdrawal* BuiltinAssetEvent::_internal_mutable_withdrawal() {
  if (!_internal_has_withdrawal()) {
    clear_action();
    set_has_withdrawal();
    action_.withdrawal_ = CreateMaybeMessage< ::vega::BuiltinAssetWithdrawal >(GetArena());
  }
  return action_.withdrawal_;
}
inline ::vega::BuiltinAssetWithdrawal* BuiltinAssetEvent::mutable_withdrawal() {
  // @@protoc_insertion_point(field_mutable:vega.BuiltinAssetEvent.withdrawal)
  return _internal_mutable_withdrawal();
}

inline bool BuiltinAssetEvent::has_action() const {
  return action_case() != ACTION_NOT_SET;
}
inline void BuiltinAssetEvent::clear_has_action() {
  _oneof_case_[0] = ACTION_NOT_SET;
}
inline BuiltinAssetEvent::ActionCase BuiltinAssetEvent::action_case() const {
  return BuiltinAssetEvent::ActionCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ERC20AssetList

// string vegaAssetID = 1 [json_name = "vegaAssetID"];
inline void ERC20AssetList::clear_vegaassetid() {
  vegaassetid_.ClearToEmpty();
}
inline const std::string& ERC20AssetList::vegaassetid() const {
  // @@protoc_insertion_point(field_get:vega.ERC20AssetList.vegaAssetID)
  return _internal_vegaassetid();
}
inline void ERC20AssetList::set_vegaassetid(const std::string& value) {
  _internal_set_vegaassetid(value);
  // @@protoc_insertion_point(field_set:vega.ERC20AssetList.vegaAssetID)
}
inline std::string* ERC20AssetList::mutable_vegaassetid() {
  // @@protoc_insertion_point(field_mutable:vega.ERC20AssetList.vegaAssetID)
  return _internal_mutable_vegaassetid();
}
inline const std::string& ERC20AssetList::_internal_vegaassetid() const {
  return vegaassetid_.Get();
}
inline void ERC20AssetList::_internal_set_vegaassetid(const std::string& value) {

  vegaassetid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void ERC20AssetList::set_vegaassetid(std::string&& value) {

  vegaassetid_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vega.ERC20AssetList.vegaAssetID)
}
inline void ERC20AssetList::set_vegaassetid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  vegaassetid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:vega.ERC20AssetList.vegaAssetID)
}
inline void ERC20AssetList::set_vegaassetid(const char* value,
    size_t size) {

  vegaassetid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vega.ERC20AssetList.vegaAssetID)
}
inline std::string* ERC20AssetList::_internal_mutable_vegaassetid() {

  return vegaassetid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* ERC20AssetList::release_vegaassetid() {
  // @@protoc_insertion_point(field_release:vega.ERC20AssetList.vegaAssetID)
  return vegaassetid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ERC20AssetList::set_allocated_vegaassetid(std::string* vegaassetid) {
  if (vegaassetid != nullptr) {

  } else {

  }
  vegaassetid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), vegaassetid,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vega.ERC20AssetList.vegaAssetID)
}

// -------------------------------------------------------------------

// ERC20AssetDelist

// string vegaAssetID = 1 [json_name = "vegaAssetID"];
inline void ERC20AssetDelist::clear_vegaassetid() {
  vegaassetid_.ClearToEmpty();
}
inline const std::string& ERC20AssetDelist::vegaassetid() const {
  // @@protoc_insertion_point(field_get:vega.ERC20AssetDelist.vegaAssetID)
  return _internal_vegaassetid();
}
inline void ERC20AssetDelist::set_vegaassetid(const std::string& value) {
  _internal_set_vegaassetid(value);
  // @@protoc_insertion_point(field_set:vega.ERC20AssetDelist.vegaAssetID)
}
inline std::string* ERC20AssetDelist::mutable_vegaassetid() {
  // @@protoc_insertion_point(field_mutable:vega.ERC20AssetDelist.vegaAssetID)
  return _internal_mutable_vegaassetid();
}
inline const std::string& ERC20AssetDelist::_internal_vegaassetid() const {
  return vegaassetid_.Get();
}
inline void ERC20AssetDelist::_internal_set_vegaassetid(const std::string& value) {

  vegaassetid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void ERC20AssetDelist::set_vegaassetid(std::string&& value) {

  vegaassetid_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vega.ERC20AssetDelist.vegaAssetID)
}
inline void ERC20AssetDelist::set_vegaassetid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  vegaassetid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:vega.ERC20AssetDelist.vegaAssetID)
}
inline void ERC20AssetDelist::set_vegaassetid(const char* value,
    size_t size) {

  vegaassetid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vega.ERC20AssetDelist.vegaAssetID)
}
inline std::string* ERC20AssetDelist::_internal_mutable_vegaassetid() {

  return vegaassetid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* ERC20AssetDelist::release_vegaassetid() {
  // @@protoc_insertion_point(field_release:vega.ERC20AssetDelist.vegaAssetID)
  return vegaassetid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ERC20AssetDelist::set_allocated_vegaassetid(std::string* vegaassetid) {
  if (vegaassetid != nullptr) {

  } else {

  }
  vegaassetid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), vegaassetid,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vega.ERC20AssetDelist.vegaAssetID)
}

// -------------------------------------------------------------------

// ERC20Deposit

// string vegaAssetID = 1 [json_name = "vegaAssetID"];
inline void ERC20Deposit::clear_vegaassetid() {
  vegaassetid_.ClearToEmpty();
}
inline const std::string& ERC20Deposit::vegaassetid() const {
  // @@protoc_insertion_point(field_get:vega.ERC20Deposit.vegaAssetID)
  return _internal_vegaassetid();
}
inline void ERC20Deposit::set_vegaassetid(const std::string& value) {
  _internal_set_vegaassetid(value);
  // @@protoc_insertion_point(field_set:vega.ERC20Deposit.vegaAssetID)
}
inline std::string* ERC20Deposit::mutable_vegaassetid() {
  // @@protoc_insertion_point(field_mutable:vega.ERC20Deposit.vegaAssetID)
  return _internal_mutable_vegaassetid();
}
inline const std::string& ERC20Deposit::_internal_vegaassetid() const {
  return vegaassetid_.Get();
}
inline void ERC20Deposit::_internal_set_vegaassetid(const std::string& value) {

  vegaassetid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void ERC20Deposit::set_vegaassetid(std::string&& value) {

  vegaassetid_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vega.ERC20Deposit.vegaAssetID)
}
inline void ERC20Deposit::set_vegaassetid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  vegaassetid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:vega.ERC20Deposit.vegaAssetID)
}
inline void ERC20Deposit::set_vegaassetid(const char* value,
    size_t size) {

  vegaassetid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vega.ERC20Deposit.vegaAssetID)
}
inline std::string* ERC20Deposit::_internal_mutable_vegaassetid() {

  return vegaassetid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* ERC20Deposit::release_vegaassetid() {
  // @@protoc_insertion_point(field_release:vega.ERC20Deposit.vegaAssetID)
  return vegaassetid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ERC20Deposit::set_allocated_vegaassetid(std::string* vegaassetid) {
  if (vegaassetid != nullptr) {

  } else {

  }
  vegaassetid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), vegaassetid,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vega.ERC20Deposit.vegaAssetID)
}

// string sourceEthereumAddress = 2 [json_name = "sourceEthereumAddress"];
inline void ERC20Deposit::clear_sourceethereumaddress() {
  sourceethereumaddress_.ClearToEmpty();
}
inline const std::string& ERC20Deposit::sourceethereumaddress() const {
  // @@protoc_insertion_point(field_get:vega.ERC20Deposit.sourceEthereumAddress)
  return _internal_sourceethereumaddress();
}
inline void ERC20Deposit::set_sourceethereumaddress(const std::string& value) {
  _internal_set_sourceethereumaddress(value);
  // @@protoc_insertion_point(field_set:vega.ERC20Deposit.sourceEthereumAddress)
}
inline std::string* ERC20Deposit::mutable_sourceethereumaddress() {
  // @@protoc_insertion_point(field_mutable:vega.ERC20Deposit.sourceEthereumAddress)
  return _internal_mutable_sourceethereumaddress();
}
inline const std::string& ERC20Deposit::_internal_sourceethereumaddress() const {
  return sourceethereumaddress_.Get();
}
inline void ERC20Deposit::_internal_set_sourceethereumaddress(const std::string& value) {

  sourceethereumaddress_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void ERC20Deposit::set_sourceethereumaddress(std::string&& value) {

  sourceethereumaddress_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vega.ERC20Deposit.sourceEthereumAddress)
}
inline void ERC20Deposit::set_sourceethereumaddress(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  sourceethereumaddress_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:vega.ERC20Deposit.sourceEthereumAddress)
}
inline void ERC20Deposit::set_sourceethereumaddress(const char* value,
    size_t size) {

  sourceethereumaddress_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vega.ERC20Deposit.sourceEthereumAddress)
}
inline std::string* ERC20Deposit::_internal_mutable_sourceethereumaddress() {

  return sourceethereumaddress_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* ERC20Deposit::release_sourceethereumaddress() {
  // @@protoc_insertion_point(field_release:vega.ERC20Deposit.sourceEthereumAddress)
  return sourceethereumaddress_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ERC20Deposit::set_allocated_sourceethereumaddress(std::string* sourceethereumaddress) {
  if (sourceethereumaddress != nullptr) {

  } else {

  }
  sourceethereumaddress_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sourceethereumaddress,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vega.ERC20Deposit.sourceEthereumAddress)
}

// string targetPartyID = 3 [json_name = "targetPartyID"];
inline void ERC20Deposit::clear_targetpartyid() {
  targetpartyid_.ClearToEmpty();
}
inline const std::string& ERC20Deposit::targetpartyid() const {
  // @@protoc_insertion_point(field_get:vega.ERC20Deposit.targetPartyID)
  return _internal_targetpartyid();
}
inline void ERC20Deposit::set_targetpartyid(const std::string& value) {
  _internal_set_targetpartyid(value);
  // @@protoc_insertion_point(field_set:vega.ERC20Deposit.targetPartyID)
}
inline std::string* ERC20Deposit::mutable_targetpartyid() {
  // @@protoc_insertion_point(field_mutable:vega.ERC20Deposit.targetPartyID)
  return _internal_mutable_targetpartyid();
}
inline const std::string& ERC20Deposit::_internal_targetpartyid() const {
  return targetpartyid_.Get();
}
inline void ERC20Deposit::_internal_set_targetpartyid(const std::string& value) {

  targetpartyid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void ERC20Deposit::set_targetpartyid(std::string&& value) {

  targetpartyid_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vega.ERC20Deposit.targetPartyID)
}
inline void ERC20Deposit::set_targetpartyid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  targetpartyid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:vega.ERC20Deposit.targetPartyID)
}
inline void ERC20Deposit::set_targetpartyid(const char* value,
    size_t size) {

  targetpartyid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vega.ERC20Deposit.targetPartyID)
}
inline std::string* ERC20Deposit::_internal_mutable_targetpartyid() {

  return targetpartyid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* ERC20Deposit::release_targetpartyid() {
  // @@protoc_insertion_point(field_release:vega.ERC20Deposit.targetPartyID)
  return targetpartyid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ERC20Deposit::set_allocated_targetpartyid(std::string* targetpartyid) {
  if (targetpartyid != nullptr) {

  } else {

  }
  targetpartyid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), targetpartyid,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vega.ERC20Deposit.targetPartyID)
}

// string amount = 4 [json_name = "amount"];
inline void ERC20Deposit::clear_amount() {
  amount_.ClearToEmpty();
}
inline const std::string& ERC20Deposit::amount() const {
  // @@protoc_insertion_point(field_get:vega.ERC20Deposit.amount)
  return _internal_amount();
}
inline void ERC20Deposit::set_amount(const std::string& value) {
  _internal_set_amount(value);
  // @@protoc_insertion_point(field_set:vega.ERC20Deposit.amount)
}
inline std::string* ERC20Deposit::mutable_amount() {
  // @@protoc_insertion_point(field_mutable:vega.ERC20Deposit.amount)
  return _internal_mutable_amount();
}
inline const std::string& ERC20Deposit::_internal_amount() const {
  return amount_.Get();
}
inline void ERC20Deposit::_internal_set_amount(const std::string& value) {

  amount_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void ERC20Deposit::set_amount(std::string&& value) {

  amount_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vega.ERC20Deposit.amount)
}
inline void ERC20Deposit::set_amount(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  amount_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:vega.ERC20Deposit.amount)
}
inline void ERC20Deposit::set_amount(const char* value,
    size_t size) {

  amount_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vega.ERC20Deposit.amount)
}
inline std::string* ERC20Deposit::_internal_mutable_amount() {

  return amount_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* ERC20Deposit::release_amount() {
  // @@protoc_insertion_point(field_release:vega.ERC20Deposit.amount)
  return amount_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ERC20Deposit::set_allocated_amount(std::string* amount) {
  if (amount != nullptr) {

  } else {

  }
  amount_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), amount,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vega.ERC20Deposit.amount)
}

// -------------------------------------------------------------------

// ERC20Withdrawal

// string vegaAssetID = 1 [json_name = "vegaAssetID"];
inline void ERC20Withdrawal::clear_vegaassetid() {
  vegaassetid_.ClearToEmpty();
}
inline const std::string& ERC20Withdrawal::vegaassetid() const {
  // @@protoc_insertion_point(field_get:vega.ERC20Withdrawal.vegaAssetID)
  return _internal_vegaassetid();
}
inline void ERC20Withdrawal::set_vegaassetid(const std::string& value) {
  _internal_set_vegaassetid(value);
  // @@protoc_insertion_point(field_set:vega.ERC20Withdrawal.vegaAssetID)
}
inline std::string* ERC20Withdrawal::mutable_vegaassetid() {
  // @@protoc_insertion_point(field_mutable:vega.ERC20Withdrawal.vegaAssetID)
  return _internal_mutable_vegaassetid();
}
inline const std::string& ERC20Withdrawal::_internal_vegaassetid() const {
  return vegaassetid_.Get();
}
inline void ERC20Withdrawal::_internal_set_vegaassetid(const std::string& value) {

  vegaassetid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void ERC20Withdrawal::set_vegaassetid(std::string&& value) {

  vegaassetid_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vega.ERC20Withdrawal.vegaAssetID)
}
inline void ERC20Withdrawal::set_vegaassetid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  vegaassetid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:vega.ERC20Withdrawal.vegaAssetID)
}
inline void ERC20Withdrawal::set_vegaassetid(const char* value,
    size_t size) {

  vegaassetid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vega.ERC20Withdrawal.vegaAssetID)
}
inline std::string* ERC20Withdrawal::_internal_mutable_vegaassetid() {

  return vegaassetid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* ERC20Withdrawal::release_vegaassetid() {
  // @@protoc_insertion_point(field_release:vega.ERC20Withdrawal.vegaAssetID)
  return vegaassetid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ERC20Withdrawal::set_allocated_vegaassetid(std::string* vegaassetid) {
  if (vegaassetid != nullptr) {

  } else {

  }
  vegaassetid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), vegaassetid,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vega.ERC20Withdrawal.vegaAssetID)
}

// string targetEthereumAddress = 2 [json_name = "targetEthereumAddress"];
inline void ERC20Withdrawal::clear_targetethereumaddress() {
  targetethereumaddress_.ClearToEmpty();
}
inline const std::string& ERC20Withdrawal::targetethereumaddress() const {
  // @@protoc_insertion_point(field_get:vega.ERC20Withdrawal.targetEthereumAddress)
  return _internal_targetethereumaddress();
}
inline void ERC20Withdrawal::set_targetethereumaddress(const std::string& value) {
  _internal_set_targetethereumaddress(value);
  // @@protoc_insertion_point(field_set:vega.ERC20Withdrawal.targetEthereumAddress)
}
inline std::string* ERC20Withdrawal::mutable_targetethereumaddress() {
  // @@protoc_insertion_point(field_mutable:vega.ERC20Withdrawal.targetEthereumAddress)
  return _internal_mutable_targetethereumaddress();
}
inline const std::string& ERC20Withdrawal::_internal_targetethereumaddress() const {
  return targetethereumaddress_.Get();
}
inline void ERC20Withdrawal::_internal_set_targetethereumaddress(const std::string& value) {

  targetethereumaddress_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void ERC20Withdrawal::set_targetethereumaddress(std::string&& value) {

  targetethereumaddress_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vega.ERC20Withdrawal.targetEthereumAddress)
}
inline void ERC20Withdrawal::set_targetethereumaddress(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  targetethereumaddress_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:vega.ERC20Withdrawal.targetEthereumAddress)
}
inline void ERC20Withdrawal::set_targetethereumaddress(const char* value,
    size_t size) {

  targetethereumaddress_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vega.ERC20Withdrawal.targetEthereumAddress)
}
inline std::string* ERC20Withdrawal::_internal_mutable_targetethereumaddress() {

  return targetethereumaddress_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* ERC20Withdrawal::release_targetethereumaddress() {
  // @@protoc_insertion_point(field_release:vega.ERC20Withdrawal.targetEthereumAddress)
  return targetethereumaddress_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ERC20Withdrawal::set_allocated_targetethereumaddress(std::string* targetethereumaddress) {
  if (targetethereumaddress != nullptr) {

  } else {

  }
  targetethereumaddress_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), targetethereumaddress,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vega.ERC20Withdrawal.targetEthereumAddress)
}

// string referenceNonce = 3 [json_name = "referenceNonce"];
inline void ERC20Withdrawal::clear_referencenonce() {
  referencenonce_.ClearToEmpty();
}
inline const std::string& ERC20Withdrawal::referencenonce() const {
  // @@protoc_insertion_point(field_get:vega.ERC20Withdrawal.referenceNonce)
  return _internal_referencenonce();
}
inline void ERC20Withdrawal::set_referencenonce(const std::string& value) {
  _internal_set_referencenonce(value);
  // @@protoc_insertion_point(field_set:vega.ERC20Withdrawal.referenceNonce)
}
inline std::string* ERC20Withdrawal::mutable_referencenonce() {
  // @@protoc_insertion_point(field_mutable:vega.ERC20Withdrawal.referenceNonce)
  return _internal_mutable_referencenonce();
}
inline const std::string& ERC20Withdrawal::_internal_referencenonce() const {
  return referencenonce_.Get();
}
inline void ERC20Withdrawal::_internal_set_referencenonce(const std::string& value) {

  referencenonce_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void ERC20Withdrawal::set_referencenonce(std::string&& value) {

  referencenonce_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vega.ERC20Withdrawal.referenceNonce)
}
inline void ERC20Withdrawal::set_referencenonce(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  referencenonce_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:vega.ERC20Withdrawal.referenceNonce)
}
inline void ERC20Withdrawal::set_referencenonce(const char* value,
    size_t size) {

  referencenonce_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vega.ERC20Withdrawal.referenceNonce)
}
inline std::string* ERC20Withdrawal::_internal_mutable_referencenonce() {

  return referencenonce_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* ERC20Withdrawal::release_referencenonce() {
  // @@protoc_insertion_point(field_release:vega.ERC20Withdrawal.referenceNonce)
  return referencenonce_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ERC20Withdrawal::set_allocated_referencenonce(std::string* referencenonce) {
  if (referencenonce != nullptr) {

  } else {

  }
  referencenonce_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), referencenonce,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vega.ERC20Withdrawal.referenceNonce)
}

// -------------------------------------------------------------------

// ERC20Event

// uint64 index = 1 [json_name = "index"];
inline void ERC20Event::clear_index() {
  index_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ERC20Event::_internal_index() const {
  return index_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ERC20Event::index() const {
  // @@protoc_insertion_point(field_get:vega.ERC20Event.index)
  return _internal_index();
}
inline void ERC20Event::_internal_set_index(::PROTOBUF_NAMESPACE_ID::uint64 value) {

  index_ = value;
}
inline void ERC20Event::set_index(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:vega.ERC20Event.index)
}

// uint64 block = 2 [json_name = "block"];
inline void ERC20Event::clear_block() {
  block_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ERC20Event::_internal_block() const {
  return block_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ERC20Event::block() const {
  // @@protoc_insertion_point(field_get:vega.ERC20Event.block)
  return _internal_block();
}
inline void ERC20Event::_internal_set_block(::PROTOBUF_NAMESPACE_ID::uint64 value) {

  block_ = value;
}
inline void ERC20Event::set_block(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_block(value);
  // @@protoc_insertion_point(field_set:vega.ERC20Event.block)
}

// .vega.ERC20AssetList assetList = 1001 [json_name = "assetList"];
inline bool ERC20Event::_internal_has_assetlist() const {
  return action_case() == kAssetList;
}
inline bool ERC20Event::has_assetlist() const {
  return _internal_has_assetlist();
}
inline void ERC20Event::set_has_assetlist() {
  _oneof_case_[0] = kAssetList;
}
inline void ERC20Event::clear_assetlist() {
  if (_internal_has_assetlist()) {
    if (GetArena() == nullptr) {
      delete action_.assetlist_;
    }
    clear_has_action();
  }
}
inline ::vega::ERC20AssetList* ERC20Event::release_assetlist() {
  // @@protoc_insertion_point(field_release:vega.ERC20Event.assetList)
  if (_internal_has_assetlist()) {
    clear_has_action();
      ::vega::ERC20AssetList* temp = action_.assetlist_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    action_.assetlist_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vega::ERC20AssetList& ERC20Event::_internal_assetlist() const {
  return _internal_has_assetlist()
      ? *action_.assetlist_
      : reinterpret_cast< ::vega::ERC20AssetList&>(::vega::_ERC20AssetList_default_instance_);
}
inline const ::vega::ERC20AssetList& ERC20Event::assetlist() const {
  // @@protoc_insertion_point(field_get:vega.ERC20Event.assetList)
  return _internal_assetlist();
}
inline ::vega::ERC20AssetList* ERC20Event::unsafe_arena_release_assetlist() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vega.ERC20Event.assetList)
  if (_internal_has_assetlist()) {
    clear_has_action();
    ::vega::ERC20AssetList* temp = action_.assetlist_;
    action_.assetlist_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ERC20Event::unsafe_arena_set_allocated_assetlist(::vega::ERC20AssetList* assetlist) {
  clear_action();
  if (assetlist) {
    set_has_assetlist();
    action_.assetlist_ = assetlist;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vega.ERC20Event.assetList)
}
inline ::vega::ERC20AssetList* ERC20Event::_internal_mutable_assetlist() {
  if (!_internal_has_assetlist()) {
    clear_action();
    set_has_assetlist();
    action_.assetlist_ = CreateMaybeMessage< ::vega::ERC20AssetList >(GetArena());
  }
  return action_.assetlist_;
}
inline ::vega::ERC20AssetList* ERC20Event::mutable_assetlist() {
  // @@protoc_insertion_point(field_mutable:vega.ERC20Event.assetList)
  return _internal_mutable_assetlist();
}

// .vega.ERC20AssetDelist assetDelist = 1002 [json_name = "assetDelist"];
inline bool ERC20Event::_internal_has_assetdelist() const {
  return action_case() == kAssetDelist;
}
inline bool ERC20Event::has_assetdelist() const {
  return _internal_has_assetdelist();
}
inline void ERC20Event::set_has_assetdelist() {
  _oneof_case_[0] = kAssetDelist;
}
inline void ERC20Event::clear_assetdelist() {
  if (_internal_has_assetdelist()) {
    if (GetArena() == nullptr) {
      delete action_.assetdelist_;
    }
    clear_has_action();
  }
}
inline ::vega::ERC20AssetDelist* ERC20Event::release_assetdelist() {
  // @@protoc_insertion_point(field_release:vega.ERC20Event.assetDelist)
  if (_internal_has_assetdelist()) {
    clear_has_action();
      ::vega::ERC20AssetDelist* temp = action_.assetdelist_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    action_.assetdelist_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vega::ERC20AssetDelist& ERC20Event::_internal_assetdelist() const {
  return _internal_has_assetdelist()
      ? *action_.assetdelist_
      : reinterpret_cast< ::vega::ERC20AssetDelist&>(::vega::_ERC20AssetDelist_default_instance_);
}
inline const ::vega::ERC20AssetDelist& ERC20Event::assetdelist() const {
  // @@protoc_insertion_point(field_get:vega.ERC20Event.assetDelist)
  return _internal_assetdelist();
}
inline ::vega::ERC20AssetDelist* ERC20Event::unsafe_arena_release_assetdelist() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vega.ERC20Event.assetDelist)
  if (_internal_has_assetdelist()) {
    clear_has_action();
    ::vega::ERC20AssetDelist* temp = action_.assetdelist_;
    action_.assetdelist_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ERC20Event::unsafe_arena_set_allocated_assetdelist(::vega::ERC20AssetDelist* assetdelist) {
  clear_action();
  if (assetdelist) {
    set_has_assetdelist();
    action_.assetdelist_ = assetdelist;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vega.ERC20Event.assetDelist)
}
inline ::vega::ERC20AssetDelist* ERC20Event::_internal_mutable_assetdelist() {
  if (!_internal_has_assetdelist()) {
    clear_action();
    set_has_assetdelist();
    action_.assetdelist_ = CreateMaybeMessage< ::vega::ERC20AssetDelist >(GetArena());
  }
  return action_.assetdelist_;
}
inline ::vega::ERC20AssetDelist* ERC20Event::mutable_assetdelist() {
  // @@protoc_insertion_point(field_mutable:vega.ERC20Event.assetDelist)
  return _internal_mutable_assetdelist();
}

// .vega.ERC20Deposit deposit = 1003 [json_name = "deposit"];
inline bool ERC20Event::_internal_has_deposit() const {
  return action_case() == kDeposit;
}
inline bool ERC20Event::has_deposit() const {
  return _internal_has_deposit();
}
inline void ERC20Event::set_has_deposit() {
  _oneof_case_[0] = kDeposit;
}
inline void ERC20Event::clear_deposit() {
  if (_internal_has_deposit()) {
    if (GetArena() == nullptr) {
      delete action_.deposit_;
    }
    clear_has_action();
  }
}
inline ::vega::ERC20Deposit* ERC20Event::release_deposit() {
  // @@protoc_insertion_point(field_release:vega.ERC20Event.deposit)
  if (_internal_has_deposit()) {
    clear_has_action();
      ::vega::ERC20Deposit* temp = action_.deposit_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    action_.deposit_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vega::ERC20Deposit& ERC20Event::_internal_deposit() const {
  return _internal_has_deposit()
      ? *action_.deposit_
      : reinterpret_cast< ::vega::ERC20Deposit&>(::vega::_ERC20Deposit_default_instance_);
}
inline const ::vega::ERC20Deposit& ERC20Event::deposit() const {
  // @@protoc_insertion_point(field_get:vega.ERC20Event.deposit)
  return _internal_deposit();
}
inline ::vega::ERC20Deposit* ERC20Event::unsafe_arena_release_deposit() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vega.ERC20Event.deposit)
  if (_internal_has_deposit()) {
    clear_has_action();
    ::vega::ERC20Deposit* temp = action_.deposit_;
    action_.deposit_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ERC20Event::unsafe_arena_set_allocated_deposit(::vega::ERC20Deposit* deposit) {
  clear_action();
  if (deposit) {
    set_has_deposit();
    action_.deposit_ = deposit;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vega.ERC20Event.deposit)
}
inline ::vega::ERC20Deposit* ERC20Event::_internal_mutable_deposit() {
  if (!_internal_has_deposit()) {
    clear_action();
    set_has_deposit();
    action_.deposit_ = CreateMaybeMessage< ::vega::ERC20Deposit >(GetArena());
  }
  return action_.deposit_;
}
inline ::vega::ERC20Deposit* ERC20Event::mutable_deposit() {
  // @@protoc_insertion_point(field_mutable:vega.ERC20Event.deposit)
  return _internal_mutable_deposit();
}

// .vega.ERC20Withdrawal withdrawal = 1004 [json_name = "withdrawal"];
inline bool ERC20Event::_internal_has_withdrawal() const {
  return action_case() == kWithdrawal;
}
inline bool ERC20Event::has_withdrawal() const {
  return _internal_has_withdrawal();
}
inline void ERC20Event::set_has_withdrawal() {
  _oneof_case_[0] = kWithdrawal;
}
inline void ERC20Event::clear_withdrawal() {
  if (_internal_has_withdrawal()) {
    if (GetArena() == nullptr) {
      delete action_.withdrawal_;
    }
    clear_has_action();
  }
}
inline ::vega::ERC20Withdrawal* ERC20Event::release_withdrawal() {
  // @@protoc_insertion_point(field_release:vega.ERC20Event.withdrawal)
  if (_internal_has_withdrawal()) {
    clear_has_action();
      ::vega::ERC20Withdrawal* temp = action_.withdrawal_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    action_.withdrawal_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vega::ERC20Withdrawal& ERC20Event::_internal_withdrawal() const {
  return _internal_has_withdrawal()
      ? *action_.withdrawal_
      : reinterpret_cast< ::vega::ERC20Withdrawal&>(::vega::_ERC20Withdrawal_default_instance_);
}
inline const ::vega::ERC20Withdrawal& ERC20Event::withdrawal() const {
  // @@protoc_insertion_point(field_get:vega.ERC20Event.withdrawal)
  return _internal_withdrawal();
}
inline ::vega::ERC20Withdrawal* ERC20Event::unsafe_arena_release_withdrawal() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vega.ERC20Event.withdrawal)
  if (_internal_has_withdrawal()) {
    clear_has_action();
    ::vega::ERC20Withdrawal* temp = action_.withdrawal_;
    action_.withdrawal_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ERC20Event::unsafe_arena_set_allocated_withdrawal(::vega::ERC20Withdrawal* withdrawal) {
  clear_action();
  if (withdrawal) {
    set_has_withdrawal();
    action_.withdrawal_ = withdrawal;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vega.ERC20Event.withdrawal)
}
inline ::vega::ERC20Withdrawal* ERC20Event::_internal_mutable_withdrawal() {
  if (!_internal_has_withdrawal()) {
    clear_action();
    set_has_withdrawal();
    action_.withdrawal_ = CreateMaybeMessage< ::vega::ERC20Withdrawal >(GetArena());
  }
  return action_.withdrawal_;
}
inline ::vega::ERC20Withdrawal* ERC20Event::mutable_withdrawal() {
  // @@protoc_insertion_point(field_mutable:vega.ERC20Event.withdrawal)
  return _internal_mutable_withdrawal();
}

inline bool ERC20Event::has_action() const {
  return action_case() != ACTION_NOT_SET;
}
inline void ERC20Event::clear_has_action() {
  _oneof_case_[0] = ACTION_NOT_SET;
}
inline ERC20Event::ActionCase ERC20Event::action_case() const {
  return ERC20Event::ActionCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// BTCDeposit

// string vegaAssetID = 1 [json_name = "vegaAssetID"];
inline void BTCDeposit::clear_vegaassetid() {
  vegaassetid_.ClearToEmpty();
}
inline const std::string& BTCDeposit::vegaassetid() const {
  // @@protoc_insertion_point(field_get:vega.BTCDeposit.vegaAssetID)
  return _internal_vegaassetid();
}
inline void BTCDeposit::set_vegaassetid(const std::string& value) {
  _internal_set_vegaassetid(value);
  // @@protoc_insertion_point(field_set:vega.BTCDeposit.vegaAssetID)
}
inline std::string* BTCDeposit::mutable_vegaassetid() {
  // @@protoc_insertion_point(field_mutable:vega.BTCDeposit.vegaAssetID)
  return _internal_mutable_vegaassetid();
}
inline const std::string& BTCDeposit::_internal_vegaassetid() const {
  return vegaassetid_.Get();
}
inline void BTCDeposit::_internal_set_vegaassetid(const std::string& value) {

  vegaassetid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void BTCDeposit::set_vegaassetid(std::string&& value) {

  vegaassetid_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vega.BTCDeposit.vegaAssetID)
}
inline void BTCDeposit::set_vegaassetid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  vegaassetid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:vega.BTCDeposit.vegaAssetID)
}
inline void BTCDeposit::set_vegaassetid(const char* value,
    size_t size) {

  vegaassetid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vega.BTCDeposit.vegaAssetID)
}
inline std::string* BTCDeposit::_internal_mutable_vegaassetid() {

  return vegaassetid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* BTCDeposit::release_vegaassetid() {
  // @@protoc_insertion_point(field_release:vega.BTCDeposit.vegaAssetID)
  return vegaassetid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void BTCDeposit::set_allocated_vegaassetid(std::string* vegaassetid) {
  if (vegaassetid != nullptr) {

  } else {

  }
  vegaassetid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), vegaassetid,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vega.BTCDeposit.vegaAssetID)
}

// string sourceBTCAddress = 2 [json_name = "sourceBTCAddress"];
inline void BTCDeposit::clear_sourcebtcaddress() {
  sourcebtcaddress_.ClearToEmpty();
}
inline const std::string& BTCDeposit::sourcebtcaddress() const {
  // @@protoc_insertion_point(field_get:vega.BTCDeposit.sourceBTCAddress)
  return _internal_sourcebtcaddress();
}
inline void BTCDeposit::set_sourcebtcaddress(const std::string& value) {
  _internal_set_sourcebtcaddress(value);
  // @@protoc_insertion_point(field_set:vega.BTCDeposit.sourceBTCAddress)
}
inline std::string* BTCDeposit::mutable_sourcebtcaddress() {
  // @@protoc_insertion_point(field_mutable:vega.BTCDeposit.sourceBTCAddress)
  return _internal_mutable_sourcebtcaddress();
}
inline const std::string& BTCDeposit::_internal_sourcebtcaddress() const {
  return sourcebtcaddress_.Get();
}
inline void BTCDeposit::_internal_set_sourcebtcaddress(const std::string& value) {

  sourcebtcaddress_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void BTCDeposit::set_sourcebtcaddress(std::string&& value) {

  sourcebtcaddress_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vega.BTCDeposit.sourceBTCAddress)
}
inline void BTCDeposit::set_sourcebtcaddress(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  sourcebtcaddress_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:vega.BTCDeposit.sourceBTCAddress)
}
inline void BTCDeposit::set_sourcebtcaddress(const char* value,
    size_t size) {

  sourcebtcaddress_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vega.BTCDeposit.sourceBTCAddress)
}
inline std::string* BTCDeposit::_internal_mutable_sourcebtcaddress() {

  return sourcebtcaddress_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* BTCDeposit::release_sourcebtcaddress() {
  // @@protoc_insertion_point(field_release:vega.BTCDeposit.sourceBTCAddress)
  return sourcebtcaddress_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void BTCDeposit::set_allocated_sourcebtcaddress(std::string* sourcebtcaddress) {
  if (sourcebtcaddress != nullptr) {

  } else {

  }
  sourcebtcaddress_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sourcebtcaddress,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vega.BTCDeposit.sourceBTCAddress)
}

// string targetPartyId = 3 [json_name = "targetPartyId"];
inline void BTCDeposit::clear_targetpartyid() {
  targetpartyid_.ClearToEmpty();
}
inline const std::string& BTCDeposit::targetpartyid() const {
  // @@protoc_insertion_point(field_get:vega.BTCDeposit.targetPartyId)
  return _internal_targetpartyid();
}
inline void BTCDeposit::set_targetpartyid(const std::string& value) {
  _internal_set_targetpartyid(value);
  // @@protoc_insertion_point(field_set:vega.BTCDeposit.targetPartyId)
}
inline std::string* BTCDeposit::mutable_targetpartyid() {
  // @@protoc_insertion_point(field_mutable:vega.BTCDeposit.targetPartyId)
  return _internal_mutable_targetpartyid();
}
inline const std::string& BTCDeposit::_internal_targetpartyid() const {
  return targetpartyid_.Get();
}
inline void BTCDeposit::_internal_set_targetpartyid(const std::string& value) {

  targetpartyid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void BTCDeposit::set_targetpartyid(std::string&& value) {

  targetpartyid_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vega.BTCDeposit.targetPartyId)
}
inline void BTCDeposit::set_targetpartyid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  targetpartyid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:vega.BTCDeposit.targetPartyId)
}
inline void BTCDeposit::set_targetpartyid(const char* value,
    size_t size) {

  targetpartyid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vega.BTCDeposit.targetPartyId)
}
inline std::string* BTCDeposit::_internal_mutable_targetpartyid() {

  return targetpartyid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* BTCDeposit::release_targetpartyid() {
  // @@protoc_insertion_point(field_release:vega.BTCDeposit.targetPartyId)
  return targetpartyid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void BTCDeposit::set_allocated_targetpartyid(std::string* targetpartyid) {
  if (targetpartyid != nullptr) {

  } else {

  }
  targetpartyid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), targetpartyid,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vega.BTCDeposit.targetPartyId)
}

// -------------------------------------------------------------------

// BTCWithdrawal

// string vegaAssetID = 1 [json_name = "vegaAssetID"];
inline void BTCWithdrawal::clear_vegaassetid() {
  vegaassetid_.ClearToEmpty();
}
inline const std::string& BTCWithdrawal::vegaassetid() const {
  // @@protoc_insertion_point(field_get:vega.BTCWithdrawal.vegaAssetID)
  return _internal_vegaassetid();
}
inline void BTCWithdrawal::set_vegaassetid(const std::string& value) {
  _internal_set_vegaassetid(value);
  // @@protoc_insertion_point(field_set:vega.BTCWithdrawal.vegaAssetID)
}
inline std::string* BTCWithdrawal::mutable_vegaassetid() {
  // @@protoc_insertion_point(field_mutable:vega.BTCWithdrawal.vegaAssetID)
  return _internal_mutable_vegaassetid();
}
inline const std::string& BTCWithdrawal::_internal_vegaassetid() const {
  return vegaassetid_.Get();
}
inline void BTCWithdrawal::_internal_set_vegaassetid(const std::string& value) {

  vegaassetid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void BTCWithdrawal::set_vegaassetid(std::string&& value) {

  vegaassetid_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vega.BTCWithdrawal.vegaAssetID)
}
inline void BTCWithdrawal::set_vegaassetid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  vegaassetid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:vega.BTCWithdrawal.vegaAssetID)
}
inline void BTCWithdrawal::set_vegaassetid(const char* value,
    size_t size) {

  vegaassetid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vega.BTCWithdrawal.vegaAssetID)
}
inline std::string* BTCWithdrawal::_internal_mutable_vegaassetid() {

  return vegaassetid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* BTCWithdrawal::release_vegaassetid() {
  // @@protoc_insertion_point(field_release:vega.BTCWithdrawal.vegaAssetID)
  return vegaassetid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void BTCWithdrawal::set_allocated_vegaassetid(std::string* vegaassetid) {
  if (vegaassetid != nullptr) {

  } else {

  }
  vegaassetid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), vegaassetid,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vega.BTCWithdrawal.vegaAssetID)
}

// string sourcePartyId = 2 [json_name = "sourcePartyId"];
inline void BTCWithdrawal::clear_sourcepartyid() {
  sourcepartyid_.ClearToEmpty();
}
inline const std::string& BTCWithdrawal::sourcepartyid() const {
  // @@protoc_insertion_point(field_get:vega.BTCWithdrawal.sourcePartyId)
  return _internal_sourcepartyid();
}
inline void BTCWithdrawal::set_sourcepartyid(const std::string& value) {
  _internal_set_sourcepartyid(value);
  // @@protoc_insertion_point(field_set:vega.BTCWithdrawal.sourcePartyId)
}
inline std::string* BTCWithdrawal::mutable_sourcepartyid() {
  // @@protoc_insertion_point(field_mutable:vega.BTCWithdrawal.sourcePartyId)
  return _internal_mutable_sourcepartyid();
}
inline const std::string& BTCWithdrawal::_internal_sourcepartyid() const {
  return sourcepartyid_.Get();
}
inline void BTCWithdrawal::_internal_set_sourcepartyid(const std::string& value) {

  sourcepartyid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void BTCWithdrawal::set_sourcepartyid(std::string&& value) {

  sourcepartyid_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vega.BTCWithdrawal.sourcePartyId)
}
inline void BTCWithdrawal::set_sourcepartyid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  sourcepartyid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:vega.BTCWithdrawal.sourcePartyId)
}
inline void BTCWithdrawal::set_sourcepartyid(const char* value,
    size_t size) {

  sourcepartyid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vega.BTCWithdrawal.sourcePartyId)
}
inline std::string* BTCWithdrawal::_internal_mutable_sourcepartyid() {

  return sourcepartyid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* BTCWithdrawal::release_sourcepartyid() {
  // @@protoc_insertion_point(field_release:vega.BTCWithdrawal.sourcePartyId)
  return sourcepartyid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void BTCWithdrawal::set_allocated_sourcepartyid(std::string* sourcepartyid) {
  if (sourcepartyid != nullptr) {

  } else {

  }
  sourcepartyid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sourcepartyid,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vega.BTCWithdrawal.sourcePartyId)
}

// string targetBTCAddress = 3 [json_name = "targetBTCAddress"];
inline void BTCWithdrawal::clear_targetbtcaddress() {
  targetbtcaddress_.ClearToEmpty();
}
inline const std::string& BTCWithdrawal::targetbtcaddress() const {
  // @@protoc_insertion_point(field_get:vega.BTCWithdrawal.targetBTCAddress)
  return _internal_targetbtcaddress();
}
inline void BTCWithdrawal::set_targetbtcaddress(const std::string& value) {
  _internal_set_targetbtcaddress(value);
  // @@protoc_insertion_point(field_set:vega.BTCWithdrawal.targetBTCAddress)
}
inline std::string* BTCWithdrawal::mutable_targetbtcaddress() {
  // @@protoc_insertion_point(field_mutable:vega.BTCWithdrawal.targetBTCAddress)
  return _internal_mutable_targetbtcaddress();
}
inline const std::string& BTCWithdrawal::_internal_targetbtcaddress() const {
  return targetbtcaddress_.Get();
}
inline void BTCWithdrawal::_internal_set_targetbtcaddress(const std::string& value) {

  targetbtcaddress_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void BTCWithdrawal::set_targetbtcaddress(std::string&& value) {

  targetbtcaddress_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vega.BTCWithdrawal.targetBTCAddress)
}
inline void BTCWithdrawal::set_targetbtcaddress(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  targetbtcaddress_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:vega.BTCWithdrawal.targetBTCAddress)
}
inline void BTCWithdrawal::set_targetbtcaddress(const char* value,
    size_t size) {

  targetbtcaddress_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vega.BTCWithdrawal.targetBTCAddress)
}
inline std::string* BTCWithdrawal::_internal_mutable_targetbtcaddress() {

  return targetbtcaddress_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* BTCWithdrawal::release_targetbtcaddress() {
  // @@protoc_insertion_point(field_release:vega.BTCWithdrawal.targetBTCAddress)
  return targetbtcaddress_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void BTCWithdrawal::set_allocated_targetbtcaddress(std::string* targetbtcaddress) {
  if (targetbtcaddress != nullptr) {

  } else {

  }
  targetbtcaddress_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), targetbtcaddress,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vega.BTCWithdrawal.targetBTCAddress)
}

// string referenceNonce = 4 [json_name = "referenceNonce"];
inline void BTCWithdrawal::clear_referencenonce() {
  referencenonce_.ClearToEmpty();
}
inline const std::string& BTCWithdrawal::referencenonce() const {
  // @@protoc_insertion_point(field_get:vega.BTCWithdrawal.referenceNonce)
  return _internal_referencenonce();
}
inline void BTCWithdrawal::set_referencenonce(const std::string& value) {
  _internal_set_referencenonce(value);
  // @@protoc_insertion_point(field_set:vega.BTCWithdrawal.referenceNonce)
}
inline std::string* BTCWithdrawal::mutable_referencenonce() {
  // @@protoc_insertion_point(field_mutable:vega.BTCWithdrawal.referenceNonce)
  return _internal_mutable_referencenonce();
}
inline const std::string& BTCWithdrawal::_internal_referencenonce() const {
  return referencenonce_.Get();
}
inline void BTCWithdrawal::_internal_set_referencenonce(const std::string& value) {

  referencenonce_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void BTCWithdrawal::set_referencenonce(std::string&& value) {

  referencenonce_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vega.BTCWithdrawal.referenceNonce)
}
inline void BTCWithdrawal::set_referencenonce(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  referencenonce_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:vega.BTCWithdrawal.referenceNonce)
}
inline void BTCWithdrawal::set_referencenonce(const char* value,
    size_t size) {

  referencenonce_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vega.BTCWithdrawal.referenceNonce)
}
inline std::string* BTCWithdrawal::_internal_mutable_referencenonce() {

  return referencenonce_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* BTCWithdrawal::release_referencenonce() {
  // @@protoc_insertion_point(field_release:vega.BTCWithdrawal.referenceNonce)
  return referencenonce_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void BTCWithdrawal::set_allocated_referencenonce(std::string* referencenonce) {
  if (referencenonce != nullptr) {

  } else {

  }
  referencenonce_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), referencenonce,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vega.BTCWithdrawal.referenceNonce)
}

// -------------------------------------------------------------------

// BTCEvent

// uint64 index = 1 [json_name = "index"];
inline void BTCEvent::clear_index() {
  index_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 BTCEvent::_internal_index() const {
  return index_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 BTCEvent::index() const {
  // @@protoc_insertion_point(field_get:vega.BTCEvent.index)
  return _internal_index();
}
inline void BTCEvent::_internal_set_index(::PROTOBUF_NAMESPACE_ID::uint64 value) {

  index_ = value;
}
inline void BTCEvent::set_index(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:vega.BTCEvent.index)
}

// uint64 block = 2 [json_name = "block"];
inline void BTCEvent::clear_block() {
  block_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 BTCEvent::_internal_block() const {
  return block_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 BTCEvent::block() const {
  // @@protoc_insertion_point(field_get:vega.BTCEvent.block)
  return _internal_block();
}
inline void BTCEvent::_internal_set_block(::PROTOBUF_NAMESPACE_ID::uint64 value) {

  block_ = value;
}
inline void BTCEvent::set_block(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_block(value);
  // @@protoc_insertion_point(field_set:vega.BTCEvent.block)
}

// .vega.BTCDeposit deposit = 1001 [json_name = "deposit"];
inline bool BTCEvent::_internal_has_deposit() const {
  return action_case() == kDeposit;
}
inline bool BTCEvent::has_deposit() const {
  return _internal_has_deposit();
}
inline void BTCEvent::set_has_deposit() {
  _oneof_case_[0] = kDeposit;
}
inline void BTCEvent::clear_deposit() {
  if (_internal_has_deposit()) {
    if (GetArena() == nullptr) {
      delete action_.deposit_;
    }
    clear_has_action();
  }
}
inline ::vega::BTCDeposit* BTCEvent::release_deposit() {
  // @@protoc_insertion_point(field_release:vega.BTCEvent.deposit)
  if (_internal_has_deposit()) {
    clear_has_action();
      ::vega::BTCDeposit* temp = action_.deposit_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    action_.deposit_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vega::BTCDeposit& BTCEvent::_internal_deposit() const {
  return _internal_has_deposit()
      ? *action_.deposit_
      : reinterpret_cast< ::vega::BTCDeposit&>(::vega::_BTCDeposit_default_instance_);
}
inline const ::vega::BTCDeposit& BTCEvent::deposit() const {
  // @@protoc_insertion_point(field_get:vega.BTCEvent.deposit)
  return _internal_deposit();
}
inline ::vega::BTCDeposit* BTCEvent::unsafe_arena_release_deposit() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vega.BTCEvent.deposit)
  if (_internal_has_deposit()) {
    clear_has_action();
    ::vega::BTCDeposit* temp = action_.deposit_;
    action_.deposit_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BTCEvent::unsafe_arena_set_allocated_deposit(::vega::BTCDeposit* deposit) {
  clear_action();
  if (deposit) {
    set_has_deposit();
    action_.deposit_ = deposit;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vega.BTCEvent.deposit)
}
inline ::vega::BTCDeposit* BTCEvent::_internal_mutable_deposit() {
  if (!_internal_has_deposit()) {
    clear_action();
    set_has_deposit();
    action_.deposit_ = CreateMaybeMessage< ::vega::BTCDeposit >(GetArena());
  }
  return action_.deposit_;
}
inline ::vega::BTCDeposit* BTCEvent::mutable_deposit() {
  // @@protoc_insertion_point(field_mutable:vega.BTCEvent.deposit)
  return _internal_mutable_deposit();
}

// .vega.BTCWithdrawal withdrawal = 1002 [json_name = "withdrawal"];
inline bool BTCEvent::_internal_has_withdrawal() const {
  return action_case() == kWithdrawal;
}
inline bool BTCEvent::has_withdrawal() const {
  return _internal_has_withdrawal();
}
inline void BTCEvent::set_has_withdrawal() {
  _oneof_case_[0] = kWithdrawal;
}
inline void BTCEvent::clear_withdrawal() {
  if (_internal_has_withdrawal()) {
    if (GetArena() == nullptr) {
      delete action_.withdrawal_;
    }
    clear_has_action();
  }
}
inline ::vega::BTCWithdrawal* BTCEvent::release_withdrawal() {
  // @@protoc_insertion_point(field_release:vega.BTCEvent.withdrawal)
  if (_internal_has_withdrawal()) {
    clear_has_action();
      ::vega::BTCWithdrawal* temp = action_.withdrawal_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    action_.withdrawal_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vega::BTCWithdrawal& BTCEvent::_internal_withdrawal() const {
  return _internal_has_withdrawal()
      ? *action_.withdrawal_
      : reinterpret_cast< ::vega::BTCWithdrawal&>(::vega::_BTCWithdrawal_default_instance_);
}
inline const ::vega::BTCWithdrawal& BTCEvent::withdrawal() const {
  // @@protoc_insertion_point(field_get:vega.BTCEvent.withdrawal)
  return _internal_withdrawal();
}
inline ::vega::BTCWithdrawal* BTCEvent::unsafe_arena_release_withdrawal() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vega.BTCEvent.withdrawal)
  if (_internal_has_withdrawal()) {
    clear_has_action();
    ::vega::BTCWithdrawal* temp = action_.withdrawal_;
    action_.withdrawal_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BTCEvent::unsafe_arena_set_allocated_withdrawal(::vega::BTCWithdrawal* withdrawal) {
  clear_action();
  if (withdrawal) {
    set_has_withdrawal();
    action_.withdrawal_ = withdrawal;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vega.BTCEvent.withdrawal)
}
inline ::vega::BTCWithdrawal* BTCEvent::_internal_mutable_withdrawal() {
  if (!_internal_has_withdrawal()) {
    clear_action();
    set_has_withdrawal();
    action_.withdrawal_ = CreateMaybeMessage< ::vega::BTCWithdrawal >(GetArena());
  }
  return action_.withdrawal_;
}
inline ::vega::BTCWithdrawal* BTCEvent::mutable_withdrawal() {
  // @@protoc_insertion_point(field_mutable:vega.BTCEvent.withdrawal)
  return _internal_mutable_withdrawal();
}

inline bool BTCEvent::has_action() const {
  return action_case() != ACTION_NOT_SET;
}
inline void BTCEvent::clear_has_action() {
  _oneof_case_[0] = ACTION_NOT_SET;
}
inline BTCEvent::ActionCase BTCEvent::action_case() const {
  return BTCEvent::ActionCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// EthereumAddress

// string address = 1 [json_name = "address"];
inline void EthereumAddress::clear_address() {
  address_.ClearToEmpty();
}
inline const std::string& EthereumAddress::address() const {
  // @@protoc_insertion_point(field_get:vega.EthereumAddress.address)
  return _internal_address();
}
inline void EthereumAddress::set_address(const std::string& value) {
  _internal_set_address(value);
  // @@protoc_insertion_point(field_set:vega.EthereumAddress.address)
}
inline std::string* EthereumAddress::mutable_address() {
  // @@protoc_insertion_point(field_mutable:vega.EthereumAddress.address)
  return _internal_mutable_address();
}
inline const std::string& EthereumAddress::_internal_address() const {
  return address_.Get();
}
inline void EthereumAddress::_internal_set_address(const std::string& value) {

  address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void EthereumAddress::set_address(std::string&& value) {

  address_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vega.EthereumAddress.address)
}
inline void EthereumAddress::set_address(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:vega.EthereumAddress.address)
}
inline void EthereumAddress::set_address(const char* value,
    size_t size) {

  address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vega.EthereumAddress.address)
}
inline std::string* EthereumAddress::_internal_mutable_address() {

  return address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* EthereumAddress::release_address() {
  // @@protoc_insertion_point(field_release:vega.EthereumAddress.address)
  return address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void EthereumAddress::set_allocated_address(std::string* address) {
  if (address != nullptr) {

  } else {

  }
  address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), address,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vega.EthereumAddress.address)
}

// -------------------------------------------------------------------

// BitcoinAddress

// string address = 1 [json_name = "address"];
inline void BitcoinAddress::clear_address() {
  address_.ClearToEmpty();
}
inline const std::string& BitcoinAddress::address() const {
  // @@protoc_insertion_point(field_get:vega.BitcoinAddress.address)
  return _internal_address();
}
inline void BitcoinAddress::set_address(const std::string& value) {
  _internal_set_address(value);
  // @@protoc_insertion_point(field_set:vega.BitcoinAddress.address)
}
inline std::string* BitcoinAddress::mutable_address() {
  // @@protoc_insertion_point(field_mutable:vega.BitcoinAddress.address)
  return _internal_mutable_address();
}
inline const std::string& BitcoinAddress::_internal_address() const {
  return address_.Get();
}
inline void BitcoinAddress::_internal_set_address(const std::string& value) {

  address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void BitcoinAddress::set_address(std::string&& value) {

  address_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vega.BitcoinAddress.address)
}
inline void BitcoinAddress::set_address(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:vega.BitcoinAddress.address)
}
inline void BitcoinAddress::set_address(const char* value,
    size_t size) {

  address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vega.BitcoinAddress.address)
}
inline std::string* BitcoinAddress::_internal_mutable_address() {

  return address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* BitcoinAddress::release_address() {
  // @@protoc_insertion_point(field_release:vega.BitcoinAddress.address)
  return address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void BitcoinAddress::set_allocated_address(std::string* address) {
  if (address != nullptr) {

  } else {

  }
  address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), address,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vega.BitcoinAddress.address)
}

// -------------------------------------------------------------------

// Identifier

// .vega.EthereumAddress ethereumAddress = 1 [json_name = "ethereumAddress"];
inline bool Identifier::_internal_has_ethereumaddress() const {
  return identifier_case() == kEthereumAddress;
}
inline bool Identifier::has_ethereumaddress() const {
  return _internal_has_ethereumaddress();
}
inline void Identifier::set_has_ethereumaddress() {
  _oneof_case_[0] = kEthereumAddress;
}
inline void Identifier::clear_ethereumaddress() {
  if (_internal_has_ethereumaddress()) {
    if (GetArena() == nullptr) {
      delete identifier_.ethereumaddress_;
    }
    clear_has_identifier();
  }
}
inline ::vega::EthereumAddress* Identifier::release_ethereumaddress() {
  // @@protoc_insertion_point(field_release:vega.Identifier.ethereumAddress)
  if (_internal_has_ethereumaddress()) {
    clear_has_identifier();
      ::vega::EthereumAddress* temp = identifier_.ethereumaddress_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    identifier_.ethereumaddress_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vega::EthereumAddress& Identifier::_internal_ethereumaddress() const {
  return _internal_has_ethereumaddress()
      ? *identifier_.ethereumaddress_
      : reinterpret_cast< ::vega::EthereumAddress&>(::vega::_EthereumAddress_default_instance_);
}
inline const ::vega::EthereumAddress& Identifier::ethereumaddress() const {
  // @@protoc_insertion_point(field_get:vega.Identifier.ethereumAddress)
  return _internal_ethereumaddress();
}
inline ::vega::EthereumAddress* Identifier::unsafe_arena_release_ethereumaddress() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vega.Identifier.ethereumAddress)
  if (_internal_has_ethereumaddress()) {
    clear_has_identifier();
    ::vega::EthereumAddress* temp = identifier_.ethereumaddress_;
    identifier_.ethereumaddress_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Identifier::unsafe_arena_set_allocated_ethereumaddress(::vega::EthereumAddress* ethereumaddress) {
  clear_identifier();
  if (ethereumaddress) {
    set_has_ethereumaddress();
    identifier_.ethereumaddress_ = ethereumaddress;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vega.Identifier.ethereumAddress)
}
inline ::vega::EthereumAddress* Identifier::_internal_mutable_ethereumaddress() {
  if (!_internal_has_ethereumaddress()) {
    clear_identifier();
    set_has_ethereumaddress();
    identifier_.ethereumaddress_ = CreateMaybeMessage< ::vega::EthereumAddress >(GetArena());
  }
  return identifier_.ethereumaddress_;
}
inline ::vega::EthereumAddress* Identifier::mutable_ethereumaddress() {
  // @@protoc_insertion_point(field_mutable:vega.Identifier.ethereumAddress)
  return _internal_mutable_ethereumaddress();
}

// .vega.BitcoinAddress bitcoinAddress = 2 [json_name = "bitcoinAddress"];
inline bool Identifier::_internal_has_bitcoinaddress() const {
  return identifier_case() == kBitcoinAddress;
}
inline bool Identifier::has_bitcoinaddress() const {
  return _internal_has_bitcoinaddress();
}
inline void Identifier::set_has_bitcoinaddress() {
  _oneof_case_[0] = kBitcoinAddress;
}
inline void Identifier::clear_bitcoinaddress() {
  if (_internal_has_bitcoinaddress()) {
    if (GetArena() == nullptr) {
      delete identifier_.bitcoinaddress_;
    }
    clear_has_identifier();
  }
}
inline ::vega::BitcoinAddress* Identifier::release_bitcoinaddress() {
  // @@protoc_insertion_point(field_release:vega.Identifier.bitcoinAddress)
  if (_internal_has_bitcoinaddress()) {
    clear_has_identifier();
      ::vega::BitcoinAddress* temp = identifier_.bitcoinaddress_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    identifier_.bitcoinaddress_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vega::BitcoinAddress& Identifier::_internal_bitcoinaddress() const {
  return _internal_has_bitcoinaddress()
      ? *identifier_.bitcoinaddress_
      : reinterpret_cast< ::vega::BitcoinAddress&>(::vega::_BitcoinAddress_default_instance_);
}
inline const ::vega::BitcoinAddress& Identifier::bitcoinaddress() const {
  // @@protoc_insertion_point(field_get:vega.Identifier.bitcoinAddress)
  return _internal_bitcoinaddress();
}
inline ::vega::BitcoinAddress* Identifier::unsafe_arena_release_bitcoinaddress() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vega.Identifier.bitcoinAddress)
  if (_internal_has_bitcoinaddress()) {
    clear_has_identifier();
    ::vega::BitcoinAddress* temp = identifier_.bitcoinaddress_;
    identifier_.bitcoinaddress_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Identifier::unsafe_arena_set_allocated_bitcoinaddress(::vega::BitcoinAddress* bitcoinaddress) {
  clear_identifier();
  if (bitcoinaddress) {
    set_has_bitcoinaddress();
    identifier_.bitcoinaddress_ = bitcoinaddress;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vega.Identifier.bitcoinAddress)
}
inline ::vega::BitcoinAddress* Identifier::_internal_mutable_bitcoinaddress() {
  if (!_internal_has_bitcoinaddress()) {
    clear_identifier();
    set_has_bitcoinaddress();
    identifier_.bitcoinaddress_ = CreateMaybeMessage< ::vega::BitcoinAddress >(GetArena());
  }
  return identifier_.bitcoinaddress_;
}
inline ::vega::BitcoinAddress* Identifier::mutable_bitcoinaddress() {
  // @@protoc_insertion_point(field_mutable:vega.Identifier.bitcoinAddress)
  return _internal_mutable_bitcoinaddress();
}

inline bool Identifier::has_identifier() const {
  return identifier_case() != IDENTIFIER_NOT_SET;
}
inline void Identifier::clear_has_identifier() {
  _oneof_case_[0] = IDENTIFIER_NOT_SET;
}
inline Identifier::IdentifierCase Identifier::identifier_case() const {
  return Identifier::IdentifierCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// AddValidator

// .vega.Identifier id = 1 [json_name = "id"];
inline bool AddValidator::_internal_has_id() const {
  return this != internal_default_instance() && id_ != nullptr;
}
inline bool AddValidator::has_id() const {
  return _internal_has_id();
}
inline void AddValidator::clear_id() {
  if (GetArena() == nullptr && id_ != nullptr) {
    delete id_;
  }
  id_ = nullptr;
}
inline const ::vega::Identifier& AddValidator::_internal_id() const {
  const ::vega::Identifier* p = id_;
  return p != nullptr ? *p : reinterpret_cast<const ::vega::Identifier&>(
      ::vega::_Identifier_default_instance_);
}
inline const ::vega::Identifier& AddValidator::id() const {
  // @@protoc_insertion_point(field_get:vega.AddValidator.id)
  return _internal_id();
}
inline void AddValidator::unsafe_arena_set_allocated_id(
    ::vega::Identifier* id) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(id_);
  }
  id_ = id;
  if (id) {

  } else {

  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vega.AddValidator.id)
}
inline ::vega::Identifier* AddValidator::release_id() {

  ::vega::Identifier* temp = id_;
  id_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::vega::Identifier* AddValidator::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_release:vega.AddValidator.id)

  ::vega::Identifier* temp = id_;
  id_ = nullptr;
  return temp;
}
inline ::vega::Identifier* AddValidator::_internal_mutable_id() {

  if (id_ == nullptr) {
    auto* p = CreateMaybeMessage<::vega::Identifier>(GetArena());
    id_ = p;
  }
  return id_;
}
inline ::vega::Identifier* AddValidator::mutable_id() {
  // @@protoc_insertion_point(field_mutable:vega.AddValidator.id)
  return _internal_mutable_id();
}
inline void AddValidator::set_allocated_id(::vega::Identifier* id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete id_;
  }
  if (id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(id);
    if (message_arena != submessage_arena) {
      id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, id, submessage_arena);
    }

  } else {

  }
  id_ = id;
  // @@protoc_insertion_point(field_set_allocated:vega.AddValidator.id)
}

// -------------------------------------------------------------------

// RemoveValidator

// .vega.Identifier id = 1 [json_name = "id"];
inline bool RemoveValidator::_internal_has_id() const {
  return this != internal_default_instance() && id_ != nullptr;
}
inline bool RemoveValidator::has_id() const {
  return _internal_has_id();
}
inline void RemoveValidator::clear_id() {
  if (GetArena() == nullptr && id_ != nullptr) {
    delete id_;
  }
  id_ = nullptr;
}
inline const ::vega::Identifier& RemoveValidator::_internal_id() const {
  const ::vega::Identifier* p = id_;
  return p != nullptr ? *p : reinterpret_cast<const ::vega::Identifier&>(
      ::vega::_Identifier_default_instance_);
}
inline const ::vega::Identifier& RemoveValidator::id() const {
  // @@protoc_insertion_point(field_get:vega.RemoveValidator.id)
  return _internal_id();
}
inline void RemoveValidator::unsafe_arena_set_allocated_id(
    ::vega::Identifier* id) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(id_);
  }
  id_ = id;
  if (id) {

  } else {

  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vega.RemoveValidator.id)
}
inline ::vega::Identifier* RemoveValidator::release_id() {

  ::vega::Identifier* temp = id_;
  id_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::vega::Identifier* RemoveValidator::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_release:vega.RemoveValidator.id)

  ::vega::Identifier* temp = id_;
  id_ = nullptr;
  return temp;
}
inline ::vega::Identifier* RemoveValidator::_internal_mutable_id() {

  if (id_ == nullptr) {
    auto* p = CreateMaybeMessage<::vega::Identifier>(GetArena());
    id_ = p;
  }
  return id_;
}
inline ::vega::Identifier* RemoveValidator::mutable_id() {
  // @@protoc_insertion_point(field_mutable:vega.RemoveValidator.id)
  return _internal_mutable_id();
}
inline void RemoveValidator::set_allocated_id(::vega::Identifier* id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete id_;
  }
  if (id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(id);
    if (message_arena != submessage_arena) {
      id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, id, submessage_arena);
    }

  } else {

  }
  id_ = id;
  // @@protoc_insertion_point(field_set_allocated:vega.RemoveValidator.id)
}

// -------------------------------------------------------------------

// ValidatorEvent

// string sourceID = 1 [json_name = "sourceID"];
inline void ValidatorEvent::clear_sourceid() {
  sourceid_.ClearToEmpty();
}
inline const std::string& ValidatorEvent::sourceid() const {
  // @@protoc_insertion_point(field_get:vega.ValidatorEvent.sourceID)
  return _internal_sourceid();
}
inline void ValidatorEvent::set_sourceid(const std::string& value) {
  _internal_set_sourceid(value);
  // @@protoc_insertion_point(field_set:vega.ValidatorEvent.sourceID)
}
inline std::string* ValidatorEvent::mutable_sourceid() {
  // @@protoc_insertion_point(field_mutable:vega.ValidatorEvent.sourceID)
  return _internal_mutable_sourceid();
}
inline const std::string& ValidatorEvent::_internal_sourceid() const {
  return sourceid_.Get();
}
inline void ValidatorEvent::_internal_set_sourceid(const std::string& value) {

  sourceid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void ValidatorEvent::set_sourceid(std::string&& value) {

  sourceid_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vega.ValidatorEvent.sourceID)
}
inline void ValidatorEvent::set_sourceid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  sourceid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:vega.ValidatorEvent.sourceID)
}
inline void ValidatorEvent::set_sourceid(const char* value,
    size_t size) {

  sourceid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vega.ValidatorEvent.sourceID)
}
inline std::string* ValidatorEvent::_internal_mutable_sourceid() {

  return sourceid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* ValidatorEvent::release_sourceid() {
  // @@protoc_insertion_point(field_release:vega.ValidatorEvent.sourceID)
  return sourceid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ValidatorEvent::set_allocated_sourceid(std::string* sourceid) {
  if (sourceid != nullptr) {

  } else {

  }
  sourceid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sourceid,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vega.ValidatorEvent.sourceID)
}

// .vega.AddValidator add = 1001 [json_name = "add"];
inline bool ValidatorEvent::_internal_has_add() const {
  return action_case() == kAdd;
}
inline bool ValidatorEvent::has_add() const {
  return _internal_has_add();
}
inline void ValidatorEvent::set_has_add() {
  _oneof_case_[0] = kAdd;
}
inline void ValidatorEvent::clear_add() {
  if (_internal_has_add()) {
    if (GetArena() == nullptr) {
      delete action_.add_;
    }
    clear_has_action();
  }
}
inline ::vega::AddValidator* ValidatorEvent::release_add() {
  // @@protoc_insertion_point(field_release:vega.ValidatorEvent.add)
  if (_internal_has_add()) {
    clear_has_action();
      ::vega::AddValidator* temp = action_.add_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    action_.add_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vega::AddValidator& ValidatorEvent::_internal_add() const {
  return _internal_has_add()
      ? *action_.add_
      : reinterpret_cast< ::vega::AddValidator&>(::vega::_AddValidator_default_instance_);
}
inline const ::vega::AddValidator& ValidatorEvent::add() const {
  // @@protoc_insertion_point(field_get:vega.ValidatorEvent.add)
  return _internal_add();
}
inline ::vega::AddValidator* ValidatorEvent::unsafe_arena_release_add() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vega.ValidatorEvent.add)
  if (_internal_has_add()) {
    clear_has_action();
    ::vega::AddValidator* temp = action_.add_;
    action_.add_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ValidatorEvent::unsafe_arena_set_allocated_add(::vega::AddValidator* add) {
  clear_action();
  if (add) {
    set_has_add();
    action_.add_ = add;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vega.ValidatorEvent.add)
}
inline ::vega::AddValidator* ValidatorEvent::_internal_mutable_add() {
  if (!_internal_has_add()) {
    clear_action();
    set_has_add();
    action_.add_ = CreateMaybeMessage< ::vega::AddValidator >(GetArena());
  }
  return action_.add_;
}
inline ::vega::AddValidator* ValidatorEvent::mutable_add() {
  // @@protoc_insertion_point(field_mutable:vega.ValidatorEvent.add)
  return _internal_mutable_add();
}

// .vega.RemoveValidator rm = 1002 [json_name = "rm"];
inline bool ValidatorEvent::_internal_has_rm() const {
  return action_case() == kRm;
}
inline bool ValidatorEvent::has_rm() const {
  return _internal_has_rm();
}
inline void ValidatorEvent::set_has_rm() {
  _oneof_case_[0] = kRm;
}
inline void ValidatorEvent::clear_rm() {
  if (_internal_has_rm()) {
    if (GetArena() == nullptr) {
      delete action_.rm_;
    }
    clear_has_action();
  }
}
inline ::vega::RemoveValidator* ValidatorEvent::release_rm() {
  // @@protoc_insertion_point(field_release:vega.ValidatorEvent.rm)
  if (_internal_has_rm()) {
    clear_has_action();
      ::vega::RemoveValidator* temp = action_.rm_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    action_.rm_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vega::RemoveValidator& ValidatorEvent::_internal_rm() const {
  return _internal_has_rm()
      ? *action_.rm_
      : reinterpret_cast< ::vega::RemoveValidator&>(::vega::_RemoveValidator_default_instance_);
}
inline const ::vega::RemoveValidator& ValidatorEvent::rm() const {
  // @@protoc_insertion_point(field_get:vega.ValidatorEvent.rm)
  return _internal_rm();
}
inline ::vega::RemoveValidator* ValidatorEvent::unsafe_arena_release_rm() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vega.ValidatorEvent.rm)
  if (_internal_has_rm()) {
    clear_has_action();
    ::vega::RemoveValidator* temp = action_.rm_;
    action_.rm_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ValidatorEvent::unsafe_arena_set_allocated_rm(::vega::RemoveValidator* rm) {
  clear_action();
  if (rm) {
    set_has_rm();
    action_.rm_ = rm;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vega.ValidatorEvent.rm)
}
inline ::vega::RemoveValidator* ValidatorEvent::_internal_mutable_rm() {
  if (!_internal_has_rm()) {
    clear_action();
    set_has_rm();
    action_.rm_ = CreateMaybeMessage< ::vega::RemoveValidator >(GetArena());
  }
  return action_.rm_;
}
inline ::vega::RemoveValidator* ValidatorEvent::mutable_rm() {
  // @@protoc_insertion_point(field_mutable:vega.ValidatorEvent.rm)
  return _internal_mutable_rm();
}

inline bool ValidatorEvent::has_action() const {
  return action_case() != ACTION_NOT_SET;
}
inline void ValidatorEvent::clear_has_action() {
  _oneof_case_[0] = ACTION_NOT_SET;
}
inline ValidatorEvent::ActionCase ValidatorEvent::action_case() const {
  return ValidatorEvent::ActionCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ChainEvent

// string txID = 1 [json_name = "txID"];
inline void ChainEvent::clear_txid() {
  txid_.ClearToEmpty();
}
inline const std::string& ChainEvent::txid() const {
  // @@protoc_insertion_point(field_get:vega.ChainEvent.txID)
  return _internal_txid();
}
inline void ChainEvent::set_txid(const std::string& value) {
  _internal_set_txid(value);
  // @@protoc_insertion_point(field_set:vega.ChainEvent.txID)
}
inline std::string* ChainEvent::mutable_txid() {
  // @@protoc_insertion_point(field_mutable:vega.ChainEvent.txID)
  return _internal_mutable_txid();
}
inline const std::string& ChainEvent::_internal_txid() const {
  return txid_.Get();
}
inline void ChainEvent::_internal_set_txid(const std::string& value) {

  txid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void ChainEvent::set_txid(std::string&& value) {

  txid_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vega.ChainEvent.txID)
}
inline void ChainEvent::set_txid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  txid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:vega.ChainEvent.txID)
}
inline void ChainEvent::set_txid(const char* value,
    size_t size) {

  txid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vega.ChainEvent.txID)
}
inline std::string* ChainEvent::_internal_mutable_txid() {

  return txid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* ChainEvent::release_txid() {
  // @@protoc_insertion_point(field_release:vega.ChainEvent.txID)
  return txid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ChainEvent::set_allocated_txid(std::string* txid) {
  if (txid != nullptr) {

  } else {

  }
  txid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), txid,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vega.ChainEvent.txID)
}

// uint64 nonce = 2 [json_name = "nonce"];
inline void ChainEvent::clear_nonce() {
  nonce_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ChainEvent::_internal_nonce() const {
  return nonce_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ChainEvent::nonce() const {
  // @@protoc_insertion_point(field_get:vega.ChainEvent.nonce)
  return _internal_nonce();
}
inline void ChainEvent::_internal_set_nonce(::PROTOBUF_NAMESPACE_ID::uint64 value) {

  nonce_ = value;
}
inline void ChainEvent::set_nonce(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_nonce(value);
  // @@protoc_insertion_point(field_set:vega.ChainEvent.nonce)
}

// .vega.BuiltinAssetEvent builtin = 1001 [json_name = "builtin"];
inline bool ChainEvent::_internal_has_builtin() const {
  return event_case() == kBuiltin;
}
inline bool ChainEvent::has_builtin() const {
  return _internal_has_builtin();
}
inline void ChainEvent::set_has_builtin() {
  _oneof_case_[0] = kBuiltin;
}
inline void ChainEvent::clear_builtin() {
  if (_internal_has_builtin()) {
    if (GetArena() == nullptr) {
      delete event_.builtin_;
    }
    clear_has_event();
  }
}
inline ::vega::BuiltinAssetEvent* ChainEvent::release_builtin() {
  // @@protoc_insertion_point(field_release:vega.ChainEvent.builtin)
  if (_internal_has_builtin()) {
    clear_has_event();
      ::vega::BuiltinAssetEvent* temp = event_.builtin_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    event_.builtin_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vega::BuiltinAssetEvent& ChainEvent::_internal_builtin() const {
  return _internal_has_builtin()
      ? *event_.builtin_
      : reinterpret_cast< ::vega::BuiltinAssetEvent&>(::vega::_BuiltinAssetEvent_default_instance_);
}
inline const ::vega::BuiltinAssetEvent& ChainEvent::builtin() const {
  // @@protoc_insertion_point(field_get:vega.ChainEvent.builtin)
  return _internal_builtin();
}
inline ::vega::BuiltinAssetEvent* ChainEvent::unsafe_arena_release_builtin() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vega.ChainEvent.builtin)
  if (_internal_has_builtin()) {
    clear_has_event();
    ::vega::BuiltinAssetEvent* temp = event_.builtin_;
    event_.builtin_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ChainEvent::unsafe_arena_set_allocated_builtin(::vega::BuiltinAssetEvent* builtin) {
  clear_event();
  if (builtin) {
    set_has_builtin();
    event_.builtin_ = builtin;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vega.ChainEvent.builtin)
}
inline ::vega::BuiltinAssetEvent* ChainEvent::_internal_mutable_builtin() {
  if (!_internal_has_builtin()) {
    clear_event();
    set_has_builtin();
    event_.builtin_ = CreateMaybeMessage< ::vega::BuiltinAssetEvent >(GetArena());
  }
  return event_.builtin_;
}
inline ::vega::BuiltinAssetEvent* ChainEvent::mutable_builtin() {
  // @@protoc_insertion_point(field_mutable:vega.ChainEvent.builtin)
  return _internal_mutable_builtin();
}

// .vega.ERC20Event erc20 = 1002 [json_name = "erc20"];
inline bool ChainEvent::_internal_has_erc20() const {
  return event_case() == kErc20;
}
inline bool ChainEvent::has_erc20() const {
  return _internal_has_erc20();
}
inline void ChainEvent::set_has_erc20() {
  _oneof_case_[0] = kErc20;
}
inline void ChainEvent::clear_erc20() {
  if (_internal_has_erc20()) {
    if (GetArena() == nullptr) {
      delete event_.erc20_;
    }
    clear_has_event();
  }
}
inline ::vega::ERC20Event* ChainEvent::release_erc20() {
  // @@protoc_insertion_point(field_release:vega.ChainEvent.erc20)
  if (_internal_has_erc20()) {
    clear_has_event();
      ::vega::ERC20Event* temp = event_.erc20_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    event_.erc20_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vega::ERC20Event& ChainEvent::_internal_erc20() const {
  return _internal_has_erc20()
      ? *event_.erc20_
      : reinterpret_cast< ::vega::ERC20Event&>(::vega::_ERC20Event_default_instance_);
}
inline const ::vega::ERC20Event& ChainEvent::erc20() const {
  // @@protoc_insertion_point(field_get:vega.ChainEvent.erc20)
  return _internal_erc20();
}
inline ::vega::ERC20Event* ChainEvent::unsafe_arena_release_erc20() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vega.ChainEvent.erc20)
  if (_internal_has_erc20()) {
    clear_has_event();
    ::vega::ERC20Event* temp = event_.erc20_;
    event_.erc20_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ChainEvent::unsafe_arena_set_allocated_erc20(::vega::ERC20Event* erc20) {
  clear_event();
  if (erc20) {
    set_has_erc20();
    event_.erc20_ = erc20;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vega.ChainEvent.erc20)
}
inline ::vega::ERC20Event* ChainEvent::_internal_mutable_erc20() {
  if (!_internal_has_erc20()) {
    clear_event();
    set_has_erc20();
    event_.erc20_ = CreateMaybeMessage< ::vega::ERC20Event >(GetArena());
  }
  return event_.erc20_;
}
inline ::vega::ERC20Event* ChainEvent::mutable_erc20() {
  // @@protoc_insertion_point(field_mutable:vega.ChainEvent.erc20)
  return _internal_mutable_erc20();
}

// .vega.BTCEvent btc = 1003 [json_name = "btc"];
inline bool ChainEvent::_internal_has_btc() const {
  return event_case() == kBtc;
}
inline bool ChainEvent::has_btc() const {
  return _internal_has_btc();
}
inline void ChainEvent::set_has_btc() {
  _oneof_case_[0] = kBtc;
}
inline void ChainEvent::clear_btc() {
  if (_internal_has_btc()) {
    if (GetArena() == nullptr) {
      delete event_.btc_;
    }
    clear_has_event();
  }
}
inline ::vega::BTCEvent* ChainEvent::release_btc() {
  // @@protoc_insertion_point(field_release:vega.ChainEvent.btc)
  if (_internal_has_btc()) {
    clear_has_event();
      ::vega::BTCEvent* temp = event_.btc_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    event_.btc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vega::BTCEvent& ChainEvent::_internal_btc() const {
  return _internal_has_btc()
      ? *event_.btc_
      : reinterpret_cast< ::vega::BTCEvent&>(::vega::_BTCEvent_default_instance_);
}
inline const ::vega::BTCEvent& ChainEvent::btc() const {
  // @@protoc_insertion_point(field_get:vega.ChainEvent.btc)
  return _internal_btc();
}
inline ::vega::BTCEvent* ChainEvent::unsafe_arena_release_btc() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vega.ChainEvent.btc)
  if (_internal_has_btc()) {
    clear_has_event();
    ::vega::BTCEvent* temp = event_.btc_;
    event_.btc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ChainEvent::unsafe_arena_set_allocated_btc(::vega::BTCEvent* btc) {
  clear_event();
  if (btc) {
    set_has_btc();
    event_.btc_ = btc;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vega.ChainEvent.btc)
}
inline ::vega::BTCEvent* ChainEvent::_internal_mutable_btc() {
  if (!_internal_has_btc()) {
    clear_event();
    set_has_btc();
    event_.btc_ = CreateMaybeMessage< ::vega::BTCEvent >(GetArena());
  }
  return event_.btc_;
}
inline ::vega::BTCEvent* ChainEvent::mutable_btc() {
  // @@protoc_insertion_point(field_mutable:vega.ChainEvent.btc)
  return _internal_mutable_btc();
}

// .vega.ValidatorEvent validator = 1004 [json_name = "validator"];
inline bool ChainEvent::_internal_has_validator() const {
  return event_case() == kValidator;
}
inline bool ChainEvent::has_validator() const {
  return _internal_has_validator();
}
inline void ChainEvent::set_has_validator() {
  _oneof_case_[0] = kValidator;
}
inline void ChainEvent::clear_validator() {
  if (_internal_has_validator()) {
    if (GetArena() == nullptr) {
      delete event_.validator_;
    }
    clear_has_event();
  }
}
inline ::vega::ValidatorEvent* ChainEvent::release_validator() {
  // @@protoc_insertion_point(field_release:vega.ChainEvent.validator)
  if (_internal_has_validator()) {
    clear_has_event();
      ::vega::ValidatorEvent* temp = event_.validator_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    event_.validator_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vega::ValidatorEvent& ChainEvent::_internal_validator() const {
  return _internal_has_validator()
      ? *event_.validator_
      : reinterpret_cast< ::vega::ValidatorEvent&>(::vega::_ValidatorEvent_default_instance_);
}
inline const ::vega::ValidatorEvent& ChainEvent::validator() const {
  // @@protoc_insertion_point(field_get:vega.ChainEvent.validator)
  return _internal_validator();
}
inline ::vega::ValidatorEvent* ChainEvent::unsafe_arena_release_validator() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vega.ChainEvent.validator)
  if (_internal_has_validator()) {
    clear_has_event();
    ::vega::ValidatorEvent* temp = event_.validator_;
    event_.validator_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ChainEvent::unsafe_arena_set_allocated_validator(::vega::ValidatorEvent* validator) {
  clear_event();
  if (validator) {
    set_has_validator();
    event_.validator_ = validator;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vega.ChainEvent.validator)
}
inline ::vega::ValidatorEvent* ChainEvent::_internal_mutable_validator() {
  if (!_internal_has_validator()) {
    clear_event();
    set_has_validator();
    event_.validator_ = CreateMaybeMessage< ::vega::ValidatorEvent >(GetArena());
  }
  return event_.validator_;
}
inline ::vega::ValidatorEvent* ChainEvent::mutable_validator() {
  // @@protoc_insertion_point(field_mutable:vega.ChainEvent.validator)
  return _internal_mutable_validator();
}

inline bool ChainEvent::has_event() const {
  return event_case() != EVENT_NOT_SET;
}
inline void ChainEvent::clear_has_event() {
  _oneof_case_[0] = EVENT_NOT_SET;
}
inline ChainEvent::EventCase ChainEvent::event_case() const {
  return ChainEvent::EventCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace vega

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_chain_5fevents_2eproto

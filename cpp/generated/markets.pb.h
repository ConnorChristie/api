// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: markets.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_markets_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_markets_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3014000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3014000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "github.com/mwitkow/go-proto-validators/validator.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_markets_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_markets_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[21]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_markets_2eproto;
namespace vega {
class AuctionDuration;
class AuctionDurationDefaultTypeInternal;
extern AuctionDurationDefaultTypeInternal _AuctionDuration_default_instance_;
class ContinuousTrading;
class ContinuousTradingDefaultTypeInternal;
extern ContinuousTradingDefaultTypeInternal _ContinuousTrading_default_instance_;
class DiscreteTrading;
class DiscreteTradingDefaultTypeInternal;
extern DiscreteTradingDefaultTypeInternal _DiscreteTrading_default_instance_;
class EthereumEvent;
class EthereumEventDefaultTypeInternal;
extern EthereumEventDefaultTypeInternal _EthereumEvent_default_instance_;
class FeeFactors;
class FeeFactorsDefaultTypeInternal;
extern FeeFactorsDefaultTypeInternal _FeeFactors_default_instance_;
class Fees;
class FeesDefaultTypeInternal;
extern FeesDefaultTypeInternal _Fees_default_instance_;
class Future;
class FutureDefaultTypeInternal;
extern FutureDefaultTypeInternal _Future_default_instance_;
class Instrument;
class InstrumentDefaultTypeInternal;
extern InstrumentDefaultTypeInternal _Instrument_default_instance_;
class InstrumentMetadata;
class InstrumentMetadataDefaultTypeInternal;
extern InstrumentMetadataDefaultTypeInternal _InstrumentMetadata_default_instance_;
class LogNormalModelParams;
class LogNormalModelParamsDefaultTypeInternal;
extern LogNormalModelParamsDefaultTypeInternal _LogNormalModelParams_default_instance_;
class LogNormalRiskModel;
class LogNormalRiskModelDefaultTypeInternal;
extern LogNormalRiskModelDefaultTypeInternal _LogNormalRiskModel_default_instance_;
class MarginCalculator;
class MarginCalculatorDefaultTypeInternal;
extern MarginCalculatorDefaultTypeInternal _MarginCalculator_default_instance_;
class Market;
class MarketDefaultTypeInternal;
extern MarketDefaultTypeInternal _Market_default_instance_;
class PriceMonitoringParameters;
class PriceMonitoringParametersDefaultTypeInternal;
extern PriceMonitoringParametersDefaultTypeInternal _PriceMonitoringParameters_default_instance_;
class PriceMonitoringSettings;
class PriceMonitoringSettingsDefaultTypeInternal;
extern PriceMonitoringSettingsDefaultTypeInternal _PriceMonitoringSettings_default_instance_;
class PriceMonitoringTrigger;
class PriceMonitoringTriggerDefaultTypeInternal;
extern PriceMonitoringTriggerDefaultTypeInternal _PriceMonitoringTrigger_default_instance_;
class ScalingFactors;
class ScalingFactorsDefaultTypeInternal;
extern ScalingFactorsDefaultTypeInternal _ScalingFactors_default_instance_;
class SimpleModelParams;
class SimpleModelParamsDefaultTypeInternal;
extern SimpleModelParamsDefaultTypeInternal _SimpleModelParams_default_instance_;
class SimpleRiskModel;
class SimpleRiskModelDefaultTypeInternal;
extern SimpleRiskModelDefaultTypeInternal _SimpleRiskModel_default_instance_;
class TargetStakeParameters;
class TargetStakeParametersDefaultTypeInternal;
extern TargetStakeParametersDefaultTypeInternal _TargetStakeParameters_default_instance_;
class TradableInstrument;
class TradableInstrumentDefaultTypeInternal;
extern TradableInstrumentDefaultTypeInternal _TradableInstrument_default_instance_;
}  // namespace vega
PROTOBUF_NAMESPACE_OPEN
template<> ::vega::AuctionDuration* Arena::CreateMaybeMessage<::vega::AuctionDuration>(Arena*);
template<> ::vega::ContinuousTrading* Arena::CreateMaybeMessage<::vega::ContinuousTrading>(Arena*);
template<> ::vega::DiscreteTrading* Arena::CreateMaybeMessage<::vega::DiscreteTrading>(Arena*);
template<> ::vega::EthereumEvent* Arena::CreateMaybeMessage<::vega::EthereumEvent>(Arena*);
template<> ::vega::FeeFactors* Arena::CreateMaybeMessage<::vega::FeeFactors>(Arena*);
template<> ::vega::Fees* Arena::CreateMaybeMessage<::vega::Fees>(Arena*);
template<> ::vega::Future* Arena::CreateMaybeMessage<::vega::Future>(Arena*);
template<> ::vega::Instrument* Arena::CreateMaybeMessage<::vega::Instrument>(Arena*);
template<> ::vega::InstrumentMetadata* Arena::CreateMaybeMessage<::vega::InstrumentMetadata>(Arena*);
template<> ::vega::LogNormalModelParams* Arena::CreateMaybeMessage<::vega::LogNormalModelParams>(Arena*);
template<> ::vega::LogNormalRiskModel* Arena::CreateMaybeMessage<::vega::LogNormalRiskModel>(Arena*);
template<> ::vega::MarginCalculator* Arena::CreateMaybeMessage<::vega::MarginCalculator>(Arena*);
template<> ::vega::Market* Arena::CreateMaybeMessage<::vega::Market>(Arena*);
template<> ::vega::PriceMonitoringParameters* Arena::CreateMaybeMessage<::vega::PriceMonitoringParameters>(Arena*);
template<> ::vega::PriceMonitoringSettings* Arena::CreateMaybeMessage<::vega::PriceMonitoringSettings>(Arena*);
template<> ::vega::PriceMonitoringTrigger* Arena::CreateMaybeMessage<::vega::PriceMonitoringTrigger>(Arena*);
template<> ::vega::ScalingFactors* Arena::CreateMaybeMessage<::vega::ScalingFactors>(Arena*);
template<> ::vega::SimpleModelParams* Arena::CreateMaybeMessage<::vega::SimpleModelParams>(Arena*);
template<> ::vega::SimpleRiskModel* Arena::CreateMaybeMessage<::vega::SimpleRiskModel>(Arena*);
template<> ::vega::TargetStakeParameters* Arena::CreateMaybeMessage<::vega::TargetStakeParameters>(Arena*);
template<> ::vega::TradableInstrument* Arena::CreateMaybeMessage<::vega::TradableInstrument>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace vega {

enum Market_State : int {
  Market_State_STATE_UNSPECIFIED = 0,
  Market_State_STATE_PROPOSED = 1,
  Market_State_STATE_REJECTED = 2,
  Market_State_STATE_PENDING = 3,
  Market_State_STATE_CANCELLED = 4,
  Market_State_STATE_ACTIVE = 5,
  Market_State_STATE_SUSPENDED = 6,
  Market_State_STATE_CLOSED = 7,
  Market_State_STATE_TRADING_TERMINATED = 8,
  Market_State_STATE_SETTLED = 9,
  Market_State_Market_State_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Market_State_Market_State_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Market_State_IsValid(int value);
constexpr Market_State Market_State_State_MIN = Market_State_STATE_UNSPECIFIED;
constexpr Market_State Market_State_State_MAX = Market_State_STATE_SETTLED;
constexpr int Market_State_State_ARRAYSIZE = Market_State_State_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Market_State_descriptor();
template<typename T>
inline const std::string& Market_State_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Market_State>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Market_State_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Market_State_descriptor(), enum_t_value);
}
inline bool Market_State_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Market_State* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Market_State>(
    Market_State_descriptor(), name, value);
}
enum Market_TradingMode : int {
  Market_TradingMode_TRADING_MODE_UNSPECIFIED = 0,
  Market_TradingMode_TRADING_MODE_CONTINUOUS = 1,
  Market_TradingMode_TRADING_MODE_BATCH_AUCTION = 2,
  Market_TradingMode_TRADING_MODE_OPENING_AUCTION = 3,
  Market_TradingMode_TRADING_MODE_MONITORING_AUCTION = 4,
  Market_TradingMode_Market_TradingMode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Market_TradingMode_Market_TradingMode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Market_TradingMode_IsValid(int value);
constexpr Market_TradingMode Market_TradingMode_TradingMode_MIN = Market_TradingMode_TRADING_MODE_UNSPECIFIED;
constexpr Market_TradingMode Market_TradingMode_TradingMode_MAX = Market_TradingMode_TRADING_MODE_MONITORING_AUCTION;
constexpr int Market_TradingMode_TradingMode_ARRAYSIZE = Market_TradingMode_TradingMode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Market_TradingMode_descriptor();
template<typename T>
inline const std::string& Market_TradingMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Market_TradingMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Market_TradingMode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Market_TradingMode_descriptor(), enum_t_value);
}
inline bool Market_TradingMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Market_TradingMode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Market_TradingMode>(
    Market_TradingMode_descriptor(), name, value);
}
// ===================================================================

class AuctionDuration PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vega.AuctionDuration) */ {
 public:
  inline AuctionDuration() : AuctionDuration(nullptr) {}
  virtual ~AuctionDuration();

  AuctionDuration(const AuctionDuration& from);
  AuctionDuration(AuctionDuration&& from) noexcept
    : AuctionDuration() {
    *this = ::std::move(from);
  }

  inline AuctionDuration& operator=(const AuctionDuration& from) {
    CopyFrom(from);
    return *this;
  }
  inline AuctionDuration& operator=(AuctionDuration&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AuctionDuration& default_instance();

  static inline const AuctionDuration* internal_default_instance() {
    return reinterpret_cast<const AuctionDuration*>(
               &_AuctionDuration_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(AuctionDuration& a, AuctionDuration& b) {
    a.Swap(&b);
  }
  inline void Swap(AuctionDuration* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AuctionDuration* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AuctionDuration* New() const final {
    return CreateMaybeMessage<AuctionDuration>(nullptr);
  }

  AuctionDuration* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AuctionDuration>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AuctionDuration& from);
  void MergeFrom(const AuctionDuration& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AuctionDuration* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vega.AuctionDuration";
  }
  protected:
  explicit AuctionDuration(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_markets_2eproto);
    return ::descriptor_table_markets_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDurationFieldNumber = 1,
    kVolumeFieldNumber = 2,
  };
  // int64 duration = 1 [json_name = "duration"];
  void clear_duration();
  ::PROTOBUF_NAMESPACE_ID::int64 duration() const;
  void set_duration(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_duration() const;
  void _internal_set_duration(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // uint64 volume = 2 [json_name = "volume"];
  void clear_volume();
  ::PROTOBUF_NAMESPACE_ID::uint64 volume() const;
  void set_volume(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_volume() const;
  void _internal_set_volume(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:vega.AuctionDuration)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int64 duration_;
  ::PROTOBUF_NAMESPACE_ID::uint64 volume_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_markets_2eproto;
};
// -------------------------------------------------------------------

class ContinuousTrading PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vega.ContinuousTrading) */ {
 public:
  inline ContinuousTrading() : ContinuousTrading(nullptr) {}
  virtual ~ContinuousTrading();

  ContinuousTrading(const ContinuousTrading& from);
  ContinuousTrading(ContinuousTrading&& from) noexcept
    : ContinuousTrading() {
    *this = ::std::move(from);
  }

  inline ContinuousTrading& operator=(const ContinuousTrading& from) {
    CopyFrom(from);
    return *this;
  }
  inline ContinuousTrading& operator=(ContinuousTrading&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ContinuousTrading& default_instance();

  static inline const ContinuousTrading* internal_default_instance() {
    return reinterpret_cast<const ContinuousTrading*>(
               &_ContinuousTrading_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ContinuousTrading& a, ContinuousTrading& b) {
    a.Swap(&b);
  }
  inline void Swap(ContinuousTrading* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ContinuousTrading* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ContinuousTrading* New() const final {
    return CreateMaybeMessage<ContinuousTrading>(nullptr);
  }

  ContinuousTrading* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ContinuousTrading>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ContinuousTrading& from);
  void MergeFrom(const ContinuousTrading& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ContinuousTrading* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vega.ContinuousTrading";
  }
  protected:
  explicit ContinuousTrading(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_markets_2eproto);
    return ::descriptor_table_markets_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTickSizeFieldNumber = 1,
  };
  // string tickSize = 1 [json_name = "tickSize"];
  void clear_ticksize();
  const std::string& ticksize() const;
  void set_ticksize(const std::string& value);
  void set_ticksize(std::string&& value);
  void set_ticksize(const char* value);
  void set_ticksize(const char* value, size_t size);
  std::string* mutable_ticksize();
  std::string* release_ticksize();
  void set_allocated_ticksize(std::string* ticksize);
  private:
  const std::string& _internal_ticksize() const;
  void _internal_set_ticksize(const std::string& value);
  std::string* _internal_mutable_ticksize();
  public:

  // @@protoc_insertion_point(class_scope:vega.ContinuousTrading)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ticksize_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_markets_2eproto;
};
// -------------------------------------------------------------------

class DiscreteTrading PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vega.DiscreteTrading) */ {
 public:
  inline DiscreteTrading() : DiscreteTrading(nullptr) {}
  virtual ~DiscreteTrading();

  DiscreteTrading(const DiscreteTrading& from);
  DiscreteTrading(DiscreteTrading&& from) noexcept
    : DiscreteTrading() {
    *this = ::std::move(from);
  }

  inline DiscreteTrading& operator=(const DiscreteTrading& from) {
    CopyFrom(from);
    return *this;
  }
  inline DiscreteTrading& operator=(DiscreteTrading&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DiscreteTrading& default_instance();

  static inline const DiscreteTrading* internal_default_instance() {
    return reinterpret_cast<const DiscreteTrading*>(
               &_DiscreteTrading_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(DiscreteTrading& a, DiscreteTrading& b) {
    a.Swap(&b);
  }
  inline void Swap(DiscreteTrading* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DiscreteTrading* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DiscreteTrading* New() const final {
    return CreateMaybeMessage<DiscreteTrading>(nullptr);
  }

  DiscreteTrading* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DiscreteTrading>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DiscreteTrading& from);
  void MergeFrom(const DiscreteTrading& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DiscreteTrading* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vega.DiscreteTrading";
  }
  protected:
  explicit DiscreteTrading(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_markets_2eproto);
    return ::descriptor_table_markets_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTickSizeFieldNumber = 2,
    kDurationNsFieldNumber = 1,
  };
  // string tickSize = 2 [json_name = "tickSize"];
  void clear_ticksize();
  const std::string& ticksize() const;
  void set_ticksize(const std::string& value);
  void set_ticksize(std::string&& value);
  void set_ticksize(const char* value);
  void set_ticksize(const char* value, size_t size);
  std::string* mutable_ticksize();
  std::string* release_ticksize();
  void set_allocated_ticksize(std::string* ticksize);
  private:
  const std::string& _internal_ticksize() const;
  void _internal_set_ticksize(const std::string& value);
  std::string* _internal_mutable_ticksize();
  public:

  // int64 durationNs = 1 [json_name = "durationNs", (.validator.field) = {
  void clear_durationns();
  ::PROTOBUF_NAMESPACE_ID::int64 durationns() const;
  void set_durationns(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_durationns() const;
  void _internal_set_durationns(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:vega.DiscreteTrading)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ticksize_;
  ::PROTOBUF_NAMESPACE_ID::int64 durationns_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_markets_2eproto;
};
// -------------------------------------------------------------------

class Future PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vega.Future) */ {
 public:
  inline Future() : Future(nullptr) {}
  virtual ~Future();

  Future(const Future& from);
  Future(Future&& from) noexcept
    : Future() {
    *this = ::std::move(from);
  }

  inline Future& operator=(const Future& from) {
    CopyFrom(from);
    return *this;
  }
  inline Future& operator=(Future&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Future& default_instance();

  enum OracleCase {
    kEthereumEvent = 100,
    ORACLE_NOT_SET = 0,
  };

  static inline const Future* internal_default_instance() {
    return reinterpret_cast<const Future*>(
               &_Future_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Future& a, Future& b) {
    a.Swap(&b);
  }
  inline void Swap(Future* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Future* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Future* New() const final {
    return CreateMaybeMessage<Future>(nullptr);
  }

  Future* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Future>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Future& from);
  void MergeFrom(const Future& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Future* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vega.Future";
  }
  protected:
  explicit Future(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_markets_2eproto);
    return ::descriptor_table_markets_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMaturityFieldNumber = 1,
    kSettlementAssetFieldNumber = 2,
    kQuoteNameFieldNumber = 4,
    kEthereumEventFieldNumber = 100,
  };
  // string maturity = 1 [json_name = "maturity"];
  void clear_maturity();
  const std::string& maturity() const;
  void set_maturity(const std::string& value);
  void set_maturity(std::string&& value);
  void set_maturity(const char* value);
  void set_maturity(const char* value, size_t size);
  std::string* mutable_maturity();
  std::string* release_maturity();
  void set_allocated_maturity(std::string* maturity);
  private:
  const std::string& _internal_maturity() const;
  void _internal_set_maturity(const std::string& value);
  std::string* _internal_mutable_maturity();
  public:

  // string settlementAsset = 2 [json_name = "settlementAsset"];
  void clear_settlementasset();
  const std::string& settlementasset() const;
  void set_settlementasset(const std::string& value);
  void set_settlementasset(std::string&& value);
  void set_settlementasset(const char* value);
  void set_settlementasset(const char* value, size_t size);
  std::string* mutable_settlementasset();
  std::string* release_settlementasset();
  void set_allocated_settlementasset(std::string* settlementasset);
  private:
  const std::string& _internal_settlementasset() const;
  void _internal_set_settlementasset(const std::string& value);
  std::string* _internal_mutable_settlementasset();
  public:

  // string quoteName = 4 [json_name = "quoteName"];
  void clear_quotename();
  const std::string& quotename() const;
  void set_quotename(const std::string& value);
  void set_quotename(std::string&& value);
  void set_quotename(const char* value);
  void set_quotename(const char* value, size_t size);
  std::string* mutable_quotename();
  std::string* release_quotename();
  void set_allocated_quotename(std::string* quotename);
  private:
  const std::string& _internal_quotename() const;
  void _internal_set_quotename(const std::string& value);
  std::string* _internal_mutable_quotename();
  public:

  // .vega.EthereumEvent ethereumEvent = 100 [json_name = "ethereumEvent"];
  bool has_ethereumevent() const;
  private:
  bool _internal_has_ethereumevent() const;
  public:
  void clear_ethereumevent();
  const ::vega::EthereumEvent& ethereumevent() const;
  ::vega::EthereumEvent* release_ethereumevent();
  ::vega::EthereumEvent* mutable_ethereumevent();
  void set_allocated_ethereumevent(::vega::EthereumEvent* ethereumevent);
  private:
  const ::vega::EthereumEvent& _internal_ethereumevent() const;
  ::vega::EthereumEvent* _internal_mutable_ethereumevent();
  public:
  void unsafe_arena_set_allocated_ethereumevent(
      ::vega::EthereumEvent* ethereumevent);
  ::vega::EthereumEvent* unsafe_arena_release_ethereumevent();

  void clear_oracle();
  OracleCase oracle_case() const;
  // @@protoc_insertion_point(class_scope:vega.Future)
 private:
  class _Internal;
  void set_has_ethereumevent();

  inline bool has_oracle() const;
  inline void clear_has_oracle();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr maturity_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr settlementasset_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr quotename_;
  union OracleUnion {
    OracleUnion() {}
    ::vega::EthereumEvent* ethereumevent_;
  } oracle_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_markets_2eproto;
};
// -------------------------------------------------------------------

class EthereumEvent PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vega.EthereumEvent) */ {
 public:
  inline EthereumEvent() : EthereumEvent(nullptr) {}
  virtual ~EthereumEvent();

  EthereumEvent(const EthereumEvent& from);
  EthereumEvent(EthereumEvent&& from) noexcept
    : EthereumEvent() {
    *this = ::std::move(from);
  }

  inline EthereumEvent& operator=(const EthereumEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline EthereumEvent& operator=(EthereumEvent&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const EthereumEvent& default_instance();

  static inline const EthereumEvent* internal_default_instance() {
    return reinterpret_cast<const EthereumEvent*>(
               &_EthereumEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(EthereumEvent& a, EthereumEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(EthereumEvent* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EthereumEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EthereumEvent* New() const final {
    return CreateMaybeMessage<EthereumEvent>(nullptr);
  }

  EthereumEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EthereumEvent>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const EthereumEvent& from);
  void MergeFrom(const EthereumEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EthereumEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vega.EthereumEvent";
  }
  protected:
  explicit EthereumEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_markets_2eproto);
    return ::descriptor_table_markets_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContractIDFieldNumber = 1,
    kEventFieldNumber = 2,
    kValueFieldNumber = 3,
  };
  // string contractID = 1 [json_name = "contractID"];
  void clear_contractid();
  const std::string& contractid() const;
  void set_contractid(const std::string& value);
  void set_contractid(std::string&& value);
  void set_contractid(const char* value);
  void set_contractid(const char* value, size_t size);
  std::string* mutable_contractid();
  std::string* release_contractid();
  void set_allocated_contractid(std::string* contractid);
  private:
  const std::string& _internal_contractid() const;
  void _internal_set_contractid(const std::string& value);
  std::string* _internal_mutable_contractid();
  public:

  // string event = 2 [json_name = "event"];
  void clear_event();
  const std::string& event() const;
  void set_event(const std::string& value);
  void set_event(std::string&& value);
  void set_event(const char* value);
  void set_event(const char* value, size_t size);
  std::string* mutable_event();
  std::string* release_event();
  void set_allocated_event(std::string* event);
  private:
  const std::string& _internal_event() const;
  void _internal_set_event(const std::string& value);
  std::string* _internal_mutable_event();
  public:

  // uint64 value = 3 [json_name = "value"];
  void clear_value();
  ::PROTOBUF_NAMESPACE_ID::uint64 value() const;
  void set_value(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_value() const;
  void _internal_set_value(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:vega.EthereumEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contractid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr event_;
  ::PROTOBUF_NAMESPACE_ID::uint64 value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_markets_2eproto;
};
// -------------------------------------------------------------------

class InstrumentMetadata PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vega.InstrumentMetadata) */ {
 public:
  inline InstrumentMetadata() : InstrumentMetadata(nullptr) {}
  virtual ~InstrumentMetadata();

  InstrumentMetadata(const InstrumentMetadata& from);
  InstrumentMetadata(InstrumentMetadata&& from) noexcept
    : InstrumentMetadata() {
    *this = ::std::move(from);
  }

  inline InstrumentMetadata& operator=(const InstrumentMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline InstrumentMetadata& operator=(InstrumentMetadata&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const InstrumentMetadata& default_instance();

  static inline const InstrumentMetadata* internal_default_instance() {
    return reinterpret_cast<const InstrumentMetadata*>(
               &_InstrumentMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(InstrumentMetadata& a, InstrumentMetadata& b) {
    a.Swap(&b);
  }
  inline void Swap(InstrumentMetadata* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InstrumentMetadata* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline InstrumentMetadata* New() const final {
    return CreateMaybeMessage<InstrumentMetadata>(nullptr);
  }

  InstrumentMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<InstrumentMetadata>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const InstrumentMetadata& from);
  void MergeFrom(const InstrumentMetadata& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InstrumentMetadata* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vega.InstrumentMetadata";
  }
  protected:
  explicit InstrumentMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_markets_2eproto);
    return ::descriptor_table_markets_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTagsFieldNumber = 1,
  };
  // repeated string tags = 1 [json_name = "tags"];
  int tags_size() const;
  private:
  int _internal_tags_size() const;
  public:
  void clear_tags();
  const std::string& tags(int index) const;
  std::string* mutable_tags(int index);
  void set_tags(int index, const std::string& value);
  void set_tags(int index, std::string&& value);
  void set_tags(int index, const char* value);
  void set_tags(int index, const char* value, size_t size);
  std::string* add_tags();
  void add_tags(const std::string& value);
  void add_tags(std::string&& value);
  void add_tags(const char* value);
  void add_tags(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& tags() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_tags();
  private:
  const std::string& _internal_tags(int index) const;
  std::string* _internal_add_tags();
  public:

  // @@protoc_insertion_point(class_scope:vega.InstrumentMetadata)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> tags_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_markets_2eproto;
};
// -------------------------------------------------------------------

class Instrument PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vega.Instrument) */ {
 public:
  inline Instrument() : Instrument(nullptr) {}
  virtual ~Instrument();

  Instrument(const Instrument& from);
  Instrument(Instrument&& from) noexcept
    : Instrument() {
    *this = ::std::move(from);
  }

  inline Instrument& operator=(const Instrument& from) {
    CopyFrom(from);
    return *this;
  }
  inline Instrument& operator=(Instrument&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Instrument& default_instance();

  enum ProductCase {
    kFuture = 100,
    PRODUCT_NOT_SET = 0,
  };

  static inline const Instrument* internal_default_instance() {
    return reinterpret_cast<const Instrument*>(
               &_Instrument_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Instrument& a, Instrument& b) {
    a.Swap(&b);
  }
  inline void Swap(Instrument* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Instrument* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Instrument* New() const final {
    return CreateMaybeMessage<Instrument>(nullptr);
  }

  Instrument* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Instrument>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Instrument& from);
  void MergeFrom(const Instrument& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Instrument* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vega.Instrument";
  }
  protected:
  explicit Instrument(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_markets_2eproto);
    return ::descriptor_table_markets_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kCodeFieldNumber = 2,
    kNameFieldNumber = 3,
    kMetadataFieldNumber = 4,
    kInitialMarkPriceFieldNumber = 5,
    kFutureFieldNumber = 100,
  };
  // string id = 1 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  void set_id(const std::string& value);
  void set_id(std::string&& value);
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  std::string* mutable_id();
  std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string code = 2 [json_name = "code"];
  void clear_code();
  const std::string& code() const;
  void set_code(const std::string& value);
  void set_code(std::string&& value);
  void set_code(const char* value);
  void set_code(const char* value, size_t size);
  std::string* mutable_code();
  std::string* release_code();
  void set_allocated_code(std::string* code);
  private:
  const std::string& _internal_code() const;
  void _internal_set_code(const std::string& value);
  std::string* _internal_mutable_code();
  public:

  // string name = 3 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .vega.InstrumentMetadata metadata = 4 [json_name = "metadata"];
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::vega::InstrumentMetadata& metadata() const;
  ::vega::InstrumentMetadata* release_metadata();
  ::vega::InstrumentMetadata* mutable_metadata();
  void set_allocated_metadata(::vega::InstrumentMetadata* metadata);
  private:
  const ::vega::InstrumentMetadata& _internal_metadata() const;
  ::vega::InstrumentMetadata* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::vega::InstrumentMetadata* metadata);
  ::vega::InstrumentMetadata* unsafe_arena_release_metadata();

  // uint64 initialMarkPrice = 5 [json_name = "initialMarkPrice"];
  void clear_initialmarkprice();
  ::PROTOBUF_NAMESPACE_ID::uint64 initialmarkprice() const;
  void set_initialmarkprice(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_initialmarkprice() const;
  void _internal_set_initialmarkprice(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // .vega.Future future = 100 [json_name = "future"];
  bool has_future() const;
  private:
  bool _internal_has_future() const;
  public:
  void clear_future();
  const ::vega::Future& future() const;
  ::vega::Future* release_future();
  ::vega::Future* mutable_future();
  void set_allocated_future(::vega::Future* future);
  private:
  const ::vega::Future& _internal_future() const;
  ::vega::Future* _internal_mutable_future();
  public:
  void unsafe_arena_set_allocated_future(
      ::vega::Future* future);
  ::vega::Future* unsafe_arena_release_future();

  void clear_product();
  ProductCase product_case() const;
  // @@protoc_insertion_point(class_scope:vega.Instrument)
 private:
  class _Internal;
  void set_has_future();

  inline bool has_product() const;
  inline void clear_has_product();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr code_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::vega::InstrumentMetadata* metadata_;
  ::PROTOBUF_NAMESPACE_ID::uint64 initialmarkprice_;
  union ProductUnion {
    ProductUnion() {}
    ::vega::Future* future_;
  } product_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_markets_2eproto;
};
// -------------------------------------------------------------------

class LogNormalRiskModel PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vega.LogNormalRiskModel) */ {
 public:
  inline LogNormalRiskModel() : LogNormalRiskModel(nullptr) {}
  virtual ~LogNormalRiskModel();

  LogNormalRiskModel(const LogNormalRiskModel& from);
  LogNormalRiskModel(LogNormalRiskModel&& from) noexcept
    : LogNormalRiskModel() {
    *this = ::std::move(from);
  }

  inline LogNormalRiskModel& operator=(const LogNormalRiskModel& from) {
    CopyFrom(from);
    return *this;
  }
  inline LogNormalRiskModel& operator=(LogNormalRiskModel&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LogNormalRiskModel& default_instance();

  static inline const LogNormalRiskModel* internal_default_instance() {
    return reinterpret_cast<const LogNormalRiskModel*>(
               &_LogNormalRiskModel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(LogNormalRiskModel& a, LogNormalRiskModel& b) {
    a.Swap(&b);
  }
  inline void Swap(LogNormalRiskModel* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LogNormalRiskModel* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LogNormalRiskModel* New() const final {
    return CreateMaybeMessage<LogNormalRiskModel>(nullptr);
  }

  LogNormalRiskModel* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LogNormalRiskModel>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LogNormalRiskModel& from);
  void MergeFrom(const LogNormalRiskModel& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LogNormalRiskModel* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vega.LogNormalRiskModel";
  }
  protected:
  explicit LogNormalRiskModel(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_markets_2eproto);
    return ::descriptor_table_markets_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParamsFieldNumber = 3,
    kRiskAversionParameterFieldNumber = 1,
    kTauFieldNumber = 2,
  };
  // .vega.LogNormalModelParams params = 3 [json_name = "params"];
  bool has_params() const;
  private:
  bool _internal_has_params() const;
  public:
  void clear_params();
  const ::vega::LogNormalModelParams& params() const;
  ::vega::LogNormalModelParams* release_params();
  ::vega::LogNormalModelParams* mutable_params();
  void set_allocated_params(::vega::LogNormalModelParams* params);
  private:
  const ::vega::LogNormalModelParams& _internal_params() const;
  ::vega::LogNormalModelParams* _internal_mutable_params();
  public:
  void unsafe_arena_set_allocated_params(
      ::vega::LogNormalModelParams* params);
  ::vega::LogNormalModelParams* unsafe_arena_release_params();

  // double riskAversionParameter = 1 [json_name = "riskAversionParameter"];
  void clear_riskaversionparameter();
  double riskaversionparameter() const;
  void set_riskaversionparameter(double value);
  private:
  double _internal_riskaversionparameter() const;
  void _internal_set_riskaversionparameter(double value);
  public:

  // double tau = 2 [json_name = "tau"];
  void clear_tau();
  double tau() const;
  void set_tau(double value);
  private:
  double _internal_tau() const;
  void _internal_set_tau(double value);
  public:

  // @@protoc_insertion_point(class_scope:vega.LogNormalRiskModel)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::vega::LogNormalModelParams* params_;
  double riskaversionparameter_;
  double tau_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_markets_2eproto;
};
// -------------------------------------------------------------------

class LogNormalModelParams PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vega.LogNormalModelParams) */ {
 public:
  inline LogNormalModelParams() : LogNormalModelParams(nullptr) {}
  virtual ~LogNormalModelParams();

  LogNormalModelParams(const LogNormalModelParams& from);
  LogNormalModelParams(LogNormalModelParams&& from) noexcept
    : LogNormalModelParams() {
    *this = ::std::move(from);
  }

  inline LogNormalModelParams& operator=(const LogNormalModelParams& from) {
    CopyFrom(from);
    return *this;
  }
  inline LogNormalModelParams& operator=(LogNormalModelParams&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LogNormalModelParams& default_instance();

  static inline const LogNormalModelParams* internal_default_instance() {
    return reinterpret_cast<const LogNormalModelParams*>(
               &_LogNormalModelParams_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(LogNormalModelParams& a, LogNormalModelParams& b) {
    a.Swap(&b);
  }
  inline void Swap(LogNormalModelParams* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LogNormalModelParams* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LogNormalModelParams* New() const final {
    return CreateMaybeMessage<LogNormalModelParams>(nullptr);
  }

  LogNormalModelParams* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LogNormalModelParams>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LogNormalModelParams& from);
  void MergeFrom(const LogNormalModelParams& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LogNormalModelParams* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vega.LogNormalModelParams";
  }
  protected:
  explicit LogNormalModelParams(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_markets_2eproto);
    return ::descriptor_table_markets_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMuFieldNumber = 1,
    kRFieldNumber = 2,
    kSigmaFieldNumber = 3,
  };
  // double mu = 1 [json_name = "mu"];
  void clear_mu();
  double mu() const;
  void set_mu(double value);
  private:
  double _internal_mu() const;
  void _internal_set_mu(double value);
  public:

  // double r = 2 [json_name = "r"];
  void clear_r();
  double r() const;
  void set_r(double value);
  private:
  double _internal_r() const;
  void _internal_set_r(double value);
  public:

  // double sigma = 3 [json_name = "sigma"];
  void clear_sigma();
  double sigma() const;
  void set_sigma(double value);
  private:
  double _internal_sigma() const;
  void _internal_set_sigma(double value);
  public:

  // @@protoc_insertion_point(class_scope:vega.LogNormalModelParams)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  double mu_;
  double r_;
  double sigma_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_markets_2eproto;
};
// -------------------------------------------------------------------

class SimpleRiskModel PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vega.SimpleRiskModel) */ {
 public:
  inline SimpleRiskModel() : SimpleRiskModel(nullptr) {}
  virtual ~SimpleRiskModel();

  SimpleRiskModel(const SimpleRiskModel& from);
  SimpleRiskModel(SimpleRiskModel&& from) noexcept
    : SimpleRiskModel() {
    *this = ::std::move(from);
  }

  inline SimpleRiskModel& operator=(const SimpleRiskModel& from) {
    CopyFrom(from);
    return *this;
  }
  inline SimpleRiskModel& operator=(SimpleRiskModel&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SimpleRiskModel& default_instance();

  static inline const SimpleRiskModel* internal_default_instance() {
    return reinterpret_cast<const SimpleRiskModel*>(
               &_SimpleRiskModel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(SimpleRiskModel& a, SimpleRiskModel& b) {
    a.Swap(&b);
  }
  inline void Swap(SimpleRiskModel* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SimpleRiskModel* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SimpleRiskModel* New() const final {
    return CreateMaybeMessage<SimpleRiskModel>(nullptr);
  }

  SimpleRiskModel* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SimpleRiskModel>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SimpleRiskModel& from);
  void MergeFrom(const SimpleRiskModel& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SimpleRiskModel* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vega.SimpleRiskModel";
  }
  protected:
  explicit SimpleRiskModel(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_markets_2eproto);
    return ::descriptor_table_markets_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParamsFieldNumber = 1,
  };
  // .vega.SimpleModelParams params = 1 [json_name = "params"];
  bool has_params() const;
  private:
  bool _internal_has_params() const;
  public:
  void clear_params();
  const ::vega::SimpleModelParams& params() const;
  ::vega::SimpleModelParams* release_params();
  ::vega::SimpleModelParams* mutable_params();
  void set_allocated_params(::vega::SimpleModelParams* params);
  private:
  const ::vega::SimpleModelParams& _internal_params() const;
  ::vega::SimpleModelParams* _internal_mutable_params();
  public:
  void unsafe_arena_set_allocated_params(
      ::vega::SimpleModelParams* params);
  ::vega::SimpleModelParams* unsafe_arena_release_params();

  // @@protoc_insertion_point(class_scope:vega.SimpleRiskModel)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::vega::SimpleModelParams* params_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_markets_2eproto;
};
// -------------------------------------------------------------------

class SimpleModelParams PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vega.SimpleModelParams) */ {
 public:
  inline SimpleModelParams() : SimpleModelParams(nullptr) {}
  virtual ~SimpleModelParams();

  SimpleModelParams(const SimpleModelParams& from);
  SimpleModelParams(SimpleModelParams&& from) noexcept
    : SimpleModelParams() {
    *this = ::std::move(from);
  }

  inline SimpleModelParams& operator=(const SimpleModelParams& from) {
    CopyFrom(from);
    return *this;
  }
  inline SimpleModelParams& operator=(SimpleModelParams&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SimpleModelParams& default_instance();

  static inline const SimpleModelParams* internal_default_instance() {
    return reinterpret_cast<const SimpleModelParams*>(
               &_SimpleModelParams_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(SimpleModelParams& a, SimpleModelParams& b) {
    a.Swap(&b);
  }
  inline void Swap(SimpleModelParams* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SimpleModelParams* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SimpleModelParams* New() const final {
    return CreateMaybeMessage<SimpleModelParams>(nullptr);
  }

  SimpleModelParams* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SimpleModelParams>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SimpleModelParams& from);
  void MergeFrom(const SimpleModelParams& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SimpleModelParams* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vega.SimpleModelParams";
  }
  protected:
  explicit SimpleModelParams(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_markets_2eproto);
    return ::descriptor_table_markets_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFactorLongFieldNumber = 1,
    kFactorShortFieldNumber = 2,
    kMaxMoveUpFieldNumber = 3,
    kMinMoveDownFieldNumber = 4,
    kProbabilityOfTradingFieldNumber = 5,
  };
  // double factorLong = 1 [json_name = "factorLong"];
  void clear_factorlong();
  double factorlong() const;
  void set_factorlong(double value);
  private:
  double _internal_factorlong() const;
  void _internal_set_factorlong(double value);
  public:

  // double factorShort = 2 [json_name = "factorShort"];
  void clear_factorshort();
  double factorshort() const;
  void set_factorshort(double value);
  private:
  double _internal_factorshort() const;
  void _internal_set_factorshort(double value);
  public:

  // double maxMoveUp = 3 [json_name = "maxMoveUp", (.validator.field) = {
  void clear_maxmoveup();
  double maxmoveup() const;
  void set_maxmoveup(double value);
  private:
  double _internal_maxmoveup() const;
  void _internal_set_maxmoveup(double value);
  public:

  // double minMoveDown = 4 [json_name = "minMoveDown", (.validator.field) = {
  void clear_minmovedown();
  double minmovedown() const;
  void set_minmovedown(double value);
  private:
  double _internal_minmovedown() const;
  void _internal_set_minmovedown(double value);
  public:

  // double probabilityOfTrading = 5 [json_name = "probabilityOfTrading", (.validator.field) = {
  void clear_probabilityoftrading();
  double probabilityoftrading() const;
  void set_probabilityoftrading(double value);
  private:
  double _internal_probabilityoftrading() const;
  void _internal_set_probabilityoftrading(double value);
  public:

  // @@protoc_insertion_point(class_scope:vega.SimpleModelParams)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  double factorlong_;
  double factorshort_;
  double maxmoveup_;
  double minmovedown_;
  double probabilityoftrading_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_markets_2eproto;
};
// -------------------------------------------------------------------

class ScalingFactors PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vega.ScalingFactors) */ {
 public:
  inline ScalingFactors() : ScalingFactors(nullptr) {}
  virtual ~ScalingFactors();

  ScalingFactors(const ScalingFactors& from);
  ScalingFactors(ScalingFactors&& from) noexcept
    : ScalingFactors() {
    *this = ::std::move(from);
  }

  inline ScalingFactors& operator=(const ScalingFactors& from) {
    CopyFrom(from);
    return *this;
  }
  inline ScalingFactors& operator=(ScalingFactors&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ScalingFactors& default_instance();

  static inline const ScalingFactors* internal_default_instance() {
    return reinterpret_cast<const ScalingFactors*>(
               &_ScalingFactors_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(ScalingFactors& a, ScalingFactors& b) {
    a.Swap(&b);
  }
  inline void Swap(ScalingFactors* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ScalingFactors* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ScalingFactors* New() const final {
    return CreateMaybeMessage<ScalingFactors>(nullptr);
  }

  ScalingFactors* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ScalingFactors>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ScalingFactors& from);
  void MergeFrom(const ScalingFactors& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ScalingFactors* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vega.ScalingFactors";
  }
  protected:
  explicit ScalingFactors(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_markets_2eproto);
    return ::descriptor_table_markets_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSearchLevelFieldNumber = 1,
    kInitialMarginFieldNumber = 2,
    kCollateralReleaseFieldNumber = 3,
  };
  // double searchLevel = 1 [json_name = "searchLevel"];
  void clear_searchlevel();
  double searchlevel() const;
  void set_searchlevel(double value);
  private:
  double _internal_searchlevel() const;
  void _internal_set_searchlevel(double value);
  public:

  // double initialMargin = 2 [json_name = "initialMargin"];
  void clear_initialmargin();
  double initialmargin() const;
  void set_initialmargin(double value);
  private:
  double _internal_initialmargin() const;
  void _internal_set_initialmargin(double value);
  public:

  // double collateralRelease = 3 [json_name = "collateralRelease"];
  void clear_collateralrelease();
  double collateralrelease() const;
  void set_collateralrelease(double value);
  private:
  double _internal_collateralrelease() const;
  void _internal_set_collateralrelease(double value);
  public:

  // @@protoc_insertion_point(class_scope:vega.ScalingFactors)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  double searchlevel_;
  double initialmargin_;
  double collateralrelease_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_markets_2eproto;
};
// -------------------------------------------------------------------

class MarginCalculator PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vega.MarginCalculator) */ {
 public:
  inline MarginCalculator() : MarginCalculator(nullptr) {}
  virtual ~MarginCalculator();

  MarginCalculator(const MarginCalculator& from);
  MarginCalculator(MarginCalculator&& from) noexcept
    : MarginCalculator() {
    *this = ::std::move(from);
  }

  inline MarginCalculator& operator=(const MarginCalculator& from) {
    CopyFrom(from);
    return *this;
  }
  inline MarginCalculator& operator=(MarginCalculator&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MarginCalculator& default_instance();

  static inline const MarginCalculator* internal_default_instance() {
    return reinterpret_cast<const MarginCalculator*>(
               &_MarginCalculator_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(MarginCalculator& a, MarginCalculator& b) {
    a.Swap(&b);
  }
  inline void Swap(MarginCalculator* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MarginCalculator* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MarginCalculator* New() const final {
    return CreateMaybeMessage<MarginCalculator>(nullptr);
  }

  MarginCalculator* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MarginCalculator>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MarginCalculator& from);
  void MergeFrom(const MarginCalculator& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MarginCalculator* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vega.MarginCalculator";
  }
  protected:
  explicit MarginCalculator(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_markets_2eproto);
    return ::descriptor_table_markets_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kScalingFactorsFieldNumber = 1,
  };
  // .vega.ScalingFactors scalingFactors = 1 [json_name = "scalingFactors"];
  bool has_scalingfactors() const;
  private:
  bool _internal_has_scalingfactors() const;
  public:
  void clear_scalingfactors();
  const ::vega::ScalingFactors& scalingfactors() const;
  ::vega::ScalingFactors* release_scalingfactors();
  ::vega::ScalingFactors* mutable_scalingfactors();
  void set_allocated_scalingfactors(::vega::ScalingFactors* scalingfactors);
  private:
  const ::vega::ScalingFactors& _internal_scalingfactors() const;
  ::vega::ScalingFactors* _internal_mutable_scalingfactors();
  public:
  void unsafe_arena_set_allocated_scalingfactors(
      ::vega::ScalingFactors* scalingfactors);
  ::vega::ScalingFactors* unsafe_arena_release_scalingfactors();

  // @@protoc_insertion_point(class_scope:vega.MarginCalculator)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::vega::ScalingFactors* scalingfactors_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_markets_2eproto;
};
// -------------------------------------------------------------------

class TradableInstrument PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vega.TradableInstrument) */ {
 public:
  inline TradableInstrument() : TradableInstrument(nullptr) {}
  virtual ~TradableInstrument();

  TradableInstrument(const TradableInstrument& from);
  TradableInstrument(TradableInstrument&& from) noexcept
    : TradableInstrument() {
    *this = ::std::move(from);
  }

  inline TradableInstrument& operator=(const TradableInstrument& from) {
    CopyFrom(from);
    return *this;
  }
  inline TradableInstrument& operator=(TradableInstrument&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TradableInstrument& default_instance();

  enum RiskModelCase {
    kLogNormalRiskModel = 100,
    kSimpleRiskModel = 101,
    RISKMODEL_NOT_SET = 0,
  };

  static inline const TradableInstrument* internal_default_instance() {
    return reinterpret_cast<const TradableInstrument*>(
               &_TradableInstrument_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(TradableInstrument& a, TradableInstrument& b) {
    a.Swap(&b);
  }
  inline void Swap(TradableInstrument* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TradableInstrument* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TradableInstrument* New() const final {
    return CreateMaybeMessage<TradableInstrument>(nullptr);
  }

  TradableInstrument* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TradableInstrument>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TradableInstrument& from);
  void MergeFrom(const TradableInstrument& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TradableInstrument* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vega.TradableInstrument";
  }
  protected:
  explicit TradableInstrument(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_markets_2eproto);
    return ::descriptor_table_markets_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInstrumentFieldNumber = 1,
    kMarginCalculatorFieldNumber = 2,
    kLogNormalRiskModelFieldNumber = 100,
    kSimpleRiskModelFieldNumber = 101,
  };
  // .vega.Instrument instrument = 1 [json_name = "instrument"];
  bool has_instrument() const;
  private:
  bool _internal_has_instrument() const;
  public:
  void clear_instrument();
  const ::vega::Instrument& instrument() const;
  ::vega::Instrument* release_instrument();
  ::vega::Instrument* mutable_instrument();
  void set_allocated_instrument(::vega::Instrument* instrument);
  private:
  const ::vega::Instrument& _internal_instrument() const;
  ::vega::Instrument* _internal_mutable_instrument();
  public:
  void unsafe_arena_set_allocated_instrument(
      ::vega::Instrument* instrument);
  ::vega::Instrument* unsafe_arena_release_instrument();

  // .vega.MarginCalculator marginCalculator = 2 [json_name = "marginCalculator"];
  bool has_margincalculator() const;
  private:
  bool _internal_has_margincalculator() const;
  public:
  void clear_margincalculator();
  const ::vega::MarginCalculator& margincalculator() const;
  ::vega::MarginCalculator* release_margincalculator();
  ::vega::MarginCalculator* mutable_margincalculator();
  void set_allocated_margincalculator(::vega::MarginCalculator* margincalculator);
  private:
  const ::vega::MarginCalculator& _internal_margincalculator() const;
  ::vega::MarginCalculator* _internal_mutable_margincalculator();
  public:
  void unsafe_arena_set_allocated_margincalculator(
      ::vega::MarginCalculator* margincalculator);
  ::vega::MarginCalculator* unsafe_arena_release_margincalculator();

  // .vega.LogNormalRiskModel logNormalRiskModel = 100 [json_name = "logNormalRiskModel"];
  bool has_lognormalriskmodel() const;
  private:
  bool _internal_has_lognormalriskmodel() const;
  public:
  void clear_lognormalriskmodel();
  const ::vega::LogNormalRiskModel& lognormalriskmodel() const;
  ::vega::LogNormalRiskModel* release_lognormalriskmodel();
  ::vega::LogNormalRiskModel* mutable_lognormalriskmodel();
  void set_allocated_lognormalriskmodel(::vega::LogNormalRiskModel* lognormalriskmodel);
  private:
  const ::vega::LogNormalRiskModel& _internal_lognormalriskmodel() const;
  ::vega::LogNormalRiskModel* _internal_mutable_lognormalriskmodel();
  public:
  void unsafe_arena_set_allocated_lognormalriskmodel(
      ::vega::LogNormalRiskModel* lognormalriskmodel);
  ::vega::LogNormalRiskModel* unsafe_arena_release_lognormalriskmodel();

  // .vega.SimpleRiskModel simpleRiskModel = 101 [json_name = "simpleRiskModel"];
  bool has_simpleriskmodel() const;
  private:
  bool _internal_has_simpleriskmodel() const;
  public:
  void clear_simpleriskmodel();
  const ::vega::SimpleRiskModel& simpleriskmodel() const;
  ::vega::SimpleRiskModel* release_simpleriskmodel();
  ::vega::SimpleRiskModel* mutable_simpleriskmodel();
  void set_allocated_simpleriskmodel(::vega::SimpleRiskModel* simpleriskmodel);
  private:
  const ::vega::SimpleRiskModel& _internal_simpleriskmodel() const;
  ::vega::SimpleRiskModel* _internal_mutable_simpleriskmodel();
  public:
  void unsafe_arena_set_allocated_simpleriskmodel(
      ::vega::SimpleRiskModel* simpleriskmodel);
  ::vega::SimpleRiskModel* unsafe_arena_release_simpleriskmodel();

  void clear_riskModel();
  RiskModelCase riskModel_case() const;
  // @@protoc_insertion_point(class_scope:vega.TradableInstrument)
 private:
  class _Internal;
  void set_has_lognormalriskmodel();
  void set_has_simpleriskmodel();

  inline bool has_riskModel() const;
  inline void clear_has_riskModel();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::vega::Instrument* instrument_;
  ::vega::MarginCalculator* margincalculator_;
  union RiskModelUnion {
    RiskModelUnion() {}
    ::vega::LogNormalRiskModel* lognormalriskmodel_;
    ::vega::SimpleRiskModel* simpleriskmodel_;
  } riskModel_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_markets_2eproto;
};
// -------------------------------------------------------------------

class FeeFactors PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vega.FeeFactors) */ {
 public:
  inline FeeFactors() : FeeFactors(nullptr) {}
  virtual ~FeeFactors();

  FeeFactors(const FeeFactors& from);
  FeeFactors(FeeFactors&& from) noexcept
    : FeeFactors() {
    *this = ::std::move(from);
  }

  inline FeeFactors& operator=(const FeeFactors& from) {
    CopyFrom(from);
    return *this;
  }
  inline FeeFactors& operator=(FeeFactors&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const FeeFactors& default_instance();

  static inline const FeeFactors* internal_default_instance() {
    return reinterpret_cast<const FeeFactors*>(
               &_FeeFactors_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(FeeFactors& a, FeeFactors& b) {
    a.Swap(&b);
  }
  inline void Swap(FeeFactors* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FeeFactors* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FeeFactors* New() const final {
    return CreateMaybeMessage<FeeFactors>(nullptr);
  }

  FeeFactors* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FeeFactors>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const FeeFactors& from);
  void MergeFrom(const FeeFactors& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FeeFactors* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vega.FeeFactors";
  }
  protected:
  explicit FeeFactors(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_markets_2eproto);
    return ::descriptor_table_markets_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMakerFeeFieldNumber = 1,
    kInfrastructureFeeFieldNumber = 2,
    kLiquidityFeeFieldNumber = 3,
  };
  // string makerFee = 1 [json_name = "makerFee"];
  void clear_makerfee();
  const std::string& makerfee() const;
  void set_makerfee(const std::string& value);
  void set_makerfee(std::string&& value);
  void set_makerfee(const char* value);
  void set_makerfee(const char* value, size_t size);
  std::string* mutable_makerfee();
  std::string* release_makerfee();
  void set_allocated_makerfee(std::string* makerfee);
  private:
  const std::string& _internal_makerfee() const;
  void _internal_set_makerfee(const std::string& value);
  std::string* _internal_mutable_makerfee();
  public:

  // string infrastructureFee = 2 [json_name = "infrastructureFee"];
  void clear_infrastructurefee();
  const std::string& infrastructurefee() const;
  void set_infrastructurefee(const std::string& value);
  void set_infrastructurefee(std::string&& value);
  void set_infrastructurefee(const char* value);
  void set_infrastructurefee(const char* value, size_t size);
  std::string* mutable_infrastructurefee();
  std::string* release_infrastructurefee();
  void set_allocated_infrastructurefee(std::string* infrastructurefee);
  private:
  const std::string& _internal_infrastructurefee() const;
  void _internal_set_infrastructurefee(const std::string& value);
  std::string* _internal_mutable_infrastructurefee();
  public:

  // string liquidityFee = 3 [json_name = "liquidityFee"];
  void clear_liquidityfee();
  const std::string& liquidityfee() const;
  void set_liquidityfee(const std::string& value);
  void set_liquidityfee(std::string&& value);
  void set_liquidityfee(const char* value);
  void set_liquidityfee(const char* value, size_t size);
  std::string* mutable_liquidityfee();
  std::string* release_liquidityfee();
  void set_allocated_liquidityfee(std::string* liquidityfee);
  private:
  const std::string& _internal_liquidityfee() const;
  void _internal_set_liquidityfee(const std::string& value);
  std::string* _internal_mutable_liquidityfee();
  public:

  // @@protoc_insertion_point(class_scope:vega.FeeFactors)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr makerfee_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr infrastructurefee_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr liquidityfee_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_markets_2eproto;
};
// -------------------------------------------------------------------

class Fees PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vega.Fees) */ {
 public:
  inline Fees() : Fees(nullptr) {}
  virtual ~Fees();

  Fees(const Fees& from);
  Fees(Fees&& from) noexcept
    : Fees() {
    *this = ::std::move(from);
  }

  inline Fees& operator=(const Fees& from) {
    CopyFrom(from);
    return *this;
  }
  inline Fees& operator=(Fees&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Fees& default_instance();

  static inline const Fees* internal_default_instance() {
    return reinterpret_cast<const Fees*>(
               &_Fees_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(Fees& a, Fees& b) {
    a.Swap(&b);
  }
  inline void Swap(Fees* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Fees* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Fees* New() const final {
    return CreateMaybeMessage<Fees>(nullptr);
  }

  Fees* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Fees>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Fees& from);
  void MergeFrom(const Fees& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Fees* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vega.Fees";
  }
  protected:
  explicit Fees(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_markets_2eproto);
    return ::descriptor_table_markets_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFactorsFieldNumber = 1,
  };
  // .vega.FeeFactors factors = 1 [json_name = "factors"];
  bool has_factors() const;
  private:
  bool _internal_has_factors() const;
  public:
  void clear_factors();
  const ::vega::FeeFactors& factors() const;
  ::vega::FeeFactors* release_factors();
  ::vega::FeeFactors* mutable_factors();
  void set_allocated_factors(::vega::FeeFactors* factors);
  private:
  const ::vega::FeeFactors& _internal_factors() const;
  ::vega::FeeFactors* _internal_mutable_factors();
  public:
  void unsafe_arena_set_allocated_factors(
      ::vega::FeeFactors* factors);
  ::vega::FeeFactors* unsafe_arena_release_factors();

  // @@protoc_insertion_point(class_scope:vega.Fees)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::vega::FeeFactors* factors_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_markets_2eproto;
};
// -------------------------------------------------------------------

class PriceMonitoringTrigger PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vega.PriceMonitoringTrigger) */ {
 public:
  inline PriceMonitoringTrigger() : PriceMonitoringTrigger(nullptr) {}
  virtual ~PriceMonitoringTrigger();

  PriceMonitoringTrigger(const PriceMonitoringTrigger& from);
  PriceMonitoringTrigger(PriceMonitoringTrigger&& from) noexcept
    : PriceMonitoringTrigger() {
    *this = ::std::move(from);
  }

  inline PriceMonitoringTrigger& operator=(const PriceMonitoringTrigger& from) {
    CopyFrom(from);
    return *this;
  }
  inline PriceMonitoringTrigger& operator=(PriceMonitoringTrigger&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PriceMonitoringTrigger& default_instance();

  static inline const PriceMonitoringTrigger* internal_default_instance() {
    return reinterpret_cast<const PriceMonitoringTrigger*>(
               &_PriceMonitoringTrigger_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(PriceMonitoringTrigger& a, PriceMonitoringTrigger& b) {
    a.Swap(&b);
  }
  inline void Swap(PriceMonitoringTrigger* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PriceMonitoringTrigger* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PriceMonitoringTrigger* New() const final {
    return CreateMaybeMessage<PriceMonitoringTrigger>(nullptr);
  }

  PriceMonitoringTrigger* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PriceMonitoringTrigger>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PriceMonitoringTrigger& from);
  void MergeFrom(const PriceMonitoringTrigger& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PriceMonitoringTrigger* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vega.PriceMonitoringTrigger";
  }
  protected:
  explicit PriceMonitoringTrigger(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_markets_2eproto);
    return ::descriptor_table_markets_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHorizonFieldNumber = 1,
    kProbabilityFieldNumber = 2,
    kAuctionExtensionFieldNumber = 3,
  };
  // int64 horizon = 1 [json_name = "horizon", (.validator.field) = {
  void clear_horizon();
  ::PROTOBUF_NAMESPACE_ID::int64 horizon() const;
  void set_horizon(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_horizon() const;
  void _internal_set_horizon(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // double probability = 2 [json_name = "probability", (.validator.field) = {
  void clear_probability();
  double probability() const;
  void set_probability(double value);
  private:
  double _internal_probability() const;
  void _internal_set_probability(double value);
  public:

  // int64 auctionExtension = 3 [json_name = "auctionExtension", (.validator.field) = {
  void clear_auctionextension();
  ::PROTOBUF_NAMESPACE_ID::int64 auctionextension() const;
  void set_auctionextension(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_auctionextension() const;
  void _internal_set_auctionextension(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:vega.PriceMonitoringTrigger)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int64 horizon_;
  double probability_;
  ::PROTOBUF_NAMESPACE_ID::int64 auctionextension_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_markets_2eproto;
};
// -------------------------------------------------------------------

class PriceMonitoringParameters PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vega.PriceMonitoringParameters) */ {
 public:
  inline PriceMonitoringParameters() : PriceMonitoringParameters(nullptr) {}
  virtual ~PriceMonitoringParameters();

  PriceMonitoringParameters(const PriceMonitoringParameters& from);
  PriceMonitoringParameters(PriceMonitoringParameters&& from) noexcept
    : PriceMonitoringParameters() {
    *this = ::std::move(from);
  }

  inline PriceMonitoringParameters& operator=(const PriceMonitoringParameters& from) {
    CopyFrom(from);
    return *this;
  }
  inline PriceMonitoringParameters& operator=(PriceMonitoringParameters&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PriceMonitoringParameters& default_instance();

  static inline const PriceMonitoringParameters* internal_default_instance() {
    return reinterpret_cast<const PriceMonitoringParameters*>(
               &_PriceMonitoringParameters_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(PriceMonitoringParameters& a, PriceMonitoringParameters& b) {
    a.Swap(&b);
  }
  inline void Swap(PriceMonitoringParameters* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PriceMonitoringParameters* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PriceMonitoringParameters* New() const final {
    return CreateMaybeMessage<PriceMonitoringParameters>(nullptr);
  }

  PriceMonitoringParameters* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PriceMonitoringParameters>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PriceMonitoringParameters& from);
  void MergeFrom(const PriceMonitoringParameters& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PriceMonitoringParameters* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vega.PriceMonitoringParameters";
  }
  protected:
  explicit PriceMonitoringParameters(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_markets_2eproto);
    return ::descriptor_table_markets_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTriggersFieldNumber = 1,
  };
  // repeated .vega.PriceMonitoringTrigger triggers = 1 [json_name = "triggers"];
  int triggers_size() const;
  private:
  int _internal_triggers_size() const;
  public:
  void clear_triggers();
  ::vega::PriceMonitoringTrigger* mutable_triggers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vega::PriceMonitoringTrigger >*
      mutable_triggers();
  private:
  const ::vega::PriceMonitoringTrigger& _internal_triggers(int index) const;
  ::vega::PriceMonitoringTrigger* _internal_add_triggers();
  public:
  const ::vega::PriceMonitoringTrigger& triggers(int index) const;
  ::vega::PriceMonitoringTrigger* add_triggers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vega::PriceMonitoringTrigger >&
      triggers() const;

  // @@protoc_insertion_point(class_scope:vega.PriceMonitoringParameters)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vega::PriceMonitoringTrigger > triggers_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_markets_2eproto;
};
// -------------------------------------------------------------------

class PriceMonitoringSettings PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vega.PriceMonitoringSettings) */ {
 public:
  inline PriceMonitoringSettings() : PriceMonitoringSettings(nullptr) {}
  virtual ~PriceMonitoringSettings();

  PriceMonitoringSettings(const PriceMonitoringSettings& from);
  PriceMonitoringSettings(PriceMonitoringSettings&& from) noexcept
    : PriceMonitoringSettings() {
    *this = ::std::move(from);
  }

  inline PriceMonitoringSettings& operator=(const PriceMonitoringSettings& from) {
    CopyFrom(from);
    return *this;
  }
  inline PriceMonitoringSettings& operator=(PriceMonitoringSettings&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PriceMonitoringSettings& default_instance();

  static inline const PriceMonitoringSettings* internal_default_instance() {
    return reinterpret_cast<const PriceMonitoringSettings*>(
               &_PriceMonitoringSettings_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(PriceMonitoringSettings& a, PriceMonitoringSettings& b) {
    a.Swap(&b);
  }
  inline void Swap(PriceMonitoringSettings* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PriceMonitoringSettings* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PriceMonitoringSettings* New() const final {
    return CreateMaybeMessage<PriceMonitoringSettings>(nullptr);
  }

  PriceMonitoringSettings* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PriceMonitoringSettings>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PriceMonitoringSettings& from);
  void MergeFrom(const PriceMonitoringSettings& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PriceMonitoringSettings* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vega.PriceMonitoringSettings";
  }
  protected:
  explicit PriceMonitoringSettings(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_markets_2eproto);
    return ::descriptor_table_markets_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParametersFieldNumber = 1,
    kUpdateFrequencyFieldNumber = 2,
  };
  // .vega.PriceMonitoringParameters parameters = 1 [json_name = "parameters"];
  bool has_parameters() const;
  private:
  bool _internal_has_parameters() const;
  public:
  void clear_parameters();
  const ::vega::PriceMonitoringParameters& parameters() const;
  ::vega::PriceMonitoringParameters* release_parameters();
  ::vega::PriceMonitoringParameters* mutable_parameters();
  void set_allocated_parameters(::vega::PriceMonitoringParameters* parameters);
  private:
  const ::vega::PriceMonitoringParameters& _internal_parameters() const;
  ::vega::PriceMonitoringParameters* _internal_mutable_parameters();
  public:
  void unsafe_arena_set_allocated_parameters(
      ::vega::PriceMonitoringParameters* parameters);
  ::vega::PriceMonitoringParameters* unsafe_arena_release_parameters();

  // int64 updateFrequency = 2 [json_name = "updateFrequency"];
  void clear_updatefrequency();
  ::PROTOBUF_NAMESPACE_ID::int64 updatefrequency() const;
  void set_updatefrequency(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_updatefrequency() const;
  void _internal_set_updatefrequency(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:vega.PriceMonitoringSettings)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::vega::PriceMonitoringParameters* parameters_;
  ::PROTOBUF_NAMESPACE_ID::int64 updatefrequency_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_markets_2eproto;
};
// -------------------------------------------------------------------

class TargetStakeParameters PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vega.TargetStakeParameters) */ {
 public:
  inline TargetStakeParameters() : TargetStakeParameters(nullptr) {}
  virtual ~TargetStakeParameters();

  TargetStakeParameters(const TargetStakeParameters& from);
  TargetStakeParameters(TargetStakeParameters&& from) noexcept
    : TargetStakeParameters() {
    *this = ::std::move(from);
  }

  inline TargetStakeParameters& operator=(const TargetStakeParameters& from) {
    CopyFrom(from);
    return *this;
  }
  inline TargetStakeParameters& operator=(TargetStakeParameters&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TargetStakeParameters& default_instance();

  static inline const TargetStakeParameters* internal_default_instance() {
    return reinterpret_cast<const TargetStakeParameters*>(
               &_TargetStakeParameters_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(TargetStakeParameters& a, TargetStakeParameters& b) {
    a.Swap(&b);
  }
  inline void Swap(TargetStakeParameters* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TargetStakeParameters* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TargetStakeParameters* New() const final {
    return CreateMaybeMessage<TargetStakeParameters>(nullptr);
  }

  TargetStakeParameters* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TargetStakeParameters>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TargetStakeParameters& from);
  void MergeFrom(const TargetStakeParameters& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TargetStakeParameters* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vega.TargetStakeParameters";
  }
  protected:
  explicit TargetStakeParameters(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_markets_2eproto);
    return ::descriptor_table_markets_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimeWindowFieldNumber = 1,
    kScalingFactorFieldNumber = 2,
  };
  // int64 timeWindow = 1 [json_name = "timeWindow", (.validator.field) = {
  void clear_timewindow();
  ::PROTOBUF_NAMESPACE_ID::int64 timewindow() const;
  void set_timewindow(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_timewindow() const;
  void _internal_set_timewindow(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // double scalingFactor = 2 [json_name = "scalingFactor", (.validator.field) = {
  void clear_scalingfactor();
  double scalingfactor() const;
  void set_scalingfactor(double value);
  private:
  double _internal_scalingfactor() const;
  void _internal_set_scalingfactor(double value);
  public:

  // @@protoc_insertion_point(class_scope:vega.TargetStakeParameters)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int64 timewindow_;
  double scalingfactor_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_markets_2eproto;
};
// -------------------------------------------------------------------

class Market PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vega.Market) */ {
 public:
  inline Market() : Market(nullptr) {}
  virtual ~Market();

  Market(const Market& from);
  Market(Market&& from) noexcept
    : Market() {
    *this = ::std::move(from);
  }

  inline Market& operator=(const Market& from) {
    CopyFrom(from);
    return *this;
  }
  inline Market& operator=(Market&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Market& default_instance();

  enum TradingModeConfigCase {
    kContinuous = 100,
    kDiscrete = 101,
    TRADINGMODECONFIG_NOT_SET = 0,
  };

  static inline const Market* internal_default_instance() {
    return reinterpret_cast<const Market*>(
               &_Market_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(Market& a, Market& b) {
    a.Swap(&b);
  }
  inline void Swap(Market* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Market* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Market* New() const final {
    return CreateMaybeMessage<Market>(nullptr);
  }

  Market* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Market>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Market& from);
  void MergeFrom(const Market& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Market* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vega.Market";
  }
  protected:
  explicit Market(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_markets_2eproto);
    return ::descriptor_table_markets_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Market_State State;
  static constexpr State STATE_UNSPECIFIED =
    Market_State_STATE_UNSPECIFIED;
  static constexpr State STATE_PROPOSED =
    Market_State_STATE_PROPOSED;
  static constexpr State STATE_REJECTED =
    Market_State_STATE_REJECTED;
  static constexpr State STATE_PENDING =
    Market_State_STATE_PENDING;
  static constexpr State STATE_CANCELLED =
    Market_State_STATE_CANCELLED;
  static constexpr State STATE_ACTIVE =
    Market_State_STATE_ACTIVE;
  static constexpr State STATE_SUSPENDED =
    Market_State_STATE_SUSPENDED;
  static constexpr State STATE_CLOSED =
    Market_State_STATE_CLOSED;
  static constexpr State STATE_TRADING_TERMINATED =
    Market_State_STATE_TRADING_TERMINATED;
  static constexpr State STATE_SETTLED =
    Market_State_STATE_SETTLED;
  static inline bool State_IsValid(int value) {
    return Market_State_IsValid(value);
  }
  static constexpr State State_MIN =
    Market_State_State_MIN;
  static constexpr State State_MAX =
    Market_State_State_MAX;
  static constexpr int State_ARRAYSIZE =
    Market_State_State_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  State_descriptor() {
    return Market_State_descriptor();
  }
  template<typename T>
  static inline const std::string& State_Name(T enum_t_value) {
    static_assert(::std::is_same<T, State>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function State_Name.");
    return Market_State_Name(enum_t_value);
  }
  static inline bool State_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      State* value) {
    return Market_State_Parse(name, value);
  }

  typedef Market_TradingMode TradingMode;
  static constexpr TradingMode TRADING_MODE_UNSPECIFIED =
    Market_TradingMode_TRADING_MODE_UNSPECIFIED;
  static constexpr TradingMode TRADING_MODE_CONTINUOUS =
    Market_TradingMode_TRADING_MODE_CONTINUOUS;
  static constexpr TradingMode TRADING_MODE_BATCH_AUCTION =
    Market_TradingMode_TRADING_MODE_BATCH_AUCTION;
  static constexpr TradingMode TRADING_MODE_OPENING_AUCTION =
    Market_TradingMode_TRADING_MODE_OPENING_AUCTION;
  static constexpr TradingMode TRADING_MODE_MONITORING_AUCTION =
    Market_TradingMode_TRADING_MODE_MONITORING_AUCTION;
  static inline bool TradingMode_IsValid(int value) {
    return Market_TradingMode_IsValid(value);
  }
  static constexpr TradingMode TradingMode_MIN =
    Market_TradingMode_TradingMode_MIN;
  static constexpr TradingMode TradingMode_MAX =
    Market_TradingMode_TradingMode_MAX;
  static constexpr int TradingMode_ARRAYSIZE =
    Market_TradingMode_TradingMode_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  TradingMode_descriptor() {
    return Market_TradingMode_descriptor();
  }
  template<typename T>
  static inline const std::string& TradingMode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, TradingMode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function TradingMode_Name.");
    return Market_TradingMode_Name(enum_t_value);
  }
  static inline bool TradingMode_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      TradingMode* value) {
    return Market_TradingMode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kTradableInstrumentFieldNumber = 2,
    kFeesFieldNumber = 4,
    kOpeningAuctionFieldNumber = 5,
    kPriceMonitoringSettingsFieldNumber = 6,
    kTargetStakeParametersFieldNumber = 7,
    kDecimalPlacesFieldNumber = 3,
    kTradingModeFieldNumber = 8,
    kStateFieldNumber = 9,
    kContinuousFieldNumber = 100,
    kDiscreteFieldNumber = 101,
  };
  // string id = 1 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  void set_id(const std::string& value);
  void set_id(std::string&& value);
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  std::string* mutable_id();
  std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // .vega.TradableInstrument tradableInstrument = 2 [json_name = "tradableInstrument"];
  bool has_tradableinstrument() const;
  private:
  bool _internal_has_tradableinstrument() const;
  public:
  void clear_tradableinstrument();
  const ::vega::TradableInstrument& tradableinstrument() const;
  ::vega::TradableInstrument* release_tradableinstrument();
  ::vega::TradableInstrument* mutable_tradableinstrument();
  void set_allocated_tradableinstrument(::vega::TradableInstrument* tradableinstrument);
  private:
  const ::vega::TradableInstrument& _internal_tradableinstrument() const;
  ::vega::TradableInstrument* _internal_mutable_tradableinstrument();
  public:
  void unsafe_arena_set_allocated_tradableinstrument(
      ::vega::TradableInstrument* tradableinstrument);
  ::vega::TradableInstrument* unsafe_arena_release_tradableinstrument();

  // .vega.Fees fees = 4 [json_name = "fees"];
  bool has_fees() const;
  private:
  bool _internal_has_fees() const;
  public:
  void clear_fees();
  const ::vega::Fees& fees() const;
  ::vega::Fees* release_fees();
  ::vega::Fees* mutable_fees();
  void set_allocated_fees(::vega::Fees* fees);
  private:
  const ::vega::Fees& _internal_fees() const;
  ::vega::Fees* _internal_mutable_fees();
  public:
  void unsafe_arena_set_allocated_fees(
      ::vega::Fees* fees);
  ::vega::Fees* unsafe_arena_release_fees();

  // .vega.AuctionDuration openingAuction = 5 [json_name = "openingAuction"];
  bool has_openingauction() const;
  private:
  bool _internal_has_openingauction() const;
  public:
  void clear_openingauction();
  const ::vega::AuctionDuration& openingauction() const;
  ::vega::AuctionDuration* release_openingauction();
  ::vega::AuctionDuration* mutable_openingauction();
  void set_allocated_openingauction(::vega::AuctionDuration* openingauction);
  private:
  const ::vega::AuctionDuration& _internal_openingauction() const;
  ::vega::AuctionDuration* _internal_mutable_openingauction();
  public:
  void unsafe_arena_set_allocated_openingauction(
      ::vega::AuctionDuration* openingauction);
  ::vega::AuctionDuration* unsafe_arena_release_openingauction();

  // .vega.PriceMonitoringSettings priceMonitoringSettings = 6 [json_name = "priceMonitoringSettings"];
  bool has_pricemonitoringsettings() const;
  private:
  bool _internal_has_pricemonitoringsettings() const;
  public:
  void clear_pricemonitoringsettings();
  const ::vega::PriceMonitoringSettings& pricemonitoringsettings() const;
  ::vega::PriceMonitoringSettings* release_pricemonitoringsettings();
  ::vega::PriceMonitoringSettings* mutable_pricemonitoringsettings();
  void set_allocated_pricemonitoringsettings(::vega::PriceMonitoringSettings* pricemonitoringsettings);
  private:
  const ::vega::PriceMonitoringSettings& _internal_pricemonitoringsettings() const;
  ::vega::PriceMonitoringSettings* _internal_mutable_pricemonitoringsettings();
  public:
  void unsafe_arena_set_allocated_pricemonitoringsettings(
      ::vega::PriceMonitoringSettings* pricemonitoringsettings);
  ::vega::PriceMonitoringSettings* unsafe_arena_release_pricemonitoringsettings();

  // .vega.TargetStakeParameters targetStakeParameters = 7 [json_name = "targetStakeParameters"];
  bool has_targetstakeparameters() const;
  private:
  bool _internal_has_targetstakeparameters() const;
  public:
  void clear_targetstakeparameters();
  const ::vega::TargetStakeParameters& targetstakeparameters() const;
  ::vega::TargetStakeParameters* release_targetstakeparameters();
  ::vega::TargetStakeParameters* mutable_targetstakeparameters();
  void set_allocated_targetstakeparameters(::vega::TargetStakeParameters* targetstakeparameters);
  private:
  const ::vega::TargetStakeParameters& _internal_targetstakeparameters() const;
  ::vega::TargetStakeParameters* _internal_mutable_targetstakeparameters();
  public:
  void unsafe_arena_set_allocated_targetstakeparameters(
      ::vega::TargetStakeParameters* targetstakeparameters);
  ::vega::TargetStakeParameters* unsafe_arena_release_targetstakeparameters();

  // uint64 decimalPlaces = 3 [json_name = "decimalPlaces"];
  void clear_decimalplaces();
  ::PROTOBUF_NAMESPACE_ID::uint64 decimalplaces() const;
  void set_decimalplaces(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_decimalplaces() const;
  void _internal_set_decimalplaces(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // .vega.Market.TradingMode tradingMode = 8 [json_name = "tradingMode"];
  void clear_tradingmode();
  ::vega::Market_TradingMode tradingmode() const;
  void set_tradingmode(::vega::Market_TradingMode value);
  private:
  ::vega::Market_TradingMode _internal_tradingmode() const;
  void _internal_set_tradingmode(::vega::Market_TradingMode value);
  public:

  // .vega.Market.State state = 9 [json_name = "state"];
  void clear_state();
  ::vega::Market_State state() const;
  void set_state(::vega::Market_State value);
  private:
  ::vega::Market_State _internal_state() const;
  void _internal_set_state(::vega::Market_State value);
  public:

  // .vega.ContinuousTrading continuous = 100 [json_name = "continuous"];
  bool has_continuous() const;
  private:
  bool _internal_has_continuous() const;
  public:
  void clear_continuous();
  const ::vega::ContinuousTrading& continuous() const;
  ::vega::ContinuousTrading* release_continuous();
  ::vega::ContinuousTrading* mutable_continuous();
  void set_allocated_continuous(::vega::ContinuousTrading* continuous);
  private:
  const ::vega::ContinuousTrading& _internal_continuous() const;
  ::vega::ContinuousTrading* _internal_mutable_continuous();
  public:
  void unsafe_arena_set_allocated_continuous(
      ::vega::ContinuousTrading* continuous);
  ::vega::ContinuousTrading* unsafe_arena_release_continuous();

  // .vega.DiscreteTrading discrete = 101 [json_name = "discrete"];
  bool has_discrete() const;
  private:
  bool _internal_has_discrete() const;
  public:
  void clear_discrete();
  const ::vega::DiscreteTrading& discrete() const;
  ::vega::DiscreteTrading* release_discrete();
  ::vega::DiscreteTrading* mutable_discrete();
  void set_allocated_discrete(::vega::DiscreteTrading* discrete);
  private:
  const ::vega::DiscreteTrading& _internal_discrete() const;
  ::vega::DiscreteTrading* _internal_mutable_discrete();
  public:
  void unsafe_arena_set_allocated_discrete(
      ::vega::DiscreteTrading* discrete);
  ::vega::DiscreteTrading* unsafe_arena_release_discrete();

  void clear_tradingModeConfig();
  TradingModeConfigCase tradingModeConfig_case() const;
  // @@protoc_insertion_point(class_scope:vega.Market)
 private:
  class _Internal;
  void set_has_continuous();
  void set_has_discrete();

  inline bool has_tradingModeConfig() const;
  inline void clear_has_tradingModeConfig();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::vega::TradableInstrument* tradableinstrument_;
  ::vega::Fees* fees_;
  ::vega::AuctionDuration* openingauction_;
  ::vega::PriceMonitoringSettings* pricemonitoringsettings_;
  ::vega::TargetStakeParameters* targetstakeparameters_;
  ::PROTOBUF_NAMESPACE_ID::uint64 decimalplaces_;
  int tradingmode_;
  int state_;
  union TradingModeConfigUnion {
    TradingModeConfigUnion() {}
    ::vega::ContinuousTrading* continuous_;
    ::vega::DiscreteTrading* discrete_;
  } tradingModeConfig_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_markets_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// AuctionDuration

// int64 duration = 1 [json_name = "duration"];
inline void AuctionDuration::clear_duration() {
  duration_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 AuctionDuration::_internal_duration() const {
  return duration_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 AuctionDuration::duration() const {
  // @@protoc_insertion_point(field_get:vega.AuctionDuration.duration)
  return _internal_duration();
}
inline void AuctionDuration::_internal_set_duration(::PROTOBUF_NAMESPACE_ID::int64 value) {

  duration_ = value;
}
inline void AuctionDuration::set_duration(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_duration(value);
  // @@protoc_insertion_point(field_set:vega.AuctionDuration.duration)
}

// uint64 volume = 2 [json_name = "volume"];
inline void AuctionDuration::clear_volume() {
  volume_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 AuctionDuration::_internal_volume() const {
  return volume_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 AuctionDuration::volume() const {
  // @@protoc_insertion_point(field_get:vega.AuctionDuration.volume)
  return _internal_volume();
}
inline void AuctionDuration::_internal_set_volume(::PROTOBUF_NAMESPACE_ID::uint64 value) {

  volume_ = value;
}
inline void AuctionDuration::set_volume(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_volume(value);
  // @@protoc_insertion_point(field_set:vega.AuctionDuration.volume)
}

// -------------------------------------------------------------------

// ContinuousTrading

// string tickSize = 1 [json_name = "tickSize"];
inline void ContinuousTrading::clear_ticksize() {
  ticksize_.ClearToEmpty();
}
inline const std::string& ContinuousTrading::ticksize() const {
  // @@protoc_insertion_point(field_get:vega.ContinuousTrading.tickSize)
  return _internal_ticksize();
}
inline void ContinuousTrading::set_ticksize(const std::string& value) {
  _internal_set_ticksize(value);
  // @@protoc_insertion_point(field_set:vega.ContinuousTrading.tickSize)
}
inline std::string* ContinuousTrading::mutable_ticksize() {
  // @@protoc_insertion_point(field_mutable:vega.ContinuousTrading.tickSize)
  return _internal_mutable_ticksize();
}
inline const std::string& ContinuousTrading::_internal_ticksize() const {
  return ticksize_.Get();
}
inline void ContinuousTrading::_internal_set_ticksize(const std::string& value) {

  ticksize_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void ContinuousTrading::set_ticksize(std::string&& value) {

  ticksize_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vega.ContinuousTrading.tickSize)
}
inline void ContinuousTrading::set_ticksize(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  ticksize_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:vega.ContinuousTrading.tickSize)
}
inline void ContinuousTrading::set_ticksize(const char* value,
    size_t size) {

  ticksize_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vega.ContinuousTrading.tickSize)
}
inline std::string* ContinuousTrading::_internal_mutable_ticksize() {

  return ticksize_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* ContinuousTrading::release_ticksize() {
  // @@protoc_insertion_point(field_release:vega.ContinuousTrading.tickSize)
  return ticksize_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ContinuousTrading::set_allocated_ticksize(std::string* ticksize) {
  if (ticksize != nullptr) {

  } else {

  }
  ticksize_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ticksize,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vega.ContinuousTrading.tickSize)
}

// -------------------------------------------------------------------

// DiscreteTrading

// int64 durationNs = 1 [json_name = "durationNs", (.validator.field) = {
inline void DiscreteTrading::clear_durationns() {
  durationns_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 DiscreteTrading::_internal_durationns() const {
  return durationns_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 DiscreteTrading::durationns() const {
  // @@protoc_insertion_point(field_get:vega.DiscreteTrading.durationNs)
  return _internal_durationns();
}
inline void DiscreteTrading::_internal_set_durationns(::PROTOBUF_NAMESPACE_ID::int64 value) {

  durationns_ = value;
}
inline void DiscreteTrading::set_durationns(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_durationns(value);
  // @@protoc_insertion_point(field_set:vega.DiscreteTrading.durationNs)
}

// string tickSize = 2 [json_name = "tickSize"];
inline void DiscreteTrading::clear_ticksize() {
  ticksize_.ClearToEmpty();
}
inline const std::string& DiscreteTrading::ticksize() const {
  // @@protoc_insertion_point(field_get:vega.DiscreteTrading.tickSize)
  return _internal_ticksize();
}
inline void DiscreteTrading::set_ticksize(const std::string& value) {
  _internal_set_ticksize(value);
  // @@protoc_insertion_point(field_set:vega.DiscreteTrading.tickSize)
}
inline std::string* DiscreteTrading::mutable_ticksize() {
  // @@protoc_insertion_point(field_mutable:vega.DiscreteTrading.tickSize)
  return _internal_mutable_ticksize();
}
inline const std::string& DiscreteTrading::_internal_ticksize() const {
  return ticksize_.Get();
}
inline void DiscreteTrading::_internal_set_ticksize(const std::string& value) {

  ticksize_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void DiscreteTrading::set_ticksize(std::string&& value) {

  ticksize_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vega.DiscreteTrading.tickSize)
}
inline void DiscreteTrading::set_ticksize(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  ticksize_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:vega.DiscreteTrading.tickSize)
}
inline void DiscreteTrading::set_ticksize(const char* value,
    size_t size) {

  ticksize_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vega.DiscreteTrading.tickSize)
}
inline std::string* DiscreteTrading::_internal_mutable_ticksize() {

  return ticksize_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* DiscreteTrading::release_ticksize() {
  // @@protoc_insertion_point(field_release:vega.DiscreteTrading.tickSize)
  return ticksize_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void DiscreteTrading::set_allocated_ticksize(std::string* ticksize) {
  if (ticksize != nullptr) {

  } else {

  }
  ticksize_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ticksize,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vega.DiscreteTrading.tickSize)
}

// -------------------------------------------------------------------

// Future

// string maturity = 1 [json_name = "maturity"];
inline void Future::clear_maturity() {
  maturity_.ClearToEmpty();
}
inline const std::string& Future::maturity() const {
  // @@protoc_insertion_point(field_get:vega.Future.maturity)
  return _internal_maturity();
}
inline void Future::set_maturity(const std::string& value) {
  _internal_set_maturity(value);
  // @@protoc_insertion_point(field_set:vega.Future.maturity)
}
inline std::string* Future::mutable_maturity() {
  // @@protoc_insertion_point(field_mutable:vega.Future.maturity)
  return _internal_mutable_maturity();
}
inline const std::string& Future::_internal_maturity() const {
  return maturity_.Get();
}
inline void Future::_internal_set_maturity(const std::string& value) {

  maturity_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Future::set_maturity(std::string&& value) {

  maturity_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vega.Future.maturity)
}
inline void Future::set_maturity(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  maturity_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:vega.Future.maturity)
}
inline void Future::set_maturity(const char* value,
    size_t size) {

  maturity_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vega.Future.maturity)
}
inline std::string* Future::_internal_mutable_maturity() {

  return maturity_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Future::release_maturity() {
  // @@protoc_insertion_point(field_release:vega.Future.maturity)
  return maturity_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Future::set_allocated_maturity(std::string* maturity) {
  if (maturity != nullptr) {

  } else {

  }
  maturity_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), maturity,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vega.Future.maturity)
}

// string settlementAsset = 2 [json_name = "settlementAsset"];
inline void Future::clear_settlementasset() {
  settlementasset_.ClearToEmpty();
}
inline const std::string& Future::settlementasset() const {
  // @@protoc_insertion_point(field_get:vega.Future.settlementAsset)
  return _internal_settlementasset();
}
inline void Future::set_settlementasset(const std::string& value) {
  _internal_set_settlementasset(value);
  // @@protoc_insertion_point(field_set:vega.Future.settlementAsset)
}
inline std::string* Future::mutable_settlementasset() {
  // @@protoc_insertion_point(field_mutable:vega.Future.settlementAsset)
  return _internal_mutable_settlementasset();
}
inline const std::string& Future::_internal_settlementasset() const {
  return settlementasset_.Get();
}
inline void Future::_internal_set_settlementasset(const std::string& value) {

  settlementasset_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Future::set_settlementasset(std::string&& value) {

  settlementasset_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vega.Future.settlementAsset)
}
inline void Future::set_settlementasset(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  settlementasset_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:vega.Future.settlementAsset)
}
inline void Future::set_settlementasset(const char* value,
    size_t size) {

  settlementasset_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vega.Future.settlementAsset)
}
inline std::string* Future::_internal_mutable_settlementasset() {

  return settlementasset_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Future::release_settlementasset() {
  // @@protoc_insertion_point(field_release:vega.Future.settlementAsset)
  return settlementasset_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Future::set_allocated_settlementasset(std::string* settlementasset) {
  if (settlementasset != nullptr) {

  } else {

  }
  settlementasset_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), settlementasset,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vega.Future.settlementAsset)
}

// string quoteName = 4 [json_name = "quoteName"];
inline void Future::clear_quotename() {
  quotename_.ClearToEmpty();
}
inline const std::string& Future::quotename() const {
  // @@protoc_insertion_point(field_get:vega.Future.quoteName)
  return _internal_quotename();
}
inline void Future::set_quotename(const std::string& value) {
  _internal_set_quotename(value);
  // @@protoc_insertion_point(field_set:vega.Future.quoteName)
}
inline std::string* Future::mutable_quotename() {
  // @@protoc_insertion_point(field_mutable:vega.Future.quoteName)
  return _internal_mutable_quotename();
}
inline const std::string& Future::_internal_quotename() const {
  return quotename_.Get();
}
inline void Future::_internal_set_quotename(const std::string& value) {

  quotename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Future::set_quotename(std::string&& value) {

  quotename_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vega.Future.quoteName)
}
inline void Future::set_quotename(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  quotename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:vega.Future.quoteName)
}
inline void Future::set_quotename(const char* value,
    size_t size) {

  quotename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vega.Future.quoteName)
}
inline std::string* Future::_internal_mutable_quotename() {

  return quotename_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Future::release_quotename() {
  // @@protoc_insertion_point(field_release:vega.Future.quoteName)
  return quotename_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Future::set_allocated_quotename(std::string* quotename) {
  if (quotename != nullptr) {

  } else {

  }
  quotename_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), quotename,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vega.Future.quoteName)
}

// .vega.EthereumEvent ethereumEvent = 100 [json_name = "ethereumEvent"];
inline bool Future::_internal_has_ethereumevent() const {
  return oracle_case() == kEthereumEvent;
}
inline bool Future::has_ethereumevent() const {
  return _internal_has_ethereumevent();
}
inline void Future::set_has_ethereumevent() {
  _oneof_case_[0] = kEthereumEvent;
}
inline void Future::clear_ethereumevent() {
  if (_internal_has_ethereumevent()) {
    if (GetArena() == nullptr) {
      delete oracle_.ethereumevent_;
    }
    clear_has_oracle();
  }
}
inline ::vega::EthereumEvent* Future::release_ethereumevent() {
  // @@protoc_insertion_point(field_release:vega.Future.ethereumEvent)
  if (_internal_has_ethereumevent()) {
    clear_has_oracle();
      ::vega::EthereumEvent* temp = oracle_.ethereumevent_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    oracle_.ethereumevent_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vega::EthereumEvent& Future::_internal_ethereumevent() const {
  return _internal_has_ethereumevent()
      ? *oracle_.ethereumevent_
      : reinterpret_cast< ::vega::EthereumEvent&>(::vega::_EthereumEvent_default_instance_);
}
inline const ::vega::EthereumEvent& Future::ethereumevent() const {
  // @@protoc_insertion_point(field_get:vega.Future.ethereumEvent)
  return _internal_ethereumevent();
}
inline ::vega::EthereumEvent* Future::unsafe_arena_release_ethereumevent() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vega.Future.ethereumEvent)
  if (_internal_has_ethereumevent()) {
    clear_has_oracle();
    ::vega::EthereumEvent* temp = oracle_.ethereumevent_;
    oracle_.ethereumevent_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Future::unsafe_arena_set_allocated_ethereumevent(::vega::EthereumEvent* ethereumevent) {
  clear_oracle();
  if (ethereumevent) {
    set_has_ethereumevent();
    oracle_.ethereumevent_ = ethereumevent;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vega.Future.ethereumEvent)
}
inline ::vega::EthereumEvent* Future::_internal_mutable_ethereumevent() {
  if (!_internal_has_ethereumevent()) {
    clear_oracle();
    set_has_ethereumevent();
    oracle_.ethereumevent_ = CreateMaybeMessage< ::vega::EthereumEvent >(GetArena());
  }
  return oracle_.ethereumevent_;
}
inline ::vega::EthereumEvent* Future::mutable_ethereumevent() {
  // @@protoc_insertion_point(field_mutable:vega.Future.ethereumEvent)
  return _internal_mutable_ethereumevent();
}

inline bool Future::has_oracle() const {
  return oracle_case() != ORACLE_NOT_SET;
}
inline void Future::clear_has_oracle() {
  _oneof_case_[0] = ORACLE_NOT_SET;
}
inline Future::OracleCase Future::oracle_case() const {
  return Future::OracleCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// EthereumEvent

// string contractID = 1 [json_name = "contractID"];
inline void EthereumEvent::clear_contractid() {
  contractid_.ClearToEmpty();
}
inline const std::string& EthereumEvent::contractid() const {
  // @@protoc_insertion_point(field_get:vega.EthereumEvent.contractID)
  return _internal_contractid();
}
inline void EthereumEvent::set_contractid(const std::string& value) {
  _internal_set_contractid(value);
  // @@protoc_insertion_point(field_set:vega.EthereumEvent.contractID)
}
inline std::string* EthereumEvent::mutable_contractid() {
  // @@protoc_insertion_point(field_mutable:vega.EthereumEvent.contractID)
  return _internal_mutable_contractid();
}
inline const std::string& EthereumEvent::_internal_contractid() const {
  return contractid_.Get();
}
inline void EthereumEvent::_internal_set_contractid(const std::string& value) {

  contractid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void EthereumEvent::set_contractid(std::string&& value) {

  contractid_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vega.EthereumEvent.contractID)
}
inline void EthereumEvent::set_contractid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  contractid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:vega.EthereumEvent.contractID)
}
inline void EthereumEvent::set_contractid(const char* value,
    size_t size) {

  contractid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vega.EthereumEvent.contractID)
}
inline std::string* EthereumEvent::_internal_mutable_contractid() {

  return contractid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* EthereumEvent::release_contractid() {
  // @@protoc_insertion_point(field_release:vega.EthereumEvent.contractID)
  return contractid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void EthereumEvent::set_allocated_contractid(std::string* contractid) {
  if (contractid != nullptr) {

  } else {

  }
  contractid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), contractid,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vega.EthereumEvent.contractID)
}

// string event = 2 [json_name = "event"];
inline void EthereumEvent::clear_event() {
  event_.ClearToEmpty();
}
inline const std::string& EthereumEvent::event() const {
  // @@protoc_insertion_point(field_get:vega.EthereumEvent.event)
  return _internal_event();
}
inline void EthereumEvent::set_event(const std::string& value) {
  _internal_set_event(value);
  // @@protoc_insertion_point(field_set:vega.EthereumEvent.event)
}
inline std::string* EthereumEvent::mutable_event() {
  // @@protoc_insertion_point(field_mutable:vega.EthereumEvent.event)
  return _internal_mutable_event();
}
inline const std::string& EthereumEvent::_internal_event() const {
  return event_.Get();
}
inline void EthereumEvent::_internal_set_event(const std::string& value) {

  event_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void EthereumEvent::set_event(std::string&& value) {

  event_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vega.EthereumEvent.event)
}
inline void EthereumEvent::set_event(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  event_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:vega.EthereumEvent.event)
}
inline void EthereumEvent::set_event(const char* value,
    size_t size) {

  event_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vega.EthereumEvent.event)
}
inline std::string* EthereumEvent::_internal_mutable_event() {

  return event_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* EthereumEvent::release_event() {
  // @@protoc_insertion_point(field_release:vega.EthereumEvent.event)
  return event_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void EthereumEvent::set_allocated_event(std::string* event) {
  if (event != nullptr) {

  } else {

  }
  event_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), event,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vega.EthereumEvent.event)
}

// uint64 value = 3 [json_name = "value"];
inline void EthereumEvent::clear_value() {
  value_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 EthereumEvent::_internal_value() const {
  return value_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 EthereumEvent::value() const {
  // @@protoc_insertion_point(field_get:vega.EthereumEvent.value)
  return _internal_value();
}
inline void EthereumEvent::_internal_set_value(::PROTOBUF_NAMESPACE_ID::uint64 value) {

  value_ = value;
}
inline void EthereumEvent::set_value(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:vega.EthereumEvent.value)
}

// -------------------------------------------------------------------

// InstrumentMetadata

// repeated string tags = 1 [json_name = "tags"];
inline int InstrumentMetadata::_internal_tags_size() const {
  return tags_.size();
}
inline int InstrumentMetadata::tags_size() const {
  return _internal_tags_size();
}
inline void InstrumentMetadata::clear_tags() {
  tags_.Clear();
}
inline std::string* InstrumentMetadata::add_tags() {
  // @@protoc_insertion_point(field_add_mutable:vega.InstrumentMetadata.tags)
  return _internal_add_tags();
}
inline const std::string& InstrumentMetadata::_internal_tags(int index) const {
  return tags_.Get(index);
}
inline const std::string& InstrumentMetadata::tags(int index) const {
  // @@protoc_insertion_point(field_get:vega.InstrumentMetadata.tags)
  return _internal_tags(index);
}
inline std::string* InstrumentMetadata::mutable_tags(int index) {
  // @@protoc_insertion_point(field_mutable:vega.InstrumentMetadata.tags)
  return tags_.Mutable(index);
}
inline void InstrumentMetadata::set_tags(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:vega.InstrumentMetadata.tags)
  tags_.Mutable(index)->assign(value);
}
inline void InstrumentMetadata::set_tags(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:vega.InstrumentMetadata.tags)
  tags_.Mutable(index)->assign(std::move(value));
}
inline void InstrumentMetadata::set_tags(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  tags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:vega.InstrumentMetadata.tags)
}
inline void InstrumentMetadata::set_tags(int index, const char* value, size_t size) {
  tags_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:vega.InstrumentMetadata.tags)
}
inline std::string* InstrumentMetadata::_internal_add_tags() {
  return tags_.Add();
}
inline void InstrumentMetadata::add_tags(const std::string& value) {
  tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:vega.InstrumentMetadata.tags)
}
inline void InstrumentMetadata::add_tags(std::string&& value) {
  tags_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:vega.InstrumentMetadata.tags)
}
inline void InstrumentMetadata::add_tags(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:vega.InstrumentMetadata.tags)
}
inline void InstrumentMetadata::add_tags(const char* value, size_t size) {
  tags_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:vega.InstrumentMetadata.tags)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
InstrumentMetadata::tags() const {
  // @@protoc_insertion_point(field_list:vega.InstrumentMetadata.tags)
  return tags_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
InstrumentMetadata::mutable_tags() {
  // @@protoc_insertion_point(field_mutable_list:vega.InstrumentMetadata.tags)
  return &tags_;
}

// -------------------------------------------------------------------

// Instrument

// string id = 1 [json_name = "id"];
inline void Instrument::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& Instrument::id() const {
  // @@protoc_insertion_point(field_get:vega.Instrument.id)
  return _internal_id();
}
inline void Instrument::set_id(const std::string& value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:vega.Instrument.id)
}
inline std::string* Instrument::mutable_id() {
  // @@protoc_insertion_point(field_mutable:vega.Instrument.id)
  return _internal_mutable_id();
}
inline const std::string& Instrument::_internal_id() const {
  return id_.Get();
}
inline void Instrument::_internal_set_id(const std::string& value) {

  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Instrument::set_id(std::string&& value) {

  id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vega.Instrument.id)
}
inline void Instrument::set_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:vega.Instrument.id)
}
inline void Instrument::set_id(const char* value,
    size_t size) {

  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vega.Instrument.id)
}
inline std::string* Instrument::_internal_mutable_id() {

  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Instrument::release_id() {
  // @@protoc_insertion_point(field_release:vega.Instrument.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Instrument::set_allocated_id(std::string* id) {
  if (id != nullptr) {

  } else {

  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vega.Instrument.id)
}

// string code = 2 [json_name = "code"];
inline void Instrument::clear_code() {
  code_.ClearToEmpty();
}
inline const std::string& Instrument::code() const {
  // @@protoc_insertion_point(field_get:vega.Instrument.code)
  return _internal_code();
}
inline void Instrument::set_code(const std::string& value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:vega.Instrument.code)
}
inline std::string* Instrument::mutable_code() {
  // @@protoc_insertion_point(field_mutable:vega.Instrument.code)
  return _internal_mutable_code();
}
inline const std::string& Instrument::_internal_code() const {
  return code_.Get();
}
inline void Instrument::_internal_set_code(const std::string& value) {

  code_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Instrument::set_code(std::string&& value) {

  code_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vega.Instrument.code)
}
inline void Instrument::set_code(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  code_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:vega.Instrument.code)
}
inline void Instrument::set_code(const char* value,
    size_t size) {

  code_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vega.Instrument.code)
}
inline std::string* Instrument::_internal_mutable_code() {

  return code_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Instrument::release_code() {
  // @@protoc_insertion_point(field_release:vega.Instrument.code)
  return code_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Instrument::set_allocated_code(std::string* code) {
  if (code != nullptr) {

  } else {

  }
  code_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), code,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vega.Instrument.code)
}

// string name = 3 [json_name = "name"];
inline void Instrument::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& Instrument::name() const {
  // @@protoc_insertion_point(field_get:vega.Instrument.name)
  return _internal_name();
}
inline void Instrument::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:vega.Instrument.name)
}
inline std::string* Instrument::mutable_name() {
  // @@protoc_insertion_point(field_mutable:vega.Instrument.name)
  return _internal_mutable_name();
}
inline const std::string& Instrument::_internal_name() const {
  return name_.Get();
}
inline void Instrument::_internal_set_name(const std::string& value) {

  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Instrument::set_name(std::string&& value) {

  name_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vega.Instrument.name)
}
inline void Instrument::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:vega.Instrument.name)
}
inline void Instrument::set_name(const char* value,
    size_t size) {

  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vega.Instrument.name)
}
inline std::string* Instrument::_internal_mutable_name() {

  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Instrument::release_name() {
  // @@protoc_insertion_point(field_release:vega.Instrument.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Instrument::set_allocated_name(std::string* name) {
  if (name != nullptr) {

  } else {

  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vega.Instrument.name)
}

// .vega.InstrumentMetadata metadata = 4 [json_name = "metadata"];
inline bool Instrument::_internal_has_metadata() const {
  return this != internal_default_instance() && metadata_ != nullptr;
}
inline bool Instrument::has_metadata() const {
  return _internal_has_metadata();
}
inline void Instrument::clear_metadata() {
  if (GetArena() == nullptr && metadata_ != nullptr) {
    delete metadata_;
  }
  metadata_ = nullptr;
}
inline const ::vega::InstrumentMetadata& Instrument::_internal_metadata() const {
  const ::vega::InstrumentMetadata* p = metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::vega::InstrumentMetadata&>(
      ::vega::_InstrumentMetadata_default_instance_);
}
inline const ::vega::InstrumentMetadata& Instrument::metadata() const {
  // @@protoc_insertion_point(field_get:vega.Instrument.metadata)
  return _internal_metadata();
}
inline void Instrument::unsafe_arena_set_allocated_metadata(
    ::vega::InstrumentMetadata* metadata) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata_);
  }
  metadata_ = metadata;
  if (metadata) {

  } else {

  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vega.Instrument.metadata)
}
inline ::vega::InstrumentMetadata* Instrument::release_metadata() {

  ::vega::InstrumentMetadata* temp = metadata_;
  metadata_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::vega::InstrumentMetadata* Instrument::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:vega.Instrument.metadata)

  ::vega::InstrumentMetadata* temp = metadata_;
  metadata_ = nullptr;
  return temp;
}
inline ::vega::InstrumentMetadata* Instrument::_internal_mutable_metadata() {

  if (metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::vega::InstrumentMetadata>(GetArena());
    metadata_ = p;
  }
  return metadata_;
}
inline ::vega::InstrumentMetadata* Instrument::mutable_metadata() {
  // @@protoc_insertion_point(field_mutable:vega.Instrument.metadata)
  return _internal_mutable_metadata();
}
inline void Instrument::set_allocated_metadata(::vega::InstrumentMetadata* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete metadata_;
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(metadata);
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }

  } else {

  }
  metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:vega.Instrument.metadata)
}

// uint64 initialMarkPrice = 5 [json_name = "initialMarkPrice"];
inline void Instrument::clear_initialmarkprice() {
  initialmarkprice_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Instrument::_internal_initialmarkprice() const {
  return initialmarkprice_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Instrument::initialmarkprice() const {
  // @@protoc_insertion_point(field_get:vega.Instrument.initialMarkPrice)
  return _internal_initialmarkprice();
}
inline void Instrument::_internal_set_initialmarkprice(::PROTOBUF_NAMESPACE_ID::uint64 value) {

  initialmarkprice_ = value;
}
inline void Instrument::set_initialmarkprice(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_initialmarkprice(value);
  // @@protoc_insertion_point(field_set:vega.Instrument.initialMarkPrice)
}

// .vega.Future future = 100 [json_name = "future"];
inline bool Instrument::_internal_has_future() const {
  return product_case() == kFuture;
}
inline bool Instrument::has_future() const {
  return _internal_has_future();
}
inline void Instrument::set_has_future() {
  _oneof_case_[0] = kFuture;
}
inline void Instrument::clear_future() {
  if (_internal_has_future()) {
    if (GetArena() == nullptr) {
      delete product_.future_;
    }
    clear_has_product();
  }
}
inline ::vega::Future* Instrument::release_future() {
  // @@protoc_insertion_point(field_release:vega.Instrument.future)
  if (_internal_has_future()) {
    clear_has_product();
      ::vega::Future* temp = product_.future_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    product_.future_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vega::Future& Instrument::_internal_future() const {
  return _internal_has_future()
      ? *product_.future_
      : reinterpret_cast< ::vega::Future&>(::vega::_Future_default_instance_);
}
inline const ::vega::Future& Instrument::future() const {
  // @@protoc_insertion_point(field_get:vega.Instrument.future)
  return _internal_future();
}
inline ::vega::Future* Instrument::unsafe_arena_release_future() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vega.Instrument.future)
  if (_internal_has_future()) {
    clear_has_product();
    ::vega::Future* temp = product_.future_;
    product_.future_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Instrument::unsafe_arena_set_allocated_future(::vega::Future* future) {
  clear_product();
  if (future) {
    set_has_future();
    product_.future_ = future;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vega.Instrument.future)
}
inline ::vega::Future* Instrument::_internal_mutable_future() {
  if (!_internal_has_future()) {
    clear_product();
    set_has_future();
    product_.future_ = CreateMaybeMessage< ::vega::Future >(GetArena());
  }
  return product_.future_;
}
inline ::vega::Future* Instrument::mutable_future() {
  // @@protoc_insertion_point(field_mutable:vega.Instrument.future)
  return _internal_mutable_future();
}

inline bool Instrument::has_product() const {
  return product_case() != PRODUCT_NOT_SET;
}
inline void Instrument::clear_has_product() {
  _oneof_case_[0] = PRODUCT_NOT_SET;
}
inline Instrument::ProductCase Instrument::product_case() const {
  return Instrument::ProductCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// LogNormalRiskModel

// double riskAversionParameter = 1 [json_name = "riskAversionParameter"];
inline void LogNormalRiskModel::clear_riskaversionparameter() {
  riskaversionparameter_ = 0;
}
inline double LogNormalRiskModel::_internal_riskaversionparameter() const {
  return riskaversionparameter_;
}
inline double LogNormalRiskModel::riskaversionparameter() const {
  // @@protoc_insertion_point(field_get:vega.LogNormalRiskModel.riskAversionParameter)
  return _internal_riskaversionparameter();
}
inline void LogNormalRiskModel::_internal_set_riskaversionparameter(double value) {

  riskaversionparameter_ = value;
}
inline void LogNormalRiskModel::set_riskaversionparameter(double value) {
  _internal_set_riskaversionparameter(value);
  // @@protoc_insertion_point(field_set:vega.LogNormalRiskModel.riskAversionParameter)
}

// double tau = 2 [json_name = "tau"];
inline void LogNormalRiskModel::clear_tau() {
  tau_ = 0;
}
inline double LogNormalRiskModel::_internal_tau() const {
  return tau_;
}
inline double LogNormalRiskModel::tau() const {
  // @@protoc_insertion_point(field_get:vega.LogNormalRiskModel.tau)
  return _internal_tau();
}
inline void LogNormalRiskModel::_internal_set_tau(double value) {

  tau_ = value;
}
inline void LogNormalRiskModel::set_tau(double value) {
  _internal_set_tau(value);
  // @@protoc_insertion_point(field_set:vega.LogNormalRiskModel.tau)
}

// .vega.LogNormalModelParams params = 3 [json_name = "params"];
inline bool LogNormalRiskModel::_internal_has_params() const {
  return this != internal_default_instance() && params_ != nullptr;
}
inline bool LogNormalRiskModel::has_params() const {
  return _internal_has_params();
}
inline void LogNormalRiskModel::clear_params() {
  if (GetArena() == nullptr && params_ != nullptr) {
    delete params_;
  }
  params_ = nullptr;
}
inline const ::vega::LogNormalModelParams& LogNormalRiskModel::_internal_params() const {
  const ::vega::LogNormalModelParams* p = params_;
  return p != nullptr ? *p : reinterpret_cast<const ::vega::LogNormalModelParams&>(
      ::vega::_LogNormalModelParams_default_instance_);
}
inline const ::vega::LogNormalModelParams& LogNormalRiskModel::params() const {
  // @@protoc_insertion_point(field_get:vega.LogNormalRiskModel.params)
  return _internal_params();
}
inline void LogNormalRiskModel::unsafe_arena_set_allocated_params(
    ::vega::LogNormalModelParams* params) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(params_);
  }
  params_ = params;
  if (params) {

  } else {

  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vega.LogNormalRiskModel.params)
}
inline ::vega::LogNormalModelParams* LogNormalRiskModel::release_params() {

  ::vega::LogNormalModelParams* temp = params_;
  params_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::vega::LogNormalModelParams* LogNormalRiskModel::unsafe_arena_release_params() {
  // @@protoc_insertion_point(field_release:vega.LogNormalRiskModel.params)

  ::vega::LogNormalModelParams* temp = params_;
  params_ = nullptr;
  return temp;
}
inline ::vega::LogNormalModelParams* LogNormalRiskModel::_internal_mutable_params() {

  if (params_ == nullptr) {
    auto* p = CreateMaybeMessage<::vega::LogNormalModelParams>(GetArena());
    params_ = p;
  }
  return params_;
}
inline ::vega::LogNormalModelParams* LogNormalRiskModel::mutable_params() {
  // @@protoc_insertion_point(field_mutable:vega.LogNormalRiskModel.params)
  return _internal_mutable_params();
}
inline void LogNormalRiskModel::set_allocated_params(::vega::LogNormalModelParams* params) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete params_;
  }
  if (params) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(params);
    if (message_arena != submessage_arena) {
      params = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, params, submessage_arena);
    }

  } else {

  }
  params_ = params;
  // @@protoc_insertion_point(field_set_allocated:vega.LogNormalRiskModel.params)
}

// -------------------------------------------------------------------

// LogNormalModelParams

// double mu = 1 [json_name = "mu"];
inline void LogNormalModelParams::clear_mu() {
  mu_ = 0;
}
inline double LogNormalModelParams::_internal_mu() const {
  return mu_;
}
inline double LogNormalModelParams::mu() const {
  // @@protoc_insertion_point(field_get:vega.LogNormalModelParams.mu)
  return _internal_mu();
}
inline void LogNormalModelParams::_internal_set_mu(double value) {

  mu_ = value;
}
inline void LogNormalModelParams::set_mu(double value) {
  _internal_set_mu(value);
  // @@protoc_insertion_point(field_set:vega.LogNormalModelParams.mu)
}

// double r = 2 [json_name = "r"];
inline void LogNormalModelParams::clear_r() {
  r_ = 0;
}
inline double LogNormalModelParams::_internal_r() const {
  return r_;
}
inline double LogNormalModelParams::r() const {
  // @@protoc_insertion_point(field_get:vega.LogNormalModelParams.r)
  return _internal_r();
}
inline void LogNormalModelParams::_internal_set_r(double value) {

  r_ = value;
}
inline void LogNormalModelParams::set_r(double value) {
  _internal_set_r(value);
  // @@protoc_insertion_point(field_set:vega.LogNormalModelParams.r)
}

// double sigma = 3 [json_name = "sigma"];
inline void LogNormalModelParams::clear_sigma() {
  sigma_ = 0;
}
inline double LogNormalModelParams::_internal_sigma() const {
  return sigma_;
}
inline double LogNormalModelParams::sigma() const {
  // @@protoc_insertion_point(field_get:vega.LogNormalModelParams.sigma)
  return _internal_sigma();
}
inline void LogNormalModelParams::_internal_set_sigma(double value) {

  sigma_ = value;
}
inline void LogNormalModelParams::set_sigma(double value) {
  _internal_set_sigma(value);
  // @@protoc_insertion_point(field_set:vega.LogNormalModelParams.sigma)
}

// -------------------------------------------------------------------

// SimpleRiskModel

// .vega.SimpleModelParams params = 1 [json_name = "params"];
inline bool SimpleRiskModel::_internal_has_params() const {
  return this != internal_default_instance() && params_ != nullptr;
}
inline bool SimpleRiskModel::has_params() const {
  return _internal_has_params();
}
inline void SimpleRiskModel::clear_params() {
  if (GetArena() == nullptr && params_ != nullptr) {
    delete params_;
  }
  params_ = nullptr;
}
inline const ::vega::SimpleModelParams& SimpleRiskModel::_internal_params() const {
  const ::vega::SimpleModelParams* p = params_;
  return p != nullptr ? *p : reinterpret_cast<const ::vega::SimpleModelParams&>(
      ::vega::_SimpleModelParams_default_instance_);
}
inline const ::vega::SimpleModelParams& SimpleRiskModel::params() const {
  // @@protoc_insertion_point(field_get:vega.SimpleRiskModel.params)
  return _internal_params();
}
inline void SimpleRiskModel::unsafe_arena_set_allocated_params(
    ::vega::SimpleModelParams* params) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(params_);
  }
  params_ = params;
  if (params) {

  } else {

  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vega.SimpleRiskModel.params)
}
inline ::vega::SimpleModelParams* SimpleRiskModel::release_params() {

  ::vega::SimpleModelParams* temp = params_;
  params_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::vega::SimpleModelParams* SimpleRiskModel::unsafe_arena_release_params() {
  // @@protoc_insertion_point(field_release:vega.SimpleRiskModel.params)

  ::vega::SimpleModelParams* temp = params_;
  params_ = nullptr;
  return temp;
}
inline ::vega::SimpleModelParams* SimpleRiskModel::_internal_mutable_params() {

  if (params_ == nullptr) {
    auto* p = CreateMaybeMessage<::vega::SimpleModelParams>(GetArena());
    params_ = p;
  }
  return params_;
}
inline ::vega::SimpleModelParams* SimpleRiskModel::mutable_params() {
  // @@protoc_insertion_point(field_mutable:vega.SimpleRiskModel.params)
  return _internal_mutable_params();
}
inline void SimpleRiskModel::set_allocated_params(::vega::SimpleModelParams* params) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete params_;
  }
  if (params) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(params);
    if (message_arena != submessage_arena) {
      params = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, params, submessage_arena);
    }

  } else {

  }
  params_ = params;
  // @@protoc_insertion_point(field_set_allocated:vega.SimpleRiskModel.params)
}

// -------------------------------------------------------------------

// SimpleModelParams

// double factorLong = 1 [json_name = "factorLong"];
inline void SimpleModelParams::clear_factorlong() {
  factorlong_ = 0;
}
inline double SimpleModelParams::_internal_factorlong() const {
  return factorlong_;
}
inline double SimpleModelParams::factorlong() const {
  // @@protoc_insertion_point(field_get:vega.SimpleModelParams.factorLong)
  return _internal_factorlong();
}
inline void SimpleModelParams::_internal_set_factorlong(double value) {

  factorlong_ = value;
}
inline void SimpleModelParams::set_factorlong(double value) {
  _internal_set_factorlong(value);
  // @@protoc_insertion_point(field_set:vega.SimpleModelParams.factorLong)
}

// double factorShort = 2 [json_name = "factorShort"];
inline void SimpleModelParams::clear_factorshort() {
  factorshort_ = 0;
}
inline double SimpleModelParams::_internal_factorshort() const {
  return factorshort_;
}
inline double SimpleModelParams::factorshort() const {
  // @@protoc_insertion_point(field_get:vega.SimpleModelParams.factorShort)
  return _internal_factorshort();
}
inline void SimpleModelParams::_internal_set_factorshort(double value) {

  factorshort_ = value;
}
inline void SimpleModelParams::set_factorshort(double value) {
  _internal_set_factorshort(value);
  // @@protoc_insertion_point(field_set:vega.SimpleModelParams.factorShort)
}

// double maxMoveUp = 3 [json_name = "maxMoveUp", (.validator.field) = {
inline void SimpleModelParams::clear_maxmoveup() {
  maxmoveup_ = 0;
}
inline double SimpleModelParams::_internal_maxmoveup() const {
  return maxmoveup_;
}
inline double SimpleModelParams::maxmoveup() const {
  // @@protoc_insertion_point(field_get:vega.SimpleModelParams.maxMoveUp)
  return _internal_maxmoveup();
}
inline void SimpleModelParams::_internal_set_maxmoveup(double value) {

  maxmoveup_ = value;
}
inline void SimpleModelParams::set_maxmoveup(double value) {
  _internal_set_maxmoveup(value);
  // @@protoc_insertion_point(field_set:vega.SimpleModelParams.maxMoveUp)
}

// double minMoveDown = 4 [json_name = "minMoveDown", (.validator.field) = {
inline void SimpleModelParams::clear_minmovedown() {
  minmovedown_ = 0;
}
inline double SimpleModelParams::_internal_minmovedown() const {
  return minmovedown_;
}
inline double SimpleModelParams::minmovedown() const {
  // @@protoc_insertion_point(field_get:vega.SimpleModelParams.minMoveDown)
  return _internal_minmovedown();
}
inline void SimpleModelParams::_internal_set_minmovedown(double value) {

  minmovedown_ = value;
}
inline void SimpleModelParams::set_minmovedown(double value) {
  _internal_set_minmovedown(value);
  // @@protoc_insertion_point(field_set:vega.SimpleModelParams.minMoveDown)
}

// double probabilityOfTrading = 5 [json_name = "probabilityOfTrading", (.validator.field) = {
inline void SimpleModelParams::clear_probabilityoftrading() {
  probabilityoftrading_ = 0;
}
inline double SimpleModelParams::_internal_probabilityoftrading() const {
  return probabilityoftrading_;
}
inline double SimpleModelParams::probabilityoftrading() const {
  // @@protoc_insertion_point(field_get:vega.SimpleModelParams.probabilityOfTrading)
  return _internal_probabilityoftrading();
}
inline void SimpleModelParams::_internal_set_probabilityoftrading(double value) {

  probabilityoftrading_ = value;
}
inline void SimpleModelParams::set_probabilityoftrading(double value) {
  _internal_set_probabilityoftrading(value);
  // @@protoc_insertion_point(field_set:vega.SimpleModelParams.probabilityOfTrading)
}

// -------------------------------------------------------------------

// ScalingFactors

// double searchLevel = 1 [json_name = "searchLevel"];
inline void ScalingFactors::clear_searchlevel() {
  searchlevel_ = 0;
}
inline double ScalingFactors::_internal_searchlevel() const {
  return searchlevel_;
}
inline double ScalingFactors::searchlevel() const {
  // @@protoc_insertion_point(field_get:vega.ScalingFactors.searchLevel)
  return _internal_searchlevel();
}
inline void ScalingFactors::_internal_set_searchlevel(double value) {

  searchlevel_ = value;
}
inline void ScalingFactors::set_searchlevel(double value) {
  _internal_set_searchlevel(value);
  // @@protoc_insertion_point(field_set:vega.ScalingFactors.searchLevel)
}

// double initialMargin = 2 [json_name = "initialMargin"];
inline void ScalingFactors::clear_initialmargin() {
  initialmargin_ = 0;
}
inline double ScalingFactors::_internal_initialmargin() const {
  return initialmargin_;
}
inline double ScalingFactors::initialmargin() const {
  // @@protoc_insertion_point(field_get:vega.ScalingFactors.initialMargin)
  return _internal_initialmargin();
}
inline void ScalingFactors::_internal_set_initialmargin(double value) {

  initialmargin_ = value;
}
inline void ScalingFactors::set_initialmargin(double value) {
  _internal_set_initialmargin(value);
  // @@protoc_insertion_point(field_set:vega.ScalingFactors.initialMargin)
}

// double collateralRelease = 3 [json_name = "collateralRelease"];
inline void ScalingFactors::clear_collateralrelease() {
  collateralrelease_ = 0;
}
inline double ScalingFactors::_internal_collateralrelease() const {
  return collateralrelease_;
}
inline double ScalingFactors::collateralrelease() const {
  // @@protoc_insertion_point(field_get:vega.ScalingFactors.collateralRelease)
  return _internal_collateralrelease();
}
inline void ScalingFactors::_internal_set_collateralrelease(double value) {

  collateralrelease_ = value;
}
inline void ScalingFactors::set_collateralrelease(double value) {
  _internal_set_collateralrelease(value);
  // @@protoc_insertion_point(field_set:vega.ScalingFactors.collateralRelease)
}

// -------------------------------------------------------------------

// MarginCalculator

// .vega.ScalingFactors scalingFactors = 1 [json_name = "scalingFactors"];
inline bool MarginCalculator::_internal_has_scalingfactors() const {
  return this != internal_default_instance() && scalingfactors_ != nullptr;
}
inline bool MarginCalculator::has_scalingfactors() const {
  return _internal_has_scalingfactors();
}
inline void MarginCalculator::clear_scalingfactors() {
  if (GetArena() == nullptr && scalingfactors_ != nullptr) {
    delete scalingfactors_;
  }
  scalingfactors_ = nullptr;
}
inline const ::vega::ScalingFactors& MarginCalculator::_internal_scalingfactors() const {
  const ::vega::ScalingFactors* p = scalingfactors_;
  return p != nullptr ? *p : reinterpret_cast<const ::vega::ScalingFactors&>(
      ::vega::_ScalingFactors_default_instance_);
}
inline const ::vega::ScalingFactors& MarginCalculator::scalingfactors() const {
  // @@protoc_insertion_point(field_get:vega.MarginCalculator.scalingFactors)
  return _internal_scalingfactors();
}
inline void MarginCalculator::unsafe_arena_set_allocated_scalingfactors(
    ::vega::ScalingFactors* scalingfactors) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(scalingfactors_);
  }
  scalingfactors_ = scalingfactors;
  if (scalingfactors) {

  } else {

  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vega.MarginCalculator.scalingFactors)
}
inline ::vega::ScalingFactors* MarginCalculator::release_scalingfactors() {

  ::vega::ScalingFactors* temp = scalingfactors_;
  scalingfactors_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::vega::ScalingFactors* MarginCalculator::unsafe_arena_release_scalingfactors() {
  // @@protoc_insertion_point(field_release:vega.MarginCalculator.scalingFactors)

  ::vega::ScalingFactors* temp = scalingfactors_;
  scalingfactors_ = nullptr;
  return temp;
}
inline ::vega::ScalingFactors* MarginCalculator::_internal_mutable_scalingfactors() {

  if (scalingfactors_ == nullptr) {
    auto* p = CreateMaybeMessage<::vega::ScalingFactors>(GetArena());
    scalingfactors_ = p;
  }
  return scalingfactors_;
}
inline ::vega::ScalingFactors* MarginCalculator::mutable_scalingfactors() {
  // @@protoc_insertion_point(field_mutable:vega.MarginCalculator.scalingFactors)
  return _internal_mutable_scalingfactors();
}
inline void MarginCalculator::set_allocated_scalingfactors(::vega::ScalingFactors* scalingfactors) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete scalingfactors_;
  }
  if (scalingfactors) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(scalingfactors);
    if (message_arena != submessage_arena) {
      scalingfactors = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, scalingfactors, submessage_arena);
    }

  } else {

  }
  scalingfactors_ = scalingfactors;
  // @@protoc_insertion_point(field_set_allocated:vega.MarginCalculator.scalingFactors)
}

// -------------------------------------------------------------------

// TradableInstrument

// .vega.Instrument instrument = 1 [json_name = "instrument"];
inline bool TradableInstrument::_internal_has_instrument() const {
  return this != internal_default_instance() && instrument_ != nullptr;
}
inline bool TradableInstrument::has_instrument() const {
  return _internal_has_instrument();
}
inline void TradableInstrument::clear_instrument() {
  if (GetArena() == nullptr && instrument_ != nullptr) {
    delete instrument_;
  }
  instrument_ = nullptr;
}
inline const ::vega::Instrument& TradableInstrument::_internal_instrument() const {
  const ::vega::Instrument* p = instrument_;
  return p != nullptr ? *p : reinterpret_cast<const ::vega::Instrument&>(
      ::vega::_Instrument_default_instance_);
}
inline const ::vega::Instrument& TradableInstrument::instrument() const {
  // @@protoc_insertion_point(field_get:vega.TradableInstrument.instrument)
  return _internal_instrument();
}
inline void TradableInstrument::unsafe_arena_set_allocated_instrument(
    ::vega::Instrument* instrument) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(instrument_);
  }
  instrument_ = instrument;
  if (instrument) {

  } else {

  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vega.TradableInstrument.instrument)
}
inline ::vega::Instrument* TradableInstrument::release_instrument() {

  ::vega::Instrument* temp = instrument_;
  instrument_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::vega::Instrument* TradableInstrument::unsafe_arena_release_instrument() {
  // @@protoc_insertion_point(field_release:vega.TradableInstrument.instrument)

  ::vega::Instrument* temp = instrument_;
  instrument_ = nullptr;
  return temp;
}
inline ::vega::Instrument* TradableInstrument::_internal_mutable_instrument() {

  if (instrument_ == nullptr) {
    auto* p = CreateMaybeMessage<::vega::Instrument>(GetArena());
    instrument_ = p;
  }
  return instrument_;
}
inline ::vega::Instrument* TradableInstrument::mutable_instrument() {
  // @@protoc_insertion_point(field_mutable:vega.TradableInstrument.instrument)
  return _internal_mutable_instrument();
}
inline void TradableInstrument::set_allocated_instrument(::vega::Instrument* instrument) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete instrument_;
  }
  if (instrument) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(instrument);
    if (message_arena != submessage_arena) {
      instrument = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, instrument, submessage_arena);
    }

  } else {

  }
  instrument_ = instrument;
  // @@protoc_insertion_point(field_set_allocated:vega.TradableInstrument.instrument)
}

// .vega.MarginCalculator marginCalculator = 2 [json_name = "marginCalculator"];
inline bool TradableInstrument::_internal_has_margincalculator() const {
  return this != internal_default_instance() && margincalculator_ != nullptr;
}
inline bool TradableInstrument::has_margincalculator() const {
  return _internal_has_margincalculator();
}
inline void TradableInstrument::clear_margincalculator() {
  if (GetArena() == nullptr && margincalculator_ != nullptr) {
    delete margincalculator_;
  }
  margincalculator_ = nullptr;
}
inline const ::vega::MarginCalculator& TradableInstrument::_internal_margincalculator() const {
  const ::vega::MarginCalculator* p = margincalculator_;
  return p != nullptr ? *p : reinterpret_cast<const ::vega::MarginCalculator&>(
      ::vega::_MarginCalculator_default_instance_);
}
inline const ::vega::MarginCalculator& TradableInstrument::margincalculator() const {
  // @@protoc_insertion_point(field_get:vega.TradableInstrument.marginCalculator)
  return _internal_margincalculator();
}
inline void TradableInstrument::unsafe_arena_set_allocated_margincalculator(
    ::vega::MarginCalculator* margincalculator) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(margincalculator_);
  }
  margincalculator_ = margincalculator;
  if (margincalculator) {

  } else {

  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vega.TradableInstrument.marginCalculator)
}
inline ::vega::MarginCalculator* TradableInstrument::release_margincalculator() {

  ::vega::MarginCalculator* temp = margincalculator_;
  margincalculator_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::vega::MarginCalculator* TradableInstrument::unsafe_arena_release_margincalculator() {
  // @@protoc_insertion_point(field_release:vega.TradableInstrument.marginCalculator)

  ::vega::MarginCalculator* temp = margincalculator_;
  margincalculator_ = nullptr;
  return temp;
}
inline ::vega::MarginCalculator* TradableInstrument::_internal_mutable_margincalculator() {

  if (margincalculator_ == nullptr) {
    auto* p = CreateMaybeMessage<::vega::MarginCalculator>(GetArena());
    margincalculator_ = p;
  }
  return margincalculator_;
}
inline ::vega::MarginCalculator* TradableInstrument::mutable_margincalculator() {
  // @@protoc_insertion_point(field_mutable:vega.TradableInstrument.marginCalculator)
  return _internal_mutable_margincalculator();
}
inline void TradableInstrument::set_allocated_margincalculator(::vega::MarginCalculator* margincalculator) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete margincalculator_;
  }
  if (margincalculator) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(margincalculator);
    if (message_arena != submessage_arena) {
      margincalculator = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, margincalculator, submessage_arena);
    }

  } else {

  }
  margincalculator_ = margincalculator;
  // @@protoc_insertion_point(field_set_allocated:vega.TradableInstrument.marginCalculator)
}

// .vega.LogNormalRiskModel logNormalRiskModel = 100 [json_name = "logNormalRiskModel"];
inline bool TradableInstrument::_internal_has_lognormalriskmodel() const {
  return riskModel_case() == kLogNormalRiskModel;
}
inline bool TradableInstrument::has_lognormalriskmodel() const {
  return _internal_has_lognormalriskmodel();
}
inline void TradableInstrument::set_has_lognormalriskmodel() {
  _oneof_case_[0] = kLogNormalRiskModel;
}
inline void TradableInstrument::clear_lognormalriskmodel() {
  if (_internal_has_lognormalriskmodel()) {
    if (GetArena() == nullptr) {
      delete riskModel_.lognormalriskmodel_;
    }
    clear_has_riskModel();
  }
}
inline ::vega::LogNormalRiskModel* TradableInstrument::release_lognormalriskmodel() {
  // @@protoc_insertion_point(field_release:vega.TradableInstrument.logNormalRiskModel)
  if (_internal_has_lognormalriskmodel()) {
    clear_has_riskModel();
      ::vega::LogNormalRiskModel* temp = riskModel_.lognormalriskmodel_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    riskModel_.lognormalriskmodel_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vega::LogNormalRiskModel& TradableInstrument::_internal_lognormalriskmodel() const {
  return _internal_has_lognormalriskmodel()
      ? *riskModel_.lognormalriskmodel_
      : reinterpret_cast< ::vega::LogNormalRiskModel&>(::vega::_LogNormalRiskModel_default_instance_);
}
inline const ::vega::LogNormalRiskModel& TradableInstrument::lognormalriskmodel() const {
  // @@protoc_insertion_point(field_get:vega.TradableInstrument.logNormalRiskModel)
  return _internal_lognormalriskmodel();
}
inline ::vega::LogNormalRiskModel* TradableInstrument::unsafe_arena_release_lognormalriskmodel() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vega.TradableInstrument.logNormalRiskModel)
  if (_internal_has_lognormalriskmodel()) {
    clear_has_riskModel();
    ::vega::LogNormalRiskModel* temp = riskModel_.lognormalriskmodel_;
    riskModel_.lognormalriskmodel_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TradableInstrument::unsafe_arena_set_allocated_lognormalriskmodel(::vega::LogNormalRiskModel* lognormalriskmodel) {
  clear_riskModel();
  if (lognormalriskmodel) {
    set_has_lognormalriskmodel();
    riskModel_.lognormalriskmodel_ = lognormalriskmodel;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vega.TradableInstrument.logNormalRiskModel)
}
inline ::vega::LogNormalRiskModel* TradableInstrument::_internal_mutable_lognormalriskmodel() {
  if (!_internal_has_lognormalriskmodel()) {
    clear_riskModel();
    set_has_lognormalriskmodel();
    riskModel_.lognormalriskmodel_ = CreateMaybeMessage< ::vega::LogNormalRiskModel >(GetArena());
  }
  return riskModel_.lognormalriskmodel_;
}
inline ::vega::LogNormalRiskModel* TradableInstrument::mutable_lognormalriskmodel() {
  // @@protoc_insertion_point(field_mutable:vega.TradableInstrument.logNormalRiskModel)
  return _internal_mutable_lognormalriskmodel();
}

// .vega.SimpleRiskModel simpleRiskModel = 101 [json_name = "simpleRiskModel"];
inline bool TradableInstrument::_internal_has_simpleriskmodel() const {
  return riskModel_case() == kSimpleRiskModel;
}
inline bool TradableInstrument::has_simpleriskmodel() const {
  return _internal_has_simpleriskmodel();
}
inline void TradableInstrument::set_has_simpleriskmodel() {
  _oneof_case_[0] = kSimpleRiskModel;
}
inline void TradableInstrument::clear_simpleriskmodel() {
  if (_internal_has_simpleriskmodel()) {
    if (GetArena() == nullptr) {
      delete riskModel_.simpleriskmodel_;
    }
    clear_has_riskModel();
  }
}
inline ::vega::SimpleRiskModel* TradableInstrument::release_simpleriskmodel() {
  // @@protoc_insertion_point(field_release:vega.TradableInstrument.simpleRiskModel)
  if (_internal_has_simpleriskmodel()) {
    clear_has_riskModel();
      ::vega::SimpleRiskModel* temp = riskModel_.simpleriskmodel_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    riskModel_.simpleriskmodel_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vega::SimpleRiskModel& TradableInstrument::_internal_simpleriskmodel() const {
  return _internal_has_simpleriskmodel()
      ? *riskModel_.simpleriskmodel_
      : reinterpret_cast< ::vega::SimpleRiskModel&>(::vega::_SimpleRiskModel_default_instance_);
}
inline const ::vega::SimpleRiskModel& TradableInstrument::simpleriskmodel() const {
  // @@protoc_insertion_point(field_get:vega.TradableInstrument.simpleRiskModel)
  return _internal_simpleriskmodel();
}
inline ::vega::SimpleRiskModel* TradableInstrument::unsafe_arena_release_simpleriskmodel() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vega.TradableInstrument.simpleRiskModel)
  if (_internal_has_simpleriskmodel()) {
    clear_has_riskModel();
    ::vega::SimpleRiskModel* temp = riskModel_.simpleriskmodel_;
    riskModel_.simpleriskmodel_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TradableInstrument::unsafe_arena_set_allocated_simpleriskmodel(::vega::SimpleRiskModel* simpleriskmodel) {
  clear_riskModel();
  if (simpleriskmodel) {
    set_has_simpleriskmodel();
    riskModel_.simpleriskmodel_ = simpleriskmodel;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vega.TradableInstrument.simpleRiskModel)
}
inline ::vega::SimpleRiskModel* TradableInstrument::_internal_mutable_simpleriskmodel() {
  if (!_internal_has_simpleriskmodel()) {
    clear_riskModel();
    set_has_simpleriskmodel();
    riskModel_.simpleriskmodel_ = CreateMaybeMessage< ::vega::SimpleRiskModel >(GetArena());
  }
  return riskModel_.simpleriskmodel_;
}
inline ::vega::SimpleRiskModel* TradableInstrument::mutable_simpleriskmodel() {
  // @@protoc_insertion_point(field_mutable:vega.TradableInstrument.simpleRiskModel)
  return _internal_mutable_simpleriskmodel();
}

inline bool TradableInstrument::has_riskModel() const {
  return riskModel_case() != RISKMODEL_NOT_SET;
}
inline void TradableInstrument::clear_has_riskModel() {
  _oneof_case_[0] = RISKMODEL_NOT_SET;
}
inline TradableInstrument::RiskModelCase TradableInstrument::riskModel_case() const {
  return TradableInstrument::RiskModelCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// FeeFactors

// string makerFee = 1 [json_name = "makerFee"];
inline void FeeFactors::clear_makerfee() {
  makerfee_.ClearToEmpty();
}
inline const std::string& FeeFactors::makerfee() const {
  // @@protoc_insertion_point(field_get:vega.FeeFactors.makerFee)
  return _internal_makerfee();
}
inline void FeeFactors::set_makerfee(const std::string& value) {
  _internal_set_makerfee(value);
  // @@protoc_insertion_point(field_set:vega.FeeFactors.makerFee)
}
inline std::string* FeeFactors::mutable_makerfee() {
  // @@protoc_insertion_point(field_mutable:vega.FeeFactors.makerFee)
  return _internal_mutable_makerfee();
}
inline const std::string& FeeFactors::_internal_makerfee() const {
  return makerfee_.Get();
}
inline void FeeFactors::_internal_set_makerfee(const std::string& value) {

  makerfee_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void FeeFactors::set_makerfee(std::string&& value) {

  makerfee_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vega.FeeFactors.makerFee)
}
inline void FeeFactors::set_makerfee(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  makerfee_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:vega.FeeFactors.makerFee)
}
inline void FeeFactors::set_makerfee(const char* value,
    size_t size) {

  makerfee_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vega.FeeFactors.makerFee)
}
inline std::string* FeeFactors::_internal_mutable_makerfee() {

  return makerfee_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* FeeFactors::release_makerfee() {
  // @@protoc_insertion_point(field_release:vega.FeeFactors.makerFee)
  return makerfee_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void FeeFactors::set_allocated_makerfee(std::string* makerfee) {
  if (makerfee != nullptr) {

  } else {

  }
  makerfee_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), makerfee,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vega.FeeFactors.makerFee)
}

// string infrastructureFee = 2 [json_name = "infrastructureFee"];
inline void FeeFactors::clear_infrastructurefee() {
  infrastructurefee_.ClearToEmpty();
}
inline const std::string& FeeFactors::infrastructurefee() const {
  // @@protoc_insertion_point(field_get:vega.FeeFactors.infrastructureFee)
  return _internal_infrastructurefee();
}
inline void FeeFactors::set_infrastructurefee(const std::string& value) {
  _internal_set_infrastructurefee(value);
  // @@protoc_insertion_point(field_set:vega.FeeFactors.infrastructureFee)
}
inline std::string* FeeFactors::mutable_infrastructurefee() {
  // @@protoc_insertion_point(field_mutable:vega.FeeFactors.infrastructureFee)
  return _internal_mutable_infrastructurefee();
}
inline const std::string& FeeFactors::_internal_infrastructurefee() const {
  return infrastructurefee_.Get();
}
inline void FeeFactors::_internal_set_infrastructurefee(const std::string& value) {

  infrastructurefee_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void FeeFactors::set_infrastructurefee(std::string&& value) {

  infrastructurefee_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vega.FeeFactors.infrastructureFee)
}
inline void FeeFactors::set_infrastructurefee(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  infrastructurefee_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:vega.FeeFactors.infrastructureFee)
}
inline void FeeFactors::set_infrastructurefee(const char* value,
    size_t size) {

  infrastructurefee_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vega.FeeFactors.infrastructureFee)
}
inline std::string* FeeFactors::_internal_mutable_infrastructurefee() {

  return infrastructurefee_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* FeeFactors::release_infrastructurefee() {
  // @@protoc_insertion_point(field_release:vega.FeeFactors.infrastructureFee)
  return infrastructurefee_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void FeeFactors::set_allocated_infrastructurefee(std::string* infrastructurefee) {
  if (infrastructurefee != nullptr) {

  } else {

  }
  infrastructurefee_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), infrastructurefee,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vega.FeeFactors.infrastructureFee)
}

// string liquidityFee = 3 [json_name = "liquidityFee"];
inline void FeeFactors::clear_liquidityfee() {
  liquidityfee_.ClearToEmpty();
}
inline const std::string& FeeFactors::liquidityfee() const {
  // @@protoc_insertion_point(field_get:vega.FeeFactors.liquidityFee)
  return _internal_liquidityfee();
}
inline void FeeFactors::set_liquidityfee(const std::string& value) {
  _internal_set_liquidityfee(value);
  // @@protoc_insertion_point(field_set:vega.FeeFactors.liquidityFee)
}
inline std::string* FeeFactors::mutable_liquidityfee() {
  // @@protoc_insertion_point(field_mutable:vega.FeeFactors.liquidityFee)
  return _internal_mutable_liquidityfee();
}
inline const std::string& FeeFactors::_internal_liquidityfee() const {
  return liquidityfee_.Get();
}
inline void FeeFactors::_internal_set_liquidityfee(const std::string& value) {

  liquidityfee_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void FeeFactors::set_liquidityfee(std::string&& value) {

  liquidityfee_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vega.FeeFactors.liquidityFee)
}
inline void FeeFactors::set_liquidityfee(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  liquidityfee_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:vega.FeeFactors.liquidityFee)
}
inline void FeeFactors::set_liquidityfee(const char* value,
    size_t size) {

  liquidityfee_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vega.FeeFactors.liquidityFee)
}
inline std::string* FeeFactors::_internal_mutable_liquidityfee() {

  return liquidityfee_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* FeeFactors::release_liquidityfee() {
  // @@protoc_insertion_point(field_release:vega.FeeFactors.liquidityFee)
  return liquidityfee_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void FeeFactors::set_allocated_liquidityfee(std::string* liquidityfee) {
  if (liquidityfee != nullptr) {

  } else {

  }
  liquidityfee_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), liquidityfee,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vega.FeeFactors.liquidityFee)
}

// -------------------------------------------------------------------

// Fees

// .vega.FeeFactors factors = 1 [json_name = "factors"];
inline bool Fees::_internal_has_factors() const {
  return this != internal_default_instance() && factors_ != nullptr;
}
inline bool Fees::has_factors() const {
  return _internal_has_factors();
}
inline void Fees::clear_factors() {
  if (GetArena() == nullptr && factors_ != nullptr) {
    delete factors_;
  }
  factors_ = nullptr;
}
inline const ::vega::FeeFactors& Fees::_internal_factors() const {
  const ::vega::FeeFactors* p = factors_;
  return p != nullptr ? *p : reinterpret_cast<const ::vega::FeeFactors&>(
      ::vega::_FeeFactors_default_instance_);
}
inline const ::vega::FeeFactors& Fees::factors() const {
  // @@protoc_insertion_point(field_get:vega.Fees.factors)
  return _internal_factors();
}
inline void Fees::unsafe_arena_set_allocated_factors(
    ::vega::FeeFactors* factors) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(factors_);
  }
  factors_ = factors;
  if (factors) {

  } else {

  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vega.Fees.factors)
}
inline ::vega::FeeFactors* Fees::release_factors() {

  ::vega::FeeFactors* temp = factors_;
  factors_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::vega::FeeFactors* Fees::unsafe_arena_release_factors() {
  // @@protoc_insertion_point(field_release:vega.Fees.factors)

  ::vega::FeeFactors* temp = factors_;
  factors_ = nullptr;
  return temp;
}
inline ::vega::FeeFactors* Fees::_internal_mutable_factors() {

  if (factors_ == nullptr) {
    auto* p = CreateMaybeMessage<::vega::FeeFactors>(GetArena());
    factors_ = p;
  }
  return factors_;
}
inline ::vega::FeeFactors* Fees::mutable_factors() {
  // @@protoc_insertion_point(field_mutable:vega.Fees.factors)
  return _internal_mutable_factors();
}
inline void Fees::set_allocated_factors(::vega::FeeFactors* factors) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete factors_;
  }
  if (factors) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(factors);
    if (message_arena != submessage_arena) {
      factors = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, factors, submessage_arena);
    }

  } else {

  }
  factors_ = factors;
  // @@protoc_insertion_point(field_set_allocated:vega.Fees.factors)
}

// -------------------------------------------------------------------

// PriceMonitoringTrigger

// int64 horizon = 1 [json_name = "horizon", (.validator.field) = {
inline void PriceMonitoringTrigger::clear_horizon() {
  horizon_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PriceMonitoringTrigger::_internal_horizon() const {
  return horizon_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PriceMonitoringTrigger::horizon() const {
  // @@protoc_insertion_point(field_get:vega.PriceMonitoringTrigger.horizon)
  return _internal_horizon();
}
inline void PriceMonitoringTrigger::_internal_set_horizon(::PROTOBUF_NAMESPACE_ID::int64 value) {

  horizon_ = value;
}
inline void PriceMonitoringTrigger::set_horizon(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_horizon(value);
  // @@protoc_insertion_point(field_set:vega.PriceMonitoringTrigger.horizon)
}

// double probability = 2 [json_name = "probability", (.validator.field) = {
inline void PriceMonitoringTrigger::clear_probability() {
  probability_ = 0;
}
inline double PriceMonitoringTrigger::_internal_probability() const {
  return probability_;
}
inline double PriceMonitoringTrigger::probability() const {
  // @@protoc_insertion_point(field_get:vega.PriceMonitoringTrigger.probability)
  return _internal_probability();
}
inline void PriceMonitoringTrigger::_internal_set_probability(double value) {

  probability_ = value;
}
inline void PriceMonitoringTrigger::set_probability(double value) {
  _internal_set_probability(value);
  // @@protoc_insertion_point(field_set:vega.PriceMonitoringTrigger.probability)
}

// int64 auctionExtension = 3 [json_name = "auctionExtension", (.validator.field) = {
inline void PriceMonitoringTrigger::clear_auctionextension() {
  auctionextension_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PriceMonitoringTrigger::_internal_auctionextension() const {
  return auctionextension_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PriceMonitoringTrigger::auctionextension() const {
  // @@protoc_insertion_point(field_get:vega.PriceMonitoringTrigger.auctionExtension)
  return _internal_auctionextension();
}
inline void PriceMonitoringTrigger::_internal_set_auctionextension(::PROTOBUF_NAMESPACE_ID::int64 value) {

  auctionextension_ = value;
}
inline void PriceMonitoringTrigger::set_auctionextension(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_auctionextension(value);
  // @@protoc_insertion_point(field_set:vega.PriceMonitoringTrigger.auctionExtension)
}

// -------------------------------------------------------------------

// PriceMonitoringParameters

// repeated .vega.PriceMonitoringTrigger triggers = 1 [json_name = "triggers"];
inline int PriceMonitoringParameters::_internal_triggers_size() const {
  return triggers_.size();
}
inline int PriceMonitoringParameters::triggers_size() const {
  return _internal_triggers_size();
}
inline void PriceMonitoringParameters::clear_triggers() {
  triggers_.Clear();
}
inline ::vega::PriceMonitoringTrigger* PriceMonitoringParameters::mutable_triggers(int index) {
  // @@protoc_insertion_point(field_mutable:vega.PriceMonitoringParameters.triggers)
  return triggers_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vega::PriceMonitoringTrigger >*
PriceMonitoringParameters::mutable_triggers() {
  // @@protoc_insertion_point(field_mutable_list:vega.PriceMonitoringParameters.triggers)
  return &triggers_;
}
inline const ::vega::PriceMonitoringTrigger& PriceMonitoringParameters::_internal_triggers(int index) const {
  return triggers_.Get(index);
}
inline const ::vega::PriceMonitoringTrigger& PriceMonitoringParameters::triggers(int index) const {
  // @@protoc_insertion_point(field_get:vega.PriceMonitoringParameters.triggers)
  return _internal_triggers(index);
}
inline ::vega::PriceMonitoringTrigger* PriceMonitoringParameters::_internal_add_triggers() {
  return triggers_.Add();
}
inline ::vega::PriceMonitoringTrigger* PriceMonitoringParameters::add_triggers() {
  // @@protoc_insertion_point(field_add:vega.PriceMonitoringParameters.triggers)
  return _internal_add_triggers();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vega::PriceMonitoringTrigger >&
PriceMonitoringParameters::triggers() const {
  // @@protoc_insertion_point(field_list:vega.PriceMonitoringParameters.triggers)
  return triggers_;
}

// -------------------------------------------------------------------

// PriceMonitoringSettings

// .vega.PriceMonitoringParameters parameters = 1 [json_name = "parameters"];
inline bool PriceMonitoringSettings::_internal_has_parameters() const {
  return this != internal_default_instance() && parameters_ != nullptr;
}
inline bool PriceMonitoringSettings::has_parameters() const {
  return _internal_has_parameters();
}
inline void PriceMonitoringSettings::clear_parameters() {
  if (GetArena() == nullptr && parameters_ != nullptr) {
    delete parameters_;
  }
  parameters_ = nullptr;
}
inline const ::vega::PriceMonitoringParameters& PriceMonitoringSettings::_internal_parameters() const {
  const ::vega::PriceMonitoringParameters* p = parameters_;
  return p != nullptr ? *p : reinterpret_cast<const ::vega::PriceMonitoringParameters&>(
      ::vega::_PriceMonitoringParameters_default_instance_);
}
inline const ::vega::PriceMonitoringParameters& PriceMonitoringSettings::parameters() const {
  // @@protoc_insertion_point(field_get:vega.PriceMonitoringSettings.parameters)
  return _internal_parameters();
}
inline void PriceMonitoringSettings::unsafe_arena_set_allocated_parameters(
    ::vega::PriceMonitoringParameters* parameters) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(parameters_);
  }
  parameters_ = parameters;
  if (parameters) {

  } else {

  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vega.PriceMonitoringSettings.parameters)
}
inline ::vega::PriceMonitoringParameters* PriceMonitoringSettings::release_parameters() {

  ::vega::PriceMonitoringParameters* temp = parameters_;
  parameters_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::vega::PriceMonitoringParameters* PriceMonitoringSettings::unsafe_arena_release_parameters() {
  // @@protoc_insertion_point(field_release:vega.PriceMonitoringSettings.parameters)

  ::vega::PriceMonitoringParameters* temp = parameters_;
  parameters_ = nullptr;
  return temp;
}
inline ::vega::PriceMonitoringParameters* PriceMonitoringSettings::_internal_mutable_parameters() {

  if (parameters_ == nullptr) {
    auto* p = CreateMaybeMessage<::vega::PriceMonitoringParameters>(GetArena());
    parameters_ = p;
  }
  return parameters_;
}
inline ::vega::PriceMonitoringParameters* PriceMonitoringSettings::mutable_parameters() {
  // @@protoc_insertion_point(field_mutable:vega.PriceMonitoringSettings.parameters)
  return _internal_mutable_parameters();
}
inline void PriceMonitoringSettings::set_allocated_parameters(::vega::PriceMonitoringParameters* parameters) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete parameters_;
  }
  if (parameters) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(parameters);
    if (message_arena != submessage_arena) {
      parameters = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, parameters, submessage_arena);
    }

  } else {

  }
  parameters_ = parameters;
  // @@protoc_insertion_point(field_set_allocated:vega.PriceMonitoringSettings.parameters)
}

// int64 updateFrequency = 2 [json_name = "updateFrequency"];
inline void PriceMonitoringSettings::clear_updatefrequency() {
  updatefrequency_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PriceMonitoringSettings::_internal_updatefrequency() const {
  return updatefrequency_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PriceMonitoringSettings::updatefrequency() const {
  // @@protoc_insertion_point(field_get:vega.PriceMonitoringSettings.updateFrequency)
  return _internal_updatefrequency();
}
inline void PriceMonitoringSettings::_internal_set_updatefrequency(::PROTOBUF_NAMESPACE_ID::int64 value) {

  updatefrequency_ = value;
}
inline void PriceMonitoringSettings::set_updatefrequency(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_updatefrequency(value);
  // @@protoc_insertion_point(field_set:vega.PriceMonitoringSettings.updateFrequency)
}

// -------------------------------------------------------------------

// TargetStakeParameters

// int64 timeWindow = 1 [json_name = "timeWindow", (.validator.field) = {
inline void TargetStakeParameters::clear_timewindow() {
  timewindow_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TargetStakeParameters::_internal_timewindow() const {
  return timewindow_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TargetStakeParameters::timewindow() const {
  // @@protoc_insertion_point(field_get:vega.TargetStakeParameters.timeWindow)
  return _internal_timewindow();
}
inline void TargetStakeParameters::_internal_set_timewindow(::PROTOBUF_NAMESPACE_ID::int64 value) {

  timewindow_ = value;
}
inline void TargetStakeParameters::set_timewindow(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_timewindow(value);
  // @@protoc_insertion_point(field_set:vega.TargetStakeParameters.timeWindow)
}

// double scalingFactor = 2 [json_name = "scalingFactor", (.validator.field) = {
inline void TargetStakeParameters::clear_scalingfactor() {
  scalingfactor_ = 0;
}
inline double TargetStakeParameters::_internal_scalingfactor() const {
  return scalingfactor_;
}
inline double TargetStakeParameters::scalingfactor() const {
  // @@protoc_insertion_point(field_get:vega.TargetStakeParameters.scalingFactor)
  return _internal_scalingfactor();
}
inline void TargetStakeParameters::_internal_set_scalingfactor(double value) {

  scalingfactor_ = value;
}
inline void TargetStakeParameters::set_scalingfactor(double value) {
  _internal_set_scalingfactor(value);
  // @@protoc_insertion_point(field_set:vega.TargetStakeParameters.scalingFactor)
}

// -------------------------------------------------------------------

// Market

// string id = 1 [json_name = "id"];
inline void Market::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& Market::id() const {
  // @@protoc_insertion_point(field_get:vega.Market.id)
  return _internal_id();
}
inline void Market::set_id(const std::string& value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:vega.Market.id)
}
inline std::string* Market::mutable_id() {
  // @@protoc_insertion_point(field_mutable:vega.Market.id)
  return _internal_mutable_id();
}
inline const std::string& Market::_internal_id() const {
  return id_.Get();
}
inline void Market::_internal_set_id(const std::string& value) {

  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Market::set_id(std::string&& value) {

  id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vega.Market.id)
}
inline void Market::set_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:vega.Market.id)
}
inline void Market::set_id(const char* value,
    size_t size) {

  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vega.Market.id)
}
inline std::string* Market::_internal_mutable_id() {

  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Market::release_id() {
  // @@protoc_insertion_point(field_release:vega.Market.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Market::set_allocated_id(std::string* id) {
  if (id != nullptr) {

  } else {

  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vega.Market.id)
}

// .vega.TradableInstrument tradableInstrument = 2 [json_name = "tradableInstrument"];
inline bool Market::_internal_has_tradableinstrument() const {
  return this != internal_default_instance() && tradableinstrument_ != nullptr;
}
inline bool Market::has_tradableinstrument() const {
  return _internal_has_tradableinstrument();
}
inline void Market::clear_tradableinstrument() {
  if (GetArena() == nullptr && tradableinstrument_ != nullptr) {
    delete tradableinstrument_;
  }
  tradableinstrument_ = nullptr;
}
inline const ::vega::TradableInstrument& Market::_internal_tradableinstrument() const {
  const ::vega::TradableInstrument* p = tradableinstrument_;
  return p != nullptr ? *p : reinterpret_cast<const ::vega::TradableInstrument&>(
      ::vega::_TradableInstrument_default_instance_);
}
inline const ::vega::TradableInstrument& Market::tradableinstrument() const {
  // @@protoc_insertion_point(field_get:vega.Market.tradableInstrument)
  return _internal_tradableinstrument();
}
inline void Market::unsafe_arena_set_allocated_tradableinstrument(
    ::vega::TradableInstrument* tradableinstrument) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(tradableinstrument_);
  }
  tradableinstrument_ = tradableinstrument;
  if (tradableinstrument) {

  } else {

  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vega.Market.tradableInstrument)
}
inline ::vega::TradableInstrument* Market::release_tradableinstrument() {

  ::vega::TradableInstrument* temp = tradableinstrument_;
  tradableinstrument_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::vega::TradableInstrument* Market::unsafe_arena_release_tradableinstrument() {
  // @@protoc_insertion_point(field_release:vega.Market.tradableInstrument)

  ::vega::TradableInstrument* temp = tradableinstrument_;
  tradableinstrument_ = nullptr;
  return temp;
}
inline ::vega::TradableInstrument* Market::_internal_mutable_tradableinstrument() {

  if (tradableinstrument_ == nullptr) {
    auto* p = CreateMaybeMessage<::vega::TradableInstrument>(GetArena());
    tradableinstrument_ = p;
  }
  return tradableinstrument_;
}
inline ::vega::TradableInstrument* Market::mutable_tradableinstrument() {
  // @@protoc_insertion_point(field_mutable:vega.Market.tradableInstrument)
  return _internal_mutable_tradableinstrument();
}
inline void Market::set_allocated_tradableinstrument(::vega::TradableInstrument* tradableinstrument) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete tradableinstrument_;
  }
  if (tradableinstrument) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(tradableinstrument);
    if (message_arena != submessage_arena) {
      tradableinstrument = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tradableinstrument, submessage_arena);
    }

  } else {

  }
  tradableinstrument_ = tradableinstrument;
  // @@protoc_insertion_point(field_set_allocated:vega.Market.tradableInstrument)
}

// uint64 decimalPlaces = 3 [json_name = "decimalPlaces"];
inline void Market::clear_decimalplaces() {
  decimalplaces_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Market::_internal_decimalplaces() const {
  return decimalplaces_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Market::decimalplaces() const {
  // @@protoc_insertion_point(field_get:vega.Market.decimalPlaces)
  return _internal_decimalplaces();
}
inline void Market::_internal_set_decimalplaces(::PROTOBUF_NAMESPACE_ID::uint64 value) {

  decimalplaces_ = value;
}
inline void Market::set_decimalplaces(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_decimalplaces(value);
  // @@protoc_insertion_point(field_set:vega.Market.decimalPlaces)
}

// .vega.Fees fees = 4 [json_name = "fees"];
inline bool Market::_internal_has_fees() const {
  return this != internal_default_instance() && fees_ != nullptr;
}
inline bool Market::has_fees() const {
  return _internal_has_fees();
}
inline void Market::clear_fees() {
  if (GetArena() == nullptr && fees_ != nullptr) {
    delete fees_;
  }
  fees_ = nullptr;
}
inline const ::vega::Fees& Market::_internal_fees() const {
  const ::vega::Fees* p = fees_;
  return p != nullptr ? *p : reinterpret_cast<const ::vega::Fees&>(
      ::vega::_Fees_default_instance_);
}
inline const ::vega::Fees& Market::fees() const {
  // @@protoc_insertion_point(field_get:vega.Market.fees)
  return _internal_fees();
}
inline void Market::unsafe_arena_set_allocated_fees(
    ::vega::Fees* fees) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(fees_);
  }
  fees_ = fees;
  if (fees) {

  } else {

  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vega.Market.fees)
}
inline ::vega::Fees* Market::release_fees() {

  ::vega::Fees* temp = fees_;
  fees_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::vega::Fees* Market::unsafe_arena_release_fees() {
  // @@protoc_insertion_point(field_release:vega.Market.fees)

  ::vega::Fees* temp = fees_;
  fees_ = nullptr;
  return temp;
}
inline ::vega::Fees* Market::_internal_mutable_fees() {

  if (fees_ == nullptr) {
    auto* p = CreateMaybeMessage<::vega::Fees>(GetArena());
    fees_ = p;
  }
  return fees_;
}
inline ::vega::Fees* Market::mutable_fees() {
  // @@protoc_insertion_point(field_mutable:vega.Market.fees)
  return _internal_mutable_fees();
}
inline void Market::set_allocated_fees(::vega::Fees* fees) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete fees_;
  }
  if (fees) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(fees);
    if (message_arena != submessage_arena) {
      fees = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fees, submessage_arena);
    }

  } else {

  }
  fees_ = fees;
  // @@protoc_insertion_point(field_set_allocated:vega.Market.fees)
}

// .vega.AuctionDuration openingAuction = 5 [json_name = "openingAuction"];
inline bool Market::_internal_has_openingauction() const {
  return this != internal_default_instance() && openingauction_ != nullptr;
}
inline bool Market::has_openingauction() const {
  return _internal_has_openingauction();
}
inline void Market::clear_openingauction() {
  if (GetArena() == nullptr && openingauction_ != nullptr) {
    delete openingauction_;
  }
  openingauction_ = nullptr;
}
inline const ::vega::AuctionDuration& Market::_internal_openingauction() const {
  const ::vega::AuctionDuration* p = openingauction_;
  return p != nullptr ? *p : reinterpret_cast<const ::vega::AuctionDuration&>(
      ::vega::_AuctionDuration_default_instance_);
}
inline const ::vega::AuctionDuration& Market::openingauction() const {
  // @@protoc_insertion_point(field_get:vega.Market.openingAuction)
  return _internal_openingauction();
}
inline void Market::unsafe_arena_set_allocated_openingauction(
    ::vega::AuctionDuration* openingauction) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(openingauction_);
  }
  openingauction_ = openingauction;
  if (openingauction) {

  } else {

  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vega.Market.openingAuction)
}
inline ::vega::AuctionDuration* Market::release_openingauction() {

  ::vega::AuctionDuration* temp = openingauction_;
  openingauction_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::vega::AuctionDuration* Market::unsafe_arena_release_openingauction() {
  // @@protoc_insertion_point(field_release:vega.Market.openingAuction)

  ::vega::AuctionDuration* temp = openingauction_;
  openingauction_ = nullptr;
  return temp;
}
inline ::vega::AuctionDuration* Market::_internal_mutable_openingauction() {

  if (openingauction_ == nullptr) {
    auto* p = CreateMaybeMessage<::vega::AuctionDuration>(GetArena());
    openingauction_ = p;
  }
  return openingauction_;
}
inline ::vega::AuctionDuration* Market::mutable_openingauction() {
  // @@protoc_insertion_point(field_mutable:vega.Market.openingAuction)
  return _internal_mutable_openingauction();
}
inline void Market::set_allocated_openingauction(::vega::AuctionDuration* openingauction) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete openingauction_;
  }
  if (openingauction) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(openingauction);
    if (message_arena != submessage_arena) {
      openingauction = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, openingauction, submessage_arena);
    }

  } else {

  }
  openingauction_ = openingauction;
  // @@protoc_insertion_point(field_set_allocated:vega.Market.openingAuction)
}

// .vega.ContinuousTrading continuous = 100 [json_name = "continuous"];
inline bool Market::_internal_has_continuous() const {
  return tradingModeConfig_case() == kContinuous;
}
inline bool Market::has_continuous() const {
  return _internal_has_continuous();
}
inline void Market::set_has_continuous() {
  _oneof_case_[0] = kContinuous;
}
inline void Market::clear_continuous() {
  if (_internal_has_continuous()) {
    if (GetArena() == nullptr) {
      delete tradingModeConfig_.continuous_;
    }
    clear_has_tradingModeConfig();
  }
}
inline ::vega::ContinuousTrading* Market::release_continuous() {
  // @@protoc_insertion_point(field_release:vega.Market.continuous)
  if (_internal_has_continuous()) {
    clear_has_tradingModeConfig();
      ::vega::ContinuousTrading* temp = tradingModeConfig_.continuous_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    tradingModeConfig_.continuous_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vega::ContinuousTrading& Market::_internal_continuous() const {
  return _internal_has_continuous()
      ? *tradingModeConfig_.continuous_
      : reinterpret_cast< ::vega::ContinuousTrading&>(::vega::_ContinuousTrading_default_instance_);
}
inline const ::vega::ContinuousTrading& Market::continuous() const {
  // @@protoc_insertion_point(field_get:vega.Market.continuous)
  return _internal_continuous();
}
inline ::vega::ContinuousTrading* Market::unsafe_arena_release_continuous() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vega.Market.continuous)
  if (_internal_has_continuous()) {
    clear_has_tradingModeConfig();
    ::vega::ContinuousTrading* temp = tradingModeConfig_.continuous_;
    tradingModeConfig_.continuous_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Market::unsafe_arena_set_allocated_continuous(::vega::ContinuousTrading* continuous) {
  clear_tradingModeConfig();
  if (continuous) {
    set_has_continuous();
    tradingModeConfig_.continuous_ = continuous;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vega.Market.continuous)
}
inline ::vega::ContinuousTrading* Market::_internal_mutable_continuous() {
  if (!_internal_has_continuous()) {
    clear_tradingModeConfig();
    set_has_continuous();
    tradingModeConfig_.continuous_ = CreateMaybeMessage< ::vega::ContinuousTrading >(GetArena());
  }
  return tradingModeConfig_.continuous_;
}
inline ::vega::ContinuousTrading* Market::mutable_continuous() {
  // @@protoc_insertion_point(field_mutable:vega.Market.continuous)
  return _internal_mutable_continuous();
}

// .vega.DiscreteTrading discrete = 101 [json_name = "discrete"];
inline bool Market::_internal_has_discrete() const {
  return tradingModeConfig_case() == kDiscrete;
}
inline bool Market::has_discrete() const {
  return _internal_has_discrete();
}
inline void Market::set_has_discrete() {
  _oneof_case_[0] = kDiscrete;
}
inline void Market::clear_discrete() {
  if (_internal_has_discrete()) {
    if (GetArena() == nullptr) {
      delete tradingModeConfig_.discrete_;
    }
    clear_has_tradingModeConfig();
  }
}
inline ::vega::DiscreteTrading* Market::release_discrete() {
  // @@protoc_insertion_point(field_release:vega.Market.discrete)
  if (_internal_has_discrete()) {
    clear_has_tradingModeConfig();
      ::vega::DiscreteTrading* temp = tradingModeConfig_.discrete_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    tradingModeConfig_.discrete_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vega::DiscreteTrading& Market::_internal_discrete() const {
  return _internal_has_discrete()
      ? *tradingModeConfig_.discrete_
      : reinterpret_cast< ::vega::DiscreteTrading&>(::vega::_DiscreteTrading_default_instance_);
}
inline const ::vega::DiscreteTrading& Market::discrete() const {
  // @@protoc_insertion_point(field_get:vega.Market.discrete)
  return _internal_discrete();
}
inline ::vega::DiscreteTrading* Market::unsafe_arena_release_discrete() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vega.Market.discrete)
  if (_internal_has_discrete()) {
    clear_has_tradingModeConfig();
    ::vega::DiscreteTrading* temp = tradingModeConfig_.discrete_;
    tradingModeConfig_.discrete_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Market::unsafe_arena_set_allocated_discrete(::vega::DiscreteTrading* discrete) {
  clear_tradingModeConfig();
  if (discrete) {
    set_has_discrete();
    tradingModeConfig_.discrete_ = discrete;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vega.Market.discrete)
}
inline ::vega::DiscreteTrading* Market::_internal_mutable_discrete() {
  if (!_internal_has_discrete()) {
    clear_tradingModeConfig();
    set_has_discrete();
    tradingModeConfig_.discrete_ = CreateMaybeMessage< ::vega::DiscreteTrading >(GetArena());
  }
  return tradingModeConfig_.discrete_;
}
inline ::vega::DiscreteTrading* Market::mutable_discrete() {
  // @@protoc_insertion_point(field_mutable:vega.Market.discrete)
  return _internal_mutable_discrete();
}

// .vega.PriceMonitoringSettings priceMonitoringSettings = 6 [json_name = "priceMonitoringSettings"];
inline bool Market::_internal_has_pricemonitoringsettings() const {
  return this != internal_default_instance() && pricemonitoringsettings_ != nullptr;
}
inline bool Market::has_pricemonitoringsettings() const {
  return _internal_has_pricemonitoringsettings();
}
inline void Market::clear_pricemonitoringsettings() {
  if (GetArena() == nullptr && pricemonitoringsettings_ != nullptr) {
    delete pricemonitoringsettings_;
  }
  pricemonitoringsettings_ = nullptr;
}
inline const ::vega::PriceMonitoringSettings& Market::_internal_pricemonitoringsettings() const {
  const ::vega::PriceMonitoringSettings* p = pricemonitoringsettings_;
  return p != nullptr ? *p : reinterpret_cast<const ::vega::PriceMonitoringSettings&>(
      ::vega::_PriceMonitoringSettings_default_instance_);
}
inline const ::vega::PriceMonitoringSettings& Market::pricemonitoringsettings() const {
  // @@protoc_insertion_point(field_get:vega.Market.priceMonitoringSettings)
  return _internal_pricemonitoringsettings();
}
inline void Market::unsafe_arena_set_allocated_pricemonitoringsettings(
    ::vega::PriceMonitoringSettings* pricemonitoringsettings) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pricemonitoringsettings_);
  }
  pricemonitoringsettings_ = pricemonitoringsettings;
  if (pricemonitoringsettings) {

  } else {

  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vega.Market.priceMonitoringSettings)
}
inline ::vega::PriceMonitoringSettings* Market::release_pricemonitoringsettings() {

  ::vega::PriceMonitoringSettings* temp = pricemonitoringsettings_;
  pricemonitoringsettings_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::vega::PriceMonitoringSettings* Market::unsafe_arena_release_pricemonitoringsettings() {
  // @@protoc_insertion_point(field_release:vega.Market.priceMonitoringSettings)

  ::vega::PriceMonitoringSettings* temp = pricemonitoringsettings_;
  pricemonitoringsettings_ = nullptr;
  return temp;
}
inline ::vega::PriceMonitoringSettings* Market::_internal_mutable_pricemonitoringsettings() {

  if (pricemonitoringsettings_ == nullptr) {
    auto* p = CreateMaybeMessage<::vega::PriceMonitoringSettings>(GetArena());
    pricemonitoringsettings_ = p;
  }
  return pricemonitoringsettings_;
}
inline ::vega::PriceMonitoringSettings* Market::mutable_pricemonitoringsettings() {
  // @@protoc_insertion_point(field_mutable:vega.Market.priceMonitoringSettings)
  return _internal_mutable_pricemonitoringsettings();
}
inline void Market::set_allocated_pricemonitoringsettings(::vega::PriceMonitoringSettings* pricemonitoringsettings) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete pricemonitoringsettings_;
  }
  if (pricemonitoringsettings) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(pricemonitoringsettings);
    if (message_arena != submessage_arena) {
      pricemonitoringsettings = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pricemonitoringsettings, submessage_arena);
    }

  } else {

  }
  pricemonitoringsettings_ = pricemonitoringsettings;
  // @@protoc_insertion_point(field_set_allocated:vega.Market.priceMonitoringSettings)
}

// .vega.TargetStakeParameters targetStakeParameters = 7 [json_name = "targetStakeParameters"];
inline bool Market::_internal_has_targetstakeparameters() const {
  return this != internal_default_instance() && targetstakeparameters_ != nullptr;
}
inline bool Market::has_targetstakeparameters() const {
  return _internal_has_targetstakeparameters();
}
inline void Market::clear_targetstakeparameters() {
  if (GetArena() == nullptr && targetstakeparameters_ != nullptr) {
    delete targetstakeparameters_;
  }
  targetstakeparameters_ = nullptr;
}
inline const ::vega::TargetStakeParameters& Market::_internal_targetstakeparameters() const {
  const ::vega::TargetStakeParameters* p = targetstakeparameters_;
  return p != nullptr ? *p : reinterpret_cast<const ::vega::TargetStakeParameters&>(
      ::vega::_TargetStakeParameters_default_instance_);
}
inline const ::vega::TargetStakeParameters& Market::targetstakeparameters() const {
  // @@protoc_insertion_point(field_get:vega.Market.targetStakeParameters)
  return _internal_targetstakeparameters();
}
inline void Market::unsafe_arena_set_allocated_targetstakeparameters(
    ::vega::TargetStakeParameters* targetstakeparameters) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(targetstakeparameters_);
  }
  targetstakeparameters_ = targetstakeparameters;
  if (targetstakeparameters) {

  } else {

  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vega.Market.targetStakeParameters)
}
inline ::vega::TargetStakeParameters* Market::release_targetstakeparameters() {

  ::vega::TargetStakeParameters* temp = targetstakeparameters_;
  targetstakeparameters_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::vega::TargetStakeParameters* Market::unsafe_arena_release_targetstakeparameters() {
  // @@protoc_insertion_point(field_release:vega.Market.targetStakeParameters)

  ::vega::TargetStakeParameters* temp = targetstakeparameters_;
  targetstakeparameters_ = nullptr;
  return temp;
}
inline ::vega::TargetStakeParameters* Market::_internal_mutable_targetstakeparameters() {

  if (targetstakeparameters_ == nullptr) {
    auto* p = CreateMaybeMessage<::vega::TargetStakeParameters>(GetArena());
    targetstakeparameters_ = p;
  }
  return targetstakeparameters_;
}
inline ::vega::TargetStakeParameters* Market::mutable_targetstakeparameters() {
  // @@protoc_insertion_point(field_mutable:vega.Market.targetStakeParameters)
  return _internal_mutable_targetstakeparameters();
}
inline void Market::set_allocated_targetstakeparameters(::vega::TargetStakeParameters* targetstakeparameters) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete targetstakeparameters_;
  }
  if (targetstakeparameters) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(targetstakeparameters);
    if (message_arena != submessage_arena) {
      targetstakeparameters = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, targetstakeparameters, submessage_arena);
    }

  } else {

  }
  targetstakeparameters_ = targetstakeparameters;
  // @@protoc_insertion_point(field_set_allocated:vega.Market.targetStakeParameters)
}

// .vega.Market.TradingMode tradingMode = 8 [json_name = "tradingMode"];
inline void Market::clear_tradingmode() {
  tradingmode_ = 0;
}
inline ::vega::Market_TradingMode Market::_internal_tradingmode() const {
  return static_cast< ::vega::Market_TradingMode >(tradingmode_);
}
inline ::vega::Market_TradingMode Market::tradingmode() const {
  // @@protoc_insertion_point(field_get:vega.Market.tradingMode)
  return _internal_tradingmode();
}
inline void Market::_internal_set_tradingmode(::vega::Market_TradingMode value) {

  tradingmode_ = value;
}
inline void Market::set_tradingmode(::vega::Market_TradingMode value) {
  _internal_set_tradingmode(value);
  // @@protoc_insertion_point(field_set:vega.Market.tradingMode)
}

// .vega.Market.State state = 9 [json_name = "state"];
inline void Market::clear_state() {
  state_ = 0;
}
inline ::vega::Market_State Market::_internal_state() const {
  return static_cast< ::vega::Market_State >(state_);
}
inline ::vega::Market_State Market::state() const {
  // @@protoc_insertion_point(field_get:vega.Market.state)
  return _internal_state();
}
inline void Market::_internal_set_state(::vega::Market_State value) {

  state_ = value;
}
inline void Market::set_state(::vega::Market_State value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:vega.Market.state)
}

inline bool Market::has_tradingModeConfig() const {
  return tradingModeConfig_case() != TRADINGMODECONFIG_NOT_SET;
}
inline void Market::clear_has_tradingModeConfig() {
  _oneof_case_[0] = TRADINGMODECONFIG_NOT_SET;
}
inline Market::TradingModeConfigCase Market::tradingModeConfig_case() const {
  return Market::TradingModeConfigCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace vega

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::vega::Market_State> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::vega::Market_State>() {
  return ::vega::Market_State_descriptor();
}
template <> struct is_proto_enum< ::vega::Market_TradingMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::vega::Market_TradingMode>() {
  return ::vega::Market_TradingMode_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_markets_2eproto
